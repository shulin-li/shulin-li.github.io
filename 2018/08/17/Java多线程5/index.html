
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="一条咸鱼">
    <title>Java多线程(五) - 一条咸鱼</title>
    <meta name="author" content="一条咸鱼">
    
    
        <link rel="icon" href="http://yoursite.com/assets/images/favicon.ico">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"一条咸鱼","sameAs":[],"image":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"},"articleBody":"  \n\n介绍读写锁内部有一个ReadLock,一个WriteLock,ReadLock可以被多个线程持有,WriteLock只能被一个线程持有。持有WriteLock的线程可以直接获取ReadLock,持有ReadLock的线程需要先释放ReadLock才能获取WriteLock。所升级(未释放读锁的情况下直接获取写锁)会导致死锁,虽然支持锁降级,但是在持有写锁时获取读锁并不会释放之前的写锁。ReadLock和WriteLock使用了同一个Sync(继承AQS)实例,使用AQS的state表示锁数量,state的高16位表示读锁(共享)数量,低16位表示写锁(独占)数量。  \n内部类/属性HoldCounter每个线程一个实例,用来记录该线程持有的读锁数量。      \n12345static final class HoldCounter &#123;    int count = 0;    //使用id,不使用引用,避免垃圾引用    final long tid = getThreadId(Thread.currentThread());&#125;\nThreadLocalHoldCounter readHolds(属性)继承自ThreadLocal,用来存储HoldCounter  \ncachedHoldCounter(属性)最后一个获取读锁的线程的HoldCounter,不同线程不断获取读锁的过程中,该字段不断更新。该缓存的作用:如果一个线程获取到读锁以后很快就会释放该读锁,那么就不需要去threadLocalMap中查找HoldCounter(乐观思想:获取后很快就会释放)    \nfirstReader/firstReaderHoldCount第一个获取读锁的线程/其读锁数量。如果一个线程使用了firstReader他就不需要使用cacheHoldCounter,主要是考虑在非竞争环境下减少统计readCount的代价  \n读锁lock()/获取读锁跟所有获取锁的流程一样,先调用Sync.tryAcquireShared()    \n1234567891011121314151617181920212223242526272829303132protected final int tryAcquireShared(int unused) &#123;//变量名表明态度......    Thread current = Thread.currentThread();    int c = getState();    //如果有线程获取了写锁,且不是当前线程的话,返回-1    if (exclusiveCount(c) != 0 &amp;&amp;        getExclusiveOwnerThread() != current)        return -1;    int r = sharedCount(c);    //如果不该阻塞且读锁数量没有超过最大值且state高16位+1成功    if (!readerShouldBlock() &amp;&amp;        r &lt; MAX_COUNT &amp;&amp;        compareAndSetState(c, c + SHARED_UNIT)) &#123;        //判断当前线程是否是第一个获取读锁的线程        if (r == 0) &#123;            firstReader = current;            firstReaderHoldCount = 1;        &#125; else if (firstReader == current) &#123;            firstReaderHoldCount++;        &#125; else &#123;            //更新HoldCounter缓存并修改其数值            HoldCounter rh = cachedHoldCounter;            if (rh == null || rh.tid != getThreadId(current))                cachedHoldCounter = rh = readHolds.get();            else if (rh.count == 0)                readHolds.set(rh);            rh.count++;        &#125;        return 1;    &#125;    //获取读锁失败,再次尝试获取    return fullTryAcquireShared(current);&#125;\nreaderShouldBlock()该方法在公平模式下的实现就是判断同步队列中是否已经有结点在等待,下面分析的是非公平模式-&gt;apparentlyFirstQueuedIsExclusive()。123456789final boolean apparentlyFirstQueuedIsExclusive() &#123;    Node h, s;    //判断同步队列中head的后继结点是否是一个等待获取写锁的结点    //表示的是,非公平模式下,写锁的级别要高于读锁(在线程马上要获取到写锁的情况下(因为他就在head后面))    return (h = head) != null &amp;&amp;        (s = h.next)  != null &amp;&amp;        !s.isShared()         &amp;&amp;        s.thread != null;&#125;\nfullTryAcquireShared()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849final int fullTryAcquireShared(Thread current) &#123;    HoldCounter rh = null;    for (;;) &#123;        int c = getState();        //其他线程拿到了写锁,返回,加入同步队列        if (exclusiveCount(c) != 0) &#123;            if (getExclusiveOwnerThread() != current)                return -1;        //如果没有线程获取写锁,同步队列中有线程在排队(不论公平还是非公平)        &#125; else if (readerShouldBlock()) &#123;            //firstReader的重入,放行            if (firstReader == current) &#123;            &#125; else &#123;                if (rh == null) &#123;                    rh = cachedHoldCounter;                    //如果cacheHoldCounter缓存的不是当前线程且当前线程不是重入的,那么需要排队                    if (rh == null || rh.tid != getThreadId(current)) &#123;                        rh = readHolds.get();                        if (rh.count == 0)                            readHolds.remove();                    &#125;                &#125;//非重入,去排队                if (rh.count == 0)                    return -1;            &#125;        &#125;//前面的操作返回了\"其他线程拿到了写锁\"/\"同步队列有阻塞线程情况下的非重入线程\"两种情况        if (sharedCount(c) == MAX_COUNT)            throw new Error(\"Maximum lock count exceeded\");        if (compareAndSetState(c, c + SHARED_UNIT)) &#123;            //第一个获取读锁的线程,更新firstReader/firstReaderCount            if (sharedCount(c) == 0) &#123;                firstReader = current;                firstReaderHoldCount = 1;            &#125; else if (firstReader == current) &#123;                firstReaderHoldCount++;            &#125; else &#123;//更新cacheHoldCounter                if (rh == null)                    rh = cachedHoldCounter;                if (rh == null || rh.tid != getThreadId(current))                    rh = readHolds.get();                else if (rh.count == 0)                    readHolds.set(rh);                rh.count++;                cachedHoldCounter = rh; // cache for release            &#125;            return 1;        &#125;    &#125;&#125;\n最终获取读锁失败(返回值&lt;0),doAcquireShared入队。  \nunlock()/解锁Sync.tryReleaseShared()1234567891011121314151617181920212223242526272829protected final boolean tryReleaseShared(int unused) &#123;    Thread current = Thread.currentThread();    if (firstReader == current) &#123;        //如果当前线程是firstReader,那么将firstReader置null(不再持有锁)或--其读锁数量        if (firstReaderHoldCount == 1)            firstReader = null;        else            firstReaderHoldCount--;    &#125; else &#123;//如果当前线程是cacheHoldCounter对应的线程,那么将其HoldCounter移除(不再持有锁)或--其读锁数量        HoldCounter rh = cachedHoldCounter;        if (rh == null || rh.tid != getThreadId(current))            rh = readHolds.get();        int count = rh.count;        if (count &lt;= 1) &#123;            readHolds.remove();            if (count &lt;= 0)                throw unmatchedUnlockException();        &#125;        --rh.count;    &#125;    for (;;) &#123;        int c = getState();        int nextc = c - SHARED_UNIT;        if (compareAndSetState(c, nextc))            //nextc是state高16位-1的值,如果==0,说明读锁写锁都无人获取,            // 返回true-&gt;调用doReleaseShared唤醒同步队列的后继结点(等待获取写锁的线程)            return nextc == 0;    &#125;&#125;\n写锁lock()/获取写锁12345678910111213141516171819202122protected final boolean tryAcquire(int acquires) &#123;    Thread current = Thread.currentThread();    int c = getState();    int w = exclusiveCount(c);    if (c != 0) &#123;        //c!=0说明有线程获取了锁-&gt;\"有线程获取了读锁\"/\"不是当前线程获取的写锁\",返回,同步队列阻塞。        if (w == 0 || current != getExclusiveOwnerThread())            return false;        //当前线程的写锁重入,更新写锁值        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)            throw new Error(\"Maximum lock count exceeded\");        //一定是写锁重入,不需要CAS        setState(c + acquires);        return true;    &#125;//公平模式判断同步队列是否有阻塞线程,非公平模式直接返回false    if (writerShouldBlock() ||        !compareAndSetState(c, c + acquires))        return false;    //成功获取写锁后,设置写锁线程,返回    setExclusiveOwnerThread(current);    return true;&#125;\n写锁获取失败,调用AQS.acquireQueued()进入同步队列阻塞。  \nunlock()/解锁AQS.release()12345678910public final boolean release(int arg) &#123;    if (tryRelease(arg)) &#123;        Node h = head;        //唤醒后继结点线程        if (h != null &amp;&amp; h.waitStatus != 0)            unparkSuccessor(h);        return true;    &#125;    return false;&#125;\nSync.tyrRelease()123456789101112protected final boolean tryRelease(int releases) &#123;    if (!isHeldExclusively())        throw new IllegalMonitorStateException();    //更新写锁数量    int nextc = getState() - releases;    boolean free = exclusiveCount(nextc) == 0;    if (free)        setExclusiveOwnerThread(null);    setState(nextc);    //写锁全部释放,返回true,唤醒线程    return free;&#125;\n参考Javadoop的博客","dateCreated":"2018-08-17T11:20:37+08:00","dateModified":"2019-03-09T21:30:06+08:00","datePublished":"2018-08-17T11:20:37+08:00","description":"Java多线程(五)源码:AQS/ReentrantReadWriteLock","headline":"Java多线程(五)","image":["https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/weekly3/Java.png","https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2018/08/17/Java多线程5/"},"publisher":{"@type":"Organization","name":"一条咸鱼","sameAs":[],"image":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg","logo":{"@type":"ImageObject","url":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"}},"url":"http://yoursite.com/2018/08/17/Java多线程5/","thumbnailUrl":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/weekly3/Java.png"}</script>
    <meta name="description" content="Java多线程(五)源码:AQS/ReentrantReadWriteLock">
<meta property="og:type" content="blog">
<meta property="og:title" content="Java多线程(五)">
<meta property="og:url" content="http://yoursite.com/2018/08/17/Java多线程5/index.html">
<meta property="og:site_name" content="一条咸鱼">
<meta property="og:description" content="Java多线程(五)源码:AQS/ReentrantReadWriteLock">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2019-03-09T13:30:06.105Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java多线程(五)">
<meta name="twitter:description" content="Java多线程(五)源码:AQS/ReentrantReadWriteLock">
<meta property="fb:app_id" content="[object Object]">
    
    
        
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"/>
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/weekly3/Java.png"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/weekly3/Java.png" />
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg" />
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-du2xmrqdqrl2ollgeiw050kpl6l4nbyz7bumjuurjgsxyopifvukebxc9lqe.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">一条咸鱼</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
                </a>
                <h4 class="sidebar-profile-name">一条咸鱼</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Java Developer</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="首页">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link open-algolia-search" href="/all-archives" title="归档">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/about" title="关于">
                    
                        <i class="sidebar-button-icon fa fa-user" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-center
                    post-header-cover--full" style="background-image:url('https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg');" data-behavior="4">
            
                <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            Java多线程(五)
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-08-17T11:20:37+08:00">
	
		    8月 17, 2018
    	
    </time>
    
</div>

    
</div>

            
        </div>

            <div id="main" data-behavior="4"
                 class="hasCover
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <!-- excerpt -->  <p></p>
<h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#介绍"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#内部类-属性"><span class="toc-text">内部类/属性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HoldCounter"><span class="toc-text">HoldCounter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocalHoldCounter-readHolds-属性"><span class="toc-text">ThreadLocalHoldCounter readHolds(属性)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cachedHoldCounter-属性"><span class="toc-text">cachedHoldCounter(属性)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#firstReader-firstReaderHoldCount"><span class="toc-text">firstReader/firstReaderHoldCount</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#读锁"><span class="toc-text">读锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lock-获取读锁"><span class="toc-text">lock()/获取读锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#readerShouldBlock"><span class="toc-text">readerShouldBlock()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fullTryAcquireShared"><span class="toc-text">fullTryAcquireShared()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unlock-解锁"><span class="toc-text">unlock()/解锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#写锁"><span class="toc-text">写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lock-获取写锁"><span class="toc-text">lock()/获取写锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unlock-解锁-1"><span class="toc-text">unlock()/解锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>读写锁内部有一个ReadLock,一个WriteLock,ReadLock可以被多个线程持有,WriteLock只能被一个线程持有。持有WriteLock的线程可以直接获取ReadLock,持有ReadLock的线程需要先释放ReadLock才能获取WriteLock。<br>所升级(未释放读锁的情况下直接获取写锁)会导致死锁,虽然支持锁降级,但是在持有写锁时获取读锁并不会释放之前的写锁。<br>ReadLock和WriteLock使用了同一个Sync(继承AQS)实例,使用AQS的state表示锁数量,state的高16位表示读锁(共享)数量,低16位表示写锁(独占)数量。  </p>
<h1 id="内部类-属性"><a href="#内部类-属性" class="headerlink" title="内部类/属性"></a>内部类/属性</h1><h2 id="HoldCounter"><a href="#HoldCounter" class="headerlink" title="HoldCounter"></a>HoldCounter</h2><p>每个线程一个实例,用来记录该线程持有的读锁数量。      </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//使用id,不使用引用,避免垃圾引用</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ThreadLocalHoldCounter-readHolds-属性"><a href="#ThreadLocalHoldCounter-readHolds-属性" class="headerlink" title="ThreadLocalHoldCounter readHolds(属性)"></a>ThreadLocalHoldCounter readHolds(属性)</h2><p>继承自ThreadLocal,用来存储HoldCounter  </p>
<h2 id="cachedHoldCounter-属性"><a href="#cachedHoldCounter-属性" class="headerlink" title="cachedHoldCounter(属性)"></a>cachedHoldCounter(属性)</h2><p>最后一个获取读锁的线程的HoldCounter,不同线程不断获取读锁的过程中,该字段不断更新。该缓存的作用:<br>如果一个线程获取到读锁以后很快就会释放该读锁,那么就不需要去threadLocalMap中查找HoldCounter(乐观思想:获取后很快就会释放)    </p>
<h2 id="firstReader-firstReaderHoldCount"><a href="#firstReader-firstReaderHoldCount" class="headerlink" title="firstReader/firstReaderHoldCount"></a>firstReader/firstReaderHoldCount</h2><p>第一个获取读锁的线程/其读锁数量。如果一个线程使用了firstReader他就不需要使用cacheHoldCounter,主要是考虑在非竞争环境下减少统计readCount的代价  </p>
<h1 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h1><h2 id="lock-获取读锁"><a href="#lock-获取读锁" class="headerlink" title="lock()/获取读锁"></a>lock()/获取读锁</h2><p>跟所有获取锁的流程一样,先调用Sync.tryAcquireShared()    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;<span class="comment">//变量名表明态度......</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">//如果有线程获取了写锁,且不是当前线程的话,返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">//如果不该阻塞且读锁数量没有超过最大值且state高16位+1成功</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="comment">//判断当前线程是否是第一个获取读锁的线程</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//更新HoldCounter缓存并修改其数值</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取读锁失败,再次尝试获取</span></span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="readerShouldBlock"><a href="#readerShouldBlock" class="headerlink" title="readerShouldBlock()"></a>readerShouldBlock()</h3><p>该方法在公平模式下的实现就是判断同步队列中是否已经有结点在等待,下面分析的是非公平模式-&gt;apparentlyFirstQueuedIsExclusive()。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node h, s;</span><br><span class="line">    <span class="comment">//判断同步队列中head的后继结点是否是一个等待获取写锁的结点</span></span><br><span class="line">    <span class="comment">//表示的是,非公平模式下,写锁的级别要高于读锁(在线程马上要获取到写锁的情况下(因为他就在head后面))</span></span><br><span class="line">    <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        !s.isShared()         &amp;&amp;</span><br><span class="line">        s.thread != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="fullTryAcquireShared"><a href="#fullTryAcquireShared" class="headerlink" title="fullTryAcquireShared()"></a>fullTryAcquireShared()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">//其他线程拿到了写锁,返回,加入同步队列</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果没有线程获取写锁,同步队列中有线程在排队(不论公平还是非公平)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">//firstReader的重入,放行</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="comment">//如果cacheHoldCounter缓存的不是当前线程且当前线程不是重入的,那么需要排队</span></span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="comment">//非重入,去排队</span></span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//前面的操作返回了"其他线程拿到了写锁"/"同步队列有阻塞线程情况下的非重入线程"两种情况</span></span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="comment">//第一个获取读锁的线程,更新firstReader/firstReaderCount</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//更新cacheHoldCounter</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终获取读锁失败(返回值&lt;0),doAcquireShared入队。  </p>
<h2 id="unlock-解锁"><a href="#unlock-解锁" class="headerlink" title="unlock()/解锁"></a>unlock()/解锁</h2><p>Sync.tryReleaseShared()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">//如果当前线程是firstReader,那么将firstReader置null(不再持有锁)或--其读锁数量</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果当前线程是cacheHoldCounter对应的线程,那么将其HoldCounter移除(不再持有锁)或--其读锁数量</span></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">//nextc是state高16位-1的值,如果==0,说明读锁写锁都无人获取,</span></span><br><span class="line">            <span class="comment">// 返回true-&gt;调用doReleaseShared唤醒同步队列的后继结点(等待获取写锁的线程)</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h1><h2 id="lock-获取写锁"><a href="#lock-获取写锁" class="headerlink" title="lock()/获取写锁"></a>lock()/获取写锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//c!=0说明有线程获取了锁-&gt;"有线程获取了读锁"/"不是当前线程获取的写锁",返回,同步队列阻塞。</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//当前线程的写锁重入,更新写锁值</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">//一定是写锁重入,不需要CAS</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="comment">//公平模式判断同步队列是否有阻塞线程,非公平模式直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//成功获取写锁后,设置写锁线程,返回</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写锁获取失败,调用AQS.acquireQueued()进入同步队列阻塞。  </p>
<h2 id="unlock-解锁-1"><a href="#unlock-解锁-1" class="headerlink" title="unlock()/解锁"></a>unlock()/解锁</h2><p>AQS.release()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">//唤醒后继结点线程</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Sync.tyrRelease()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//更新写锁数量</span></span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="comment">//写锁全部释放,返回true,唤醒线程</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://javadoop.com/post/reentrant-read-write-lock" target="_blank" rel="noopener">Javadoop的博客</a></p>
            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/21/Java多线程6/" data-tooltip="Java多线程(六)" aria-label="上一篇: Java多线程(六)">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/16/Java多线程4/" data-tooltip="Java多线程(四)" aria-label="下一篇: Java多线程(四)">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 一条咸鱼. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/21/Java多线程6/" data-tooltip="Java多线程(六)" aria-label="上一篇: Java多线程(六)">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/16/Java多线程4/" data-tooltip="Java多线程(四)" aria-label="下一篇: Java多线程(四)">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-times"></i>
    <ul class="share-options">
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
        
            <h4 id="about-card-name">一条咸鱼</h4>
        
            <div id="about-card-bio"><p>重庆</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>学生</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/sideCover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-vufjrm3fmbuttogo1hxuu0w9w0sesk5iyysjuguc2hdhufot9szxg8twijry.min.js"></script>
<!--SCRIPTS END-->

    



    </body>
</html>
