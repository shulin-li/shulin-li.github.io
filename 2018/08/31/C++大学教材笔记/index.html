
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="一条咸鱼">
    <title>C++大学教材笔记 - 一条咸鱼</title>
    <meta name="author" content="一条咸鱼">
    
    
        <link rel="icon" href="http://yoursite.com/assets/images/favicon.ico">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"一条咸鱼","sameAs":[],"image":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"},"articleBody":"\n\n1.C++简介预处理执行诸如“包含其他要编译的文件”/“实现文本的替换”的预处理指令,以“#”开始的语句都由预处理器处理。  \n编译程序到机器语言的过程。  \n链接程序都会引用在其他库(标准库/私有库)中定义的函数/数据,链接器将这些函数/数据代码与之前编译的代码链接起来以形成最终的可执行程序。  \n载入载入器将可执行程序传入到内存中。  \n2.C++编程入门内存的概念变量名对应着内存中的特定区域,可以理解为一种映射关系?这种“映射关系”由编译器维护。  \n3.类,对象和字符串的介绍定义类以关键字“class”+类名定义类(类名与Java一样),定义方面与Java不同的是C++的类访问控制符写在定义中。12345678910111213141516171819202122232425class MyClass&#123;public:  MyClass(std::string user_name)//constructor method    :name(user_name)  &#123;//empyt body  &#125;  void set_name(std::string user_name)  &#123;    name = user_name;  &#125;  std::string get_name() const  &#123;    return name;  &#125;    void say_hello() const  &#123;    std::cout&lt;&lt;\"Hello \"&lt;&lt; name;  &#125;private:  std::string name;&#125;;\n上述的类声明中,将所有的函数声明为public,成员变量声明为private,访问控制符含义与Java一致。但是与Java不同的是,编译器并不在程序运行期间检查访问控制符,即如果通过private变量的指针对其进行访问,可以突破访问控制限制。构造函数中在方法名后接“:”采用的是成员初始化列表,如果含有多个数据成员则用逗号分开,成员初始化列表在构造函数体执行前执行,该方法初始化效率更高(原书这么说,但是没有解释高在哪里,对此,只能说一句“高到不知道哪里去了”)。函数中有两个函数后面声明了“const”,表明该方法不修改对象的值,这样的声明可以由编译器进行保证(不修改值的方法应该都声明为const—-最小特权)。  \n可复用性以及接口和实现分离头文件在C++开发中,通常将可复用代码(如类定义)抽离为一个单独文件,称之为头文件(.h),头文件中不能包含“using”指令/声明,其他文件使用#include预处理指令来包含头文件,通过包含头文件,编译器就能确定一个类的对象的大小,自定义的头文件在include包含时应使用双引号,这样预处理器会在写有include指令的文件所在的文件夹下寻找该头文件,没找到或使用&lt;&gt;包含,预处理器会去标准库中寻找。   \n分离为了只暴露接口而隐藏函数实现细节,会将类拆分为.h+.cpp两个文件,.h文件中声明,.cpp文件中定义(实现)。MyClass.h \n12345678910111213# include&lt;string&gt;class MyClass&#123;  public:    MyClass(std::string user_name);    void set_name(std::string user_name);    std::string get_name() const;    void say_hello();  private:    std:string name;&#125;;\nMyClass.cpp1234567891011121314151617181920212223#include&lt;iostream&gt;#include\"MyClass.h\"using namespace std;MyClass::MyClass(string user_name)  :name(user_name)  &#123;  &#125;void MyClass::set_name(string user_name)&#123;  name = user_name;&#125;string MyClass::get_name() const&#123;  return name;&#125;void MyClass::say_hello() const&#123;  cout&lt;&lt;\"Hello \"&lt;&lt;name;&#125;\nMyClass.cpp包含MyClass.h,编译器在编译MyClass.cpp时就可以使用头文件中的信息确保每一个函数都与类定义中的函数原型匹配,同时成员函数的定义(cpp文件)也可以访问访问成员变量(h文件)。test.cpp12345678910#include &lt;iostream&gt;#include \"MyClass.h\"using namespace std;int main()&#123;  MyClass one(\"tom\");  MyClass two(\"jack\");  cout&lt;&lt;one.get_name()&lt;&lt;endl&lt;&lt;one.say_hello()&lt;&lt;endl;  cout&lt;&lt;two.get_name()&lt;&lt;endl&lt;&lt;two.say_hello()&lt;&lt;endl;&#125;\n使用类的文件中只需要包含类的头文件,在链接过程中,需要将MyClass.cpp和test.cpp进行链接。  \n4.控制/赋值/自增自减else摇摆C++编译器将else同它之前最近的if联系起来(如果没有花括号)123456if(x&gt;5)  if(y&gt;5)    cout&lt;&lt;\"x and y are &gt;5\";else  cout&lt;&lt;\"x is &lt;=5\";\n对于这类的语句,编译器将else和第二个if(y&gt;5)对应,导致输出可能与预想的不一样(这个问题Java也有,而且idea在输完第一个System.out.println(“x and y ard &gt;5”);回车后自动与第一个if对齐……)。  \n基本类型间显式和隐式转换C++提供static_const运算符以进行强制类型转换,该转换只是提供一个转换后的副本,原数据类型并不改变。12int a = 10;double b = static_const&lt;double&gt;(a);\nb被赋值为a的double版本,但a仍然是int类型。  \n列表初始化使用列表初始化可以初始化任意类型的变量。1Employee employee&#123;\"Jack\",\"2000\",\"run\"&#125;\n列表初始化器可以阻止“缩小转换”12int a = 12.7;int b &#123;12.7&#125;\n第一种写法可能仅仅是警告,第二种无法通过编译。  \n自增自减自增自减运算符的操作数不可以是表达式,只能是已经定义的变量(这一点其实与Java一样,但我从没注意过……)。  \n5.控制语句和逻辑运算符浮点型由于浮点值是近似的,所以不应将浮点值用于控制判断。  \n=/==与Java不同,在需要bool类型的判断时,C++将所有的非0值解释为true。12345int a;if(a = 3)&#123;//......&#125;\nif中的赋值表达式的值为3,被解释为true,这种情况编译时并不会报错……  \n左值/右值凡是可以在赋值运算符左边使用的值都称为左值,常量称之为右值,左值可以用做右值,但反之不行。另外C++允许“x==1“这样的语句通过编译,Java则认为这不是一个statement……  \n6.函数和递归函数的实参在调用函数时,有时候函数的实参是一样复杂的表达式或是调用其他函数的返回值,这时编译器并不保证按照顺序对实参求值,所以可能出现与预想不一致的情况。  \n存储类别/链接性/作用域存储期/链接性存储期决定标识符在内存中存在的时间。链接性决定标识符是只在声明他的源文件中可以识别还是在经编译后链接在一起的多个文件中可以识别。    \n自动存储期在函数中声明的局部变量或者函数的形参都属于自动存储期,在执行到定义语句块时创建,退出语句块时自动销毁,只存在最接近他的花括号内。register关键词用于建议编译器将局部变量或函数形参放到寄存器内,但是编译器可以忽略register声明,不建议使用。自动存储期的变量没有链接性。  \n静态存储期关键词extern和static为函数和具有静态存储期的变量声明标识符。静态存储期变量从程序开始执行直到程序执行结束,一直存在于内存中,用static声明的函数内局部变量,哪怕函数被调用多次也只会声明一次,同时函数返回后其值不变。static变量链接性为内部。extern变量链接性为外部\n作用域作用域指出标识符可以被引用的范围。  \n语句块作用域在一个语句块中声明的标识符的作用域开始于标识符声明处,结束于语句块的右花括号,当出现嵌套语句块,且内层变量名与外层变量名相同时,程序执行到内存时,内层变量隐藏外层变量。出了内层循环时,外层变量可见。12345678int a = 1;cout &lt;&lt; a &lt;&lt; endl;//1&#123;  int a = 2;  cout &lt;&lt; a &lt;&lt; endl;//2&#125;cout &lt;&lt; a &lt;&lt; endl;//1\n全局命名空间作用域声明于任何函数或类之外的标识符具有全局命名空间作用域,其作用域从声明处开始直到文件结尾(注意是文件！！！)。\n链接性链接性决定标识符是只在声明他的源文件中可以识别还是在经编译后链接在一起的多个文件中可以识别。  \n内联函数通过在函数的返回类型前使用”inline“关键字,可以建议编译器在适当的时候在调用该函数的地方直接生成该函数的函数体代码,内联函数一般放在头文件以便于复用,即使没用声明为inline编译器的优化可能也会自动采用内联。  \n引用和引用形参按值传递的函数形参传递方式会在函数调用堆栈上生成实参值的副本,按引用传递时,函数可以直接修改原数据。声明形参按引用传递只需在类型名后加&amp;,在调用函数时直接传递变量名即可。1234567void test(int&amp; a)&#123;  //......&#125;int b = 2;test(b);\n如果在被调用函数中声明了一个引用,并且在函数最后需要return这个引用,那么需要将该引用声明为static,否则该引用变量会随函数出栈而被销毁。  \n默认实参函数调用时,可以为函数形参设置默认值,如果调用该函数时没有传入相应值,那么采用默认值,默认实参必须是参数列表中最靠右边的,在调用函数时,实参按从左到右的顺序给形参赋值。默认值在函数原型中声明即可。123456void test(int a,int b=1,int c=2)&#123;  //......&#125;test(1,2)//a = 1;b = 2; c = 2;\n一元作用域分辨运算符局部变量和全局变量可以同名,C++提供::运算符来显式的访问全局变量,但::不能用来访问外层语句块中同名的局部变量。  \n函数重载函数重载基本与Java相同,但是要主要的是,如果含有默认实参的函数和重载函数在调用时可能能匹配多个函数从而产生二义性,那么无法通过编译。12345678void test4(int a,int b = 2,int c =2 );void test4(int a,int b);int main()&#123;\ttest4(1, 2);\tcin.get();&#125;\n函数模板函数模板就是泛型编程,当调用函数模板提供实参类型时,C++自动生成独立的函数模板特化。函数模板必须要以template开头。1234567891011121314template&lt;class T&gt; T test5(T a);int main()&#123;\ttest5(1);\tcin.get();&#125;template&lt;class T&gt;T test5(T a)&#123;\tcout &lt;&lt; a;\treturn ++a;&#125;\n7.类模板array和vector,异常和捕获array对象array对象是一组具有相同类型且连续的内存区域。123# include&lt;array&gt;array &lt;int,5&gt; my_array = &#123;1,2,3,4,5&#125;;\n在使用[]运算符以下标访问array对象的元素时C++没有提供自动的边界范围检测,范围越界时也不会产生警告,所以可能访问到无效的值,array对象提供了at函数用来访问元素,该函数带有下标范围检测的功能。  \nvector对象vector支持动态的大小调整,对于vector对象,可以使用!=/==来进行vector内元素的比较。  \n8.指针指针变量将内存地址作为值,传递指针是C++中的第二种引用传递,本质上说所有的参数都是按值传递的,在传递指针时,也是将实参的指针值复制到形参中。  \n内置数组内置数组的名字会隐式转化为内置数组中第一个元素的地址,内置数组并不知道自己的大小,内置数组无法使用关系和相等运算符进行比较也不能相互赋值。  \nconst修饰指针1const int * ptr;\n指向const数据的非const指针,该类指针表示不能当过该指针修改其指向的数据(const数据),但该指针可以修改以用于指向其他数据(非const指针)。  \n1int * const ptr;\n指向非const数据的const指针,可以通过该指针修改其指向的数据(非const数据),但是该指针不能修改以指向其他数据(const指针)。  \n1const int * const ptr;\n指向const数据的const指针,最严格。   \nsizeof不同系统,各类型数据所占字节数可能不同,可以使用sizeof来确定,sizeof是编译时运算符,他的操作数不会被求值。  \n指针算数运算一个指针可以加减,以使其指向其他内存区域,当指针加/减一个整数时,其实是加/减这个整数与指针指向对象的字节大小的乘积。  \n指针赋值如果两个指针是同一类型的,那么可以赋值,否则要使用强制类型转换。void*是一种通用指针,任何类型的指针都可以直接赋值给void*类型的指针,反之则不行。  \n9.类/抛出异常类的定义为了防止在构建程序时不小心重复包含头文件(可能有各种间接包含)带来的编译错误,一般使用#ifndef/#define/#endif12345678910111213#ifndef TIME_H#define TIME_Hclass Time&#123;  public:    Time();    void test();  private:    int hour;&#125;;#endif\n如果没有定义”TIME_H“那么define和endif之间的代码就会被包含,这样通过定义TIME_H就可以防止重复包含,习惯上定义使用大写的头文件名,并用下划线代替圆点。  \n析构函数析构函数名为类名前加”~“,当对像被销毁时,其析构函数隐式的被调用,主要用来释放内存,调用析构函数的顺序与构造函数完全相反。  \nconst对象和const成员函数变量和对象声明为const可能可以提升程序性能,因为编译器会为这些常量提供更多的优化。对于const对象,其只能调用const成员函数,哪怕某些非const成员函数并没有修改数据。如果某些对象作为类的成员存在,这些成员对象以在类的定义中声明的顺序(不是以构造函数中的成员初始化器的顺序)创建。在创建对象时,成员对象如果没有显示初始化,那么会自动调用成员对象的默认构造函数。如果成员对象的类没有构造函数且没有对该成员对象使用初始化器,那么无法通过编译。  \n友元类的友元在类的作用域之外定义,但是可以访问类的private数据。12345678910111213141516171819class  Count&#123;  friend void set_x(Count &amp;,int);//friend method  friend class ClassOne;//friend class  public:    Count()      :x(0)    &#123;&#125;    void print() const;  private     int x;&#125;;void set_x(Count &amp; c,int val)&#123;  c.x = val;&#125;\nset_x就是类Count的友元函数,其可以访问private数据x,ClassTwo是类Count的友元类,其中的所有函数都是Count的友元函数。  \nthis指针与Java的this引用一样,指向当前对象,但this指针并不是对象的一部分,sizeof运算结果不包含this指针大小,this指针作为一个隐式参数被编译器传递个每个对象的每个非static函数,this指针类型取决于对象类型和函数类型。  \nstatic类成员static类成员的默认构造函数会被默认调用,可以不用手动初始化,使用类名::成员名引用static成员。static函数与Java一样。  \n10.运算符重载:string类运算符重载使用operator关键字指定要重载的运算符,重载运算符后,运算符的优先级不会改变,重载(),[],-&gt;即其他赋值运算符时,重载函数必须被声明为类成员函数。123456789class String&#123;  public    bool operator&lt;(const String &amp;) const;&#125;;String y;String x;y&lt;x// -&gt;  y.operator&lt;(x);\n对于上面的重载操作符,要求做操作数必须要改类的一个对象。同时还有另外一种重载形式。1234567bool operator&lt;(const String &amp; a,const String &amp; b)&#123;  //......&#125;String x;String y;x&lt;y   //  -&gt;  operator&lt;(x,y);\n当重载++/–操作符时,建议采用前置操作符,因为后值操作符时需要创建临时对象,影响性能。  \n动态内存管理使用new运算符分配的内存在堆中,其无法随函数出入栈而自动收回,必须使用delete手动的释放内存。12Count* c = new Count[5];delete [] c;\ndelete时,先会调用Count数组中每一个对象的析构函数,然后回收数组的内存空间,将该空间返回给自由存储区,此时该内存才可以继续被使用。在delete时,如果不加[],那么有可能只调用第一个对象的析构函数(各编译器实现不同)。  \n拷贝构造函数/赋值函数12345Array integers1;Array integers2(integers1) //1.Array integers3 = integers // 2.Array integers4;integers4 = integers1; //3.\n上述代码中1,2都是调用的Array类的拷贝构造函数,3调用的是赋值函数(运算符重载),=如果出现在变量声明的地方,那么就是拷贝构造函数。在这两个函数中需要注意的是,如果只是把源对象的指针复制到目标对象的指针,那么在某一个对象调用析构函数释放这一块内存时,另一个对象可能就会出错。  \n类型转换/explicit构造函数123Count::operatr char *()Count s;static_cast&lt;char *&gt;(s);  //  -&gt; s.operator char *();\n通过重载转换运算符,可以指定自己的类型转换方式。  \n任何单参数的构造函数都可以被编译器用来执行隐式转换。123456789101112131415161718192021class Array&#123;  public:    Array(int 10);  private;    int * ptr;&#125;Array:Array(int size)  :ptr(new int[size])&#123;&#125;int main&#123;  outputArray(3);&#125;void outputArray(const Array&amp; array)&#123;// ......&#125;\n上面的main函数中,调用outputArray并传入3,但是outputArray接受的是Array对象的引用,于是编译器尝试将3转化为Array对象,发现Array类有一个单参数的构造函数,于是隐式调用该构造函数将3转化为一个临时的Array对象并传给outputArray函数,但这种情况可能并不是我们想要的,可以通过在单参数构造函数前加关键字explicit,来禁止该构造函数被隐式调用。  \n11.继承C++提供三种继承,public/protected/private。  \n基类和派生类12345678class Dog : public Animal&#123;  private int x;//......&#125;;Dog::Dog(int a,int b.int c,int d)  :Animal(a,b,c),x(d);\nDog public继承自Animal,基类的private成员已被派生类继承,但是派生类不能直接访问(可通过函数),友元是不能被继承的,继承时派生类继承了基类除了构造函数和析构函数外的所有函数,但是派生类在构造函数时需要主动的调用基类的构造函数以初始化那些继承到派生类中的基类成员,否则的话编译器会隐式调用基类的默认构造函数,如果没有的话,报错。派生类需要#include基类的头文件,以使编译器确定基类对象的大小  \n12.多态派生类对象调用基类函数将派生类对象赋给基类指针,通过该指针调用方法时调用的仍然是基类的方法,而不是子类重写的,因为编译器通过调用函数的句柄(指针或引用)来确定调用哪个版本的函数。  \nvirtual函数/virtual析构函数/final函数使用virtual函数后,通过真实的对象类型来决定调用版本,不再通过句柄类型决定。只需在函数原型前加virtual关键词即可,一旦一个函数声明为virtual,那么从该类起往下的所有派生类中,该函数都是virtual的,但为了可读性,最好还是在所有派生类中主动声明virtual,如果在函数原型最后面使用override关键词,会使编译器主动检查该函数是否是重写了基类函数,virtual带来的多态只能通过指针或引用来使用。  \n如果通过指向某一派生类对象的基类指针应用delete运算符,且该派生类的析构函数是非虚函数,那么编译器会报错。解决办法就是在基类中声明析构函数是虚函数,这样所有派生的析构函数都是虚函数。为了防止基类指针delete派生类对象出错,应将任何含有虚函数的类的析构函数设置为virtual。  \nfinal函数与Java一样,不能被子类重写,同时final类也不能被子类继承。  \n抽象类通过声明类的至少一个虚函数为纯虚函数(Java的抽象方法),可以使一个类成为抽象类。1virtual void print()const = 0;\n=0称为纯指示符,表明该函数必须被子类实现。  \n多态的实现多态通过三级指针实现,当编译器编译含有至少一个virtual函数的类时,它会为这个类创建一个虚函数表(vtable),其中包含指向虚函数的指针,那么每一个类如果重写/实现了virtual函数,那么该类的vtable中对应的指针就会指向他自己的实现,否则就会指向其他父类的实现,那么每次调用虚函数时,都会通过vtable选择正确的虚函数实现。第一级指针指的就是vtable中的函数指针,指向真正要调用的函数。第二级指针指向的是对象所属的类的vtable的指针。第三级指针就是对象的句柄(指针或引用)。  \ndynamic_cast1BaseClass* base_ptr = dynamic_cast&lt;BaseClass*&gt;(sub_ptr)\n与static_cast不判断类别直接进行转换不同的是,dynamic_cast会判断要转换的对象(sub_ptr指向的对象)是否是一个接受类型的对象(BaseClass类对象),如果是则直接赋值,如果不是,则赋nullptr。dynamic_cast有丶像Java中instance of判断后再转换的模式。  \n17.异常处理基础对于浮点数中的除数为0的情况,在一些C++的实现版本中是允许的,计算的结果是正负无穷大。C++中的异常类的基类是exception,runtime_error是其派生类,从runtime_error继承的类只有一个构造函数,该构造函数接收错误信息字符串并传递给其基类runtime_error,what函数用于返回该错误信息。catch处理器只能接收一个参数。  \n重新抛出异常某种情况下,发生异常时,可能需要释放一些资源,但当前函数并不处理该异常,所以他可以捕获异常后使用throw;再次抛出异常。123456789try&#123;  throw exception();//模拟异常被抛出&#125;catch (exception &amp;)&#123;  //资源处理  throw;//重新抛出&#125;\n构造函数/析构函数的异常处理构造函数抛出异常前,已经构造好的那些成员对象的析构函数将被调用,析构函数应该捕捉异常以防止程序终止。为防止使用new动态分配内存失败,可以使用set_new_handler方法并传入一个函数指针来进行处理,set_new_handler要求传入的函数不能有返回值,并且参数要为空。12345678910void consumer_handler()&#123;  cout &lt;&lt; \"new error\";  abort();&#125;int main&#123;  set_new_handler(consumer_handler);&#125;\nuique_ptr使用new分配内存时,如果在delete之前出现了异常,那么可能会造成内存泄漏。头文件memory提供了模板类uique_ptr,该类的对象维护了一个指向动态分配内存的指针,当uique_ptr对象的析构函数被调用时,他将先对其指针数据成员执行delete操作,它本身重载了./-&gt;操作符,所以将他当做普通指针使用。假设函数B返回给函数A一个指向某对象的指针,然后函数A并没有手动delete该指针,那么就可能造成内存泄漏,但如果返回一个uique_ptr指针,当该指针被销毁时,他会自动的delete释放动态内存中的对象。  \n23.其他const_cast该运算符可以强制去除const和volatile的限定,建议少用const_cast，更应该从逻辑上解决”需要修改const变量“的情况。  \nmutable如果一个数据总是要被修改,可以使用mutable关键字来声明该数据,这样甚至在const函数中也以修改该数据。  \n命名空间有点类似Java的包名,用于防止变量名重复,可定义匿名命名空间,或嵌套命名空间。对于匿名命名空间,其变量只在当前文件中有效。  \n多重继承/virtual继承多重继承时可能引发二义性转换错误。1234567891011121314class Base&#123;&#125;;class One : public Base&#123;&#125;;class Two : public Base&#123;&#125;;class Multiple : public One , public Two&#123;&#125;;Multiple both;Base* ptr = &amp; both;//error;\n在上述为指针变量赋值时会产生编译错误,因为both对象实际上包含了One/Two两个类的对象,即both包含了Base的两个子对象,ptr不知道该指向谁,引发二义性错误为解决这种问题,可以使用virtual继承。1234567891011class Base&#123;&#125;;class One : virtual public Base&#123;&#125;;class Two : virtual public Base&#123;&#125;;class Multiple : public One , public Two&#123;&#125;;\n将One/Two声明为virtual继承,并不改变One/Two的类对象是Base的子对象的事实,但是在构建Multiple对象时,编译器保证只有一个Base类子对象继承到了其中(具体是哪一个?????书里并没有说)。","dateCreated":"2018-08-31T19:29:45+08:00","dateModified":"2018-09-10T10:23:04+08:00","datePublished":"2018-08-31T19:29:45+08:00","description":"C++大学教材","headline":"C++大学教材笔记","image":["https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/c%2B%2B/c%2B%2B.png","https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2018/08/31/C++大学教材笔记/"},"publisher":{"@type":"Organization","name":"一条咸鱼","sameAs":[],"image":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg","logo":{"@type":"ImageObject","url":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"}},"url":"http://yoursite.com/2018/08/31/C++大学教材笔记/","thumbnailUrl":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/c%2B%2B/c%2B%2B.png"}</script>
    <meta name="description" content="C++大学教材">
<meta property="og:type" content="blog">
<meta property="og:title" content="C++大学教材笔记">
<meta property="og:url" content="http://yoursite.com/2018/08/31/C++大学教材笔记/index.html">
<meta property="og:site_name" content="一条咸鱼">
<meta property="og:description" content="C++大学教材">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/C%2B%2Bextend.png">
<meta property="og:updated_time" content="2018-09-10T02:23:04.370Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++大学教材笔记">
<meta name="twitter:description" content="C++大学教材">
<meta name="twitter:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/C%2B%2Bextend.png">
<meta property="fb:app_id" content="[object Object]">
    
    
        
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"/>
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/c%2B%2B/c%2B%2B.png"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/c%2B%2B/c%2B%2B.png" />
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg" />
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-du2xmrqdqrl2ollgeiw050kpl6l4nbyz7bumjuurjgsxyopifvukebxc9lqe.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">一条咸鱼</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
                </a>
                <h4 class="sidebar-profile-name">一条咸鱼</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Java Developer</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="首页">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link open-algolia-search" href="/all-archives" title="归档">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/about" title="关于">
                    
                        <i class="sidebar-button-icon fa fa-user" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-center
                    post-header-cover--full" style="background-image:url('https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg');" data-behavior="4">
            
                <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            C++大学教材笔记
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-08-31T19:29:45+08:00">
	
		    8月 31, 2018
    	
    </time>
    
</div>

    
</div>

            
        </div>

            <div id="main" data-behavior="4"
                 class="hasCover
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <!-- excerpt -->
<h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-C-简介"><span class="toc-text">1.C++简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#预处理"><span class="toc-text">预处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编译"><span class="toc-text">编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链接"><span class="toc-text">链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#载入"><span class="toc-text">载入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-C-编程入门"><span class="toc-text">2.C++编程入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内存的概念"><span class="toc-text">内存的概念</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-类-对象和字符串的介绍"><span class="toc-text">3.类,对象和字符串的介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义类"><span class="toc-text">定义类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可复用性以及接口和实现分离"><span class="toc-text">可复用性以及接口和实现分离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#头文件"><span class="toc-text">头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分离"><span class="toc-text">分离</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-控制-赋值-自增自减"><span class="toc-text">4.控制/赋值/自增自减</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#else摇摆"><span class="toc-text">else摇摆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本类型间显式和隐式转换"><span class="toc-text">基本类型间显式和隐式转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#列表初始化"><span class="toc-text">列表初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自增自减"><span class="toc-text">自增自减</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-控制语句和逻辑运算符"><span class="toc-text">5.控制语句和逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#浮点型"><span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#"><span class="toc-text">=/==</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#左值-右值"><span class="toc-text">左值/右值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-函数和递归"><span class="toc-text">6.函数和递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的实参"><span class="toc-text">函数的实参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储类别-链接性-作用域"><span class="toc-text">存储类别/链接性/作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#存储期-链接性"><span class="toc-text">存储期/链接性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自动存储期"><span class="toc-text">自动存储期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态存储期"><span class="toc-text">静态存储期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域"><span class="toc-text">作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#语句块作用域"><span class="toc-text">语句块作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#全局命名空间作用域"><span class="toc-text">全局命名空间作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链接性"><span class="toc-text">链接性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内联函数"><span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用和引用形参"><span class="toc-text">引用和引用形参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#默认实参"><span class="toc-text">默认实参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一元作用域分辨运算符"><span class="toc-text">一元作用域分辨运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数重载"><span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数模板"><span class="toc-text">函数模板</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-类模板array和vector-异常和捕获"><span class="toc-text">7.类模板array和vector,异常和捕获</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#array对象"><span class="toc-text">array对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector对象"><span class="toc-text">vector对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-指针"><span class="toc-text">8.指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内置数组"><span class="toc-text">内置数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const修饰指针"><span class="toc-text">const修饰指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sizeof"><span class="toc-text">sizeof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针算数运算"><span class="toc-text">指针算数运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针赋值"><span class="toc-text">指针赋值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-类-抛出异常"><span class="toc-text">9.类/抛出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#类的定义"><span class="toc-text">类的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#析构函数"><span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const对象和const成员函数"><span class="toc-text">const对象和const成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#友元"><span class="toc-text">友元</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this指针"><span class="toc-text">this指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static类成员"><span class="toc-text">static类成员</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-运算符重载-string类"><span class="toc-text">10.运算符重载:string类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#运算符重载"><span class="toc-text">运算符重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态内存管理"><span class="toc-text">动态内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拷贝构造函数-赋值函数"><span class="toc-text">拷贝构造函数/赋值函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型转换-explicit构造函数"><span class="toc-text">类型转换/explicit构造函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-继承"><span class="toc-text">11.继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基类和派生类"><span class="toc-text">基类和派生类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-多态"><span class="toc-text">12.多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#派生类对象调用基类函数"><span class="toc-text">派生类对象调用基类函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#virtual函数-virtual析构函数-final函数"><span class="toc-text">virtual函数/virtual析构函数/final函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象类"><span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多态的实现"><span class="toc-text">多态的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dynamic-cast"><span class="toc-text">dynamic_cast</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-异常处理"><span class="toc-text">17.异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础"><span class="toc-text">基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重新抛出异常"><span class="toc-text">重新抛出异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数-析构函数的异常处理"><span class="toc-text">构造函数/析构函数的异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uique-ptr"><span class="toc-text">uique_ptr</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-其他"><span class="toc-text">23.其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#const-cast"><span class="toc-text">const_cast</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mutable"><span class="toc-text">mutable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#命名空间"><span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多重继承-virtual继承"><span class="toc-text">多重继承/virtual继承</span></a></li></ol></li></ol>
<h1 id="1-C-简介"><a href="#1-C-简介" class="headerlink" title="1.C++简介"></a>1.C++简介</h1><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><p>执行诸如“包含其他要编译的文件”/“实现文本的替换”的预处理指令,以“#”开始的语句都由预处理器处理。  </p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>程序到机器语言的过程。  </p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>程序都会引用在其他库(标准库/私有库)中定义的函数/数据,链接器将这些函数/数据代码与之前编译的代码链接起来以形成最终的可执行程序。  </p>
<h2 id="载入"><a href="#载入" class="headerlink" title="载入"></a>载入</h2><p>载入器将可执行程序传入到内存中。  </p>
<h1 id="2-C-编程入门"><a href="#2-C-编程入门" class="headerlink" title="2.C++编程入门"></a>2.C++编程入门</h1><h2 id="内存的概念"><a href="#内存的概念" class="headerlink" title="内存的概念"></a>内存的概念</h2><p>变量名对应着内存中的特定区域,可以理解为一种映射关系?这种“映射关系”由编译器维护。  </p>
<h1 id="3-类-对象和字符串的介绍"><a href="#3-类-对象和字符串的介绍" class="headerlink" title="3.类,对象和字符串的介绍"></a>3.类,对象和字符串的介绍</h1><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><p>以关键字“class”+类名定义类(类名与Java一样),定义方面与Java不同的是C++的类访问控制符写在定义中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  MyClass(<span class="built_in">std</span>::<span class="built_in">string</span> user_name)<span class="comment">//constructor method</span></span><br><span class="line">    :name(user_name)</span><br><span class="line">  &#123;<span class="comment">//empyt body</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_name</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> user_name)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    name = user_name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">get_name</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">say_hello</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello "</span>&lt;&lt; name;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上述的类声明中,将所有的函数声明为public,成员变量声明为private,访问控制符含义与Java一致。<br>但是与Java不同的是,编译器并不在程序运行期间检查访问控制符,即如果通过private变量的指针对其进行访问,可以突破访问控制限制。<br>构造函数中在方法名后接“:”采用的是成员初始化列表,如果含有多个数据成员则用逗号分开,成员初始化列表在构造函数体执行前执行,该方法初始化效率更高(原书这么说,但是没有解释高在哪里,对此,只能说一句“高到不知道哪里去了”)。<br>函数中有两个函数后面声明了“const”,表明该方法不修改对象的值,这样的声明可以由编译器进行保证(不修改值的方法应该都声明为const—-最小特权)。  </p>
<h2 id="可复用性以及接口和实现分离"><a href="#可复用性以及接口和实现分离" class="headerlink" title="可复用性以及接口和实现分离"></a>可复用性以及接口和实现分离</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>在C++开发中,通常将可复用代码(如类定义)抽离为一个单独文件,称之为头文件(.h),头文件中不能包含“using”指令/声明,其他文件使用#include预处理指令来包含头文件,通过包含头文件,编译器就能确定一个类的对象的大小,自定义的头文件在include包含时应使用双引号,这样预处理器会在写有include指令的文件所在的文件夹下寻找该头文件,没找到或使用&lt;&gt;包含,预处理器会去标准库中寻找。   </p>
<h3 id="分离"><a href="#分离" class="headerlink" title="分离"></a>分离</h3><p>为了只暴露接口而隐藏函数实现细节,会将类拆分为.h+.cpp两个文件,.h文件中声明,.cpp文件中定义(实现)。<br>MyClass.h </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    MyClass(<span class="built_in">std</span>::<span class="built_in">string</span> user_name);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_name</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> user_name)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">get_name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say_hello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>:<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>MyClass.cpp<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">MyClass::MyClass(<span class="built_in">string</span> user_name)</span><br><span class="line">  :name(user_name)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MyClass::set_name(<span class="built_in">string</span> user_name)</span><br><span class="line">&#123;</span><br><span class="line">  name = user_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> MyClass::get_name() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MyClass::say_hello() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello "</span>&lt;&lt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MyClass.cpp包含MyClass.h,编译器在编译MyClass.cpp时就可以使用头文件中的信息确保每一个函数都与类定义中的函数原型匹配,同时成员函数的定义(cpp文件)也可以访问访问成员变量(h文件)。<br>test.cpp<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyClass.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">MyClass <span class="title">one</span><span class="params">(<span class="string">"tom"</span>)</span></span>;</span><br><span class="line">  <span class="function">MyClass <span class="title">two</span><span class="params">(<span class="string">"jack"</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;one.get_name()&lt;&lt;<span class="built_in">endl</span>&lt;&lt;one.say_hello()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;two.get_name()&lt;&lt;<span class="built_in">endl</span>&lt;&lt;two.say_hello()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用类的文件中只需要包含类的头文件,在链接过程中,需要将MyClass.cpp和test.cpp进行链接。  </p>
<h1 id="4-控制-赋值-自增自减"><a href="#4-控制-赋值-自增自减" class="headerlink" title="4.控制/赋值/自增自减"></a>4.控制/赋值/自增自减</h1><h2 id="else摇摆"><a href="#else摇摆" class="headerlink" title="else摇摆"></a>else摇摆</h2><p>C++编译器将else同它之前最近的if联系起来(如果没有花括号)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">5</span>)</span><br><span class="line">  <span class="keyword">if</span>(y&gt;<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x and y are &gt;5"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"x is &lt;=5"</span>;</span><br></pre></td></tr></table></figure></p>
<p>对于这类的语句,编译器将else和第二个if(y&gt;5)对应,导致输出可能与预想的不一样(这个问题Java也有,而且idea在输完第一个System.out.println(“x and y ard &gt;5”);回车后自动与第一个if对齐……)。  </p>
<h2 id="基本类型间显式和隐式转换"><a href="#基本类型间显式和隐式转换" class="headerlink" title="基本类型间显式和隐式转换"></a>基本类型间显式和隐式转换</h2><p>C++提供static_const运算符以进行强制类型转换,该转换只是提供一个转换后的副本,原数据类型并不改变。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> b = static_const&lt;<span class="keyword">double</span>&gt;(a);</span><br></pre></td></tr></table></figure></p>
<p>b被赋值为a的double版本,但a仍然是int类型。  </p>
<h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>使用列表初始化可以初始化任意类型的变量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee employee&#123;<span class="string">"Jack"</span>,<span class="string">"2000"</span>,<span class="string">"run"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>列表初始化器可以阻止“缩小转换”<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">12.7</span>;</span><br><span class="line"><span class="keyword">int</span> b &#123;<span class="number">12.7</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一种写法可能仅仅是警告,第二种无法通过编译。  </p>
<h2 id="自增自减"><a href="#自增自减" class="headerlink" title="自增自减"></a>自增自减</h2><p>自增自减运算符的操作数不可以是表达式,只能是已经定义的变量(这一点其实与Java一样,但我从没注意过……)。  </p>
<h1 id="5-控制语句和逻辑运算符"><a href="#5-控制语句和逻辑运算符" class="headerlink" title="5.控制语句和逻辑运算符"></a>5.控制语句和逻辑运算符</h1><h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p>由于浮点值是近似的,所以不应将浮点值用于控制判断。  </p>
<h2 id><a href="#" class="headerlink" title="=/=="></a>=/==</h2><p>与Java不同,在需要bool类型的判断时,C++将所有的非0值解释为true。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">if</span>(a = <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>if中的赋值表达式的值为3,被解释为true,这种情况编译时并不会报错……  </p>
<h2 id="左值-右值"><a href="#左值-右值" class="headerlink" title="左值/右值"></a>左值/右值</h2><p>凡是可以在赋值运算符左边使用的值都称为左值,常量称之为右值,左值可以用做右值,但反之不行。<br>另外C++允许“x==1“这样的语句通过编译,Java则认为这不是一个statement……  </p>
<h1 id="6-函数和递归"><a href="#6-函数和递归" class="headerlink" title="6.函数和递归"></a>6.函数和递归</h1><h2 id="函数的实参"><a href="#函数的实参" class="headerlink" title="函数的实参"></a>函数的实参</h2><p>在调用函数时,有时候函数的实参是一样复杂的表达式或是调用其他函数的返回值,这时编译器并不保证按照顺序对实参求值,所以可能出现与预想不一致的情况。  </p>
<h2 id="存储类别-链接性-作用域"><a href="#存储类别-链接性-作用域" class="headerlink" title="存储类别/链接性/作用域"></a>存储类别/链接性/作用域</h2><h3 id="存储期-链接性"><a href="#存储期-链接性" class="headerlink" title="存储期/链接性"></a>存储期/链接性</h3><p>存储期决定标识符在内存中存在的时间。<br>链接性决定标识符是只在声明他的源文件中可以识别还是在经编译后链接在一起的多个文件中可以识别。    </p>
<h4 id="自动存储期"><a href="#自动存储期" class="headerlink" title="自动存储期"></a>自动存储期</h4><p>在函数中声明的局部变量或者函数的形参都属于自动存储期,在执行到定义语句块时创建,退出语句块时自动销毁,只存在最接近他的花括号内。register关键词用于建议编译器将局部变量或函数形参放到寄存器内,但是编译器可以忽略register声明,不建议使用。<br>自动存储期的变量没有链接性。  </p>
<h4 id="静态存储期"><a href="#静态存储期" class="headerlink" title="静态存储期"></a>静态存储期</h4><p>关键词extern和static为函数和具有静态存储期的变量声明标识符。静态存储期变量从程序开始执行直到程序执行结束,一直存在于内存中,用static声明的函数内局部变量,哪怕函数被调用多次也只会声明一次,同时函数返回后其值不变。<br>static变量链接性为内部。<br>extern变量链接性为外部</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域指出标识符可以被引用的范围。  </p>
<h4 id="语句块作用域"><a href="#语句块作用域" class="headerlink" title="语句块作用域"></a>语句块作用域</h4><p>在一个语句块中声明的标识符的作用域开始于标识符声明处,结束于语句块的右花括号,当出现嵌套语句块,且内层变量名与外层变量名相同时,程序执行到内存时,内层变量隐藏外层变量。出了内层循环时,外层变量可见。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<h4 id="全局命名空间作用域"><a href="#全局命名空间作用域" class="headerlink" title="全局命名空间作用域"></a>全局命名空间作用域</h4><p>声明于任何函数或类之外的标识符具有全局命名空间作用域,其作用域从声明处开始直到文件结尾(注意是文件！！！)。</p>
<h3 id="链接性"><a href="#链接性" class="headerlink" title="链接性"></a>链接性</h3><p>链接性决定标识符是只在声明他的源文件中可以识别还是在经编译后链接在一起的多个文件中可以识别。  </p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>通过在函数的返回类型前使用”inline“关键字,可以建议编译器在适当的时候在调用该函数的地方直接生成该函数的函数体代码,内联函数一般放在头文件以便于复用,即使没用声明为inline编译器的优化可能也会自动采用内联。  </p>
<h2 id="引用和引用形参"><a href="#引用和引用形参" class="headerlink" title="引用和引用形参"></a>引用和引用形参</h2><p>按值传递的函数形参传递方式会在函数调用堆栈上生成实参值的副本,按引用传递时,函数可以直接修改原数据。声明形参按引用传递只需在类型名后加&amp;,在调用函数时直接传递变量名即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">test(b);</span><br></pre></td></tr></table></figure></p>
<p>如果在被调用函数中声明了一个引用,并且在函数最后需要return这个引用,那么需要将该引用声明为static,否则该引用变量会随函数出栈而被销毁。  </p>
<h2 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h2><p>函数调用时,可以为函数形参设置默认值,如果调用该函数时没有传入相应值,那么采用默认值,默认实参必须是参数列表中最靠右边的,在调用函数时,实参按从左到右的顺序给形参赋值。默认值在函数原型中声明即可。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b=<span class="number">1</span>,<span class="keyword">int</span> c=<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>)<span class="comment">//a = 1;b = 2; c = 2;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="一元作用域分辨运算符"><a href="#一元作用域分辨运算符" class="headerlink" title="一元作用域分辨运算符"></a>一元作用域分辨运算符</h2><p>局部变量和全局变量可以同名,C++提供::运算符来显式的访问全局变量,但::不能用来访问外层语句块中同名的局部变量。  </p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数重载基本与Java相同,但是要主要的是,如果含有默认实参的函数和重载函数在调用时可能能匹配多个函数从而产生二义性,那么无法通过编译。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b = <span class="number">2</span>,<span class="keyword">int</span> c =<span class="number">2</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	test4(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">cin</span>.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>函数模板就是泛型编程,当调用函数模板提供实参类型时,C++自动生成独立的函数模板特化。<br>函数模板必须要以template开头。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">T</span> <span class="title">test5</span>(<span class="title">T</span> <span class="title">a</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	test5(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">cin</span>.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">test5</span>(<span class="title">T</span> <span class="title">a</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">	<span class="keyword">return</span> ++a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="7-类模板array和vector-异常和捕获"><a href="#7-类模板array和vector-异常和捕获" class="headerlink" title="7.类模板array和vector,异常和捕获"></a>7.类模板array和vector,异常和捕获</h1><h2 id="array对象"><a href="#array对象" class="headerlink" title="array对象"></a>array对象</h2><p>array对象是一组具有相同类型且连续的内存区域。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span> &lt;<span class="keyword">int</span>,5&gt; my_array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在使用[]运算符以下标访问array对象的元素时C++没有提供自动的边界范围检测,范围越界时也不会产生警告,所以可能访问到无效的值,array对象提供了at函数用来访问元素,该函数带有下标范围检测的功能。  </p>
<h2 id="vector对象"><a href="#vector对象" class="headerlink" title="vector对象"></a>vector对象</h2><p>vector支持动态的大小调整,对于vector对象,可以使用!=/==来进行vector内元素的比较。  </p>
<h1 id="8-指针"><a href="#8-指针" class="headerlink" title="8.指针"></a>8.指针</h1><p>指针变量将内存地址作为值,传递指针是C++中的第二种引用传递,本质上说所有的参数都是按值传递的,在传递指针时,也是将实参的指针值复制到形参中。  </p>
<h2 id="内置数组"><a href="#内置数组" class="headerlink" title="内置数组"></a>内置数组</h2><p>内置数组的名字会隐式转化为内置数组中第一个元素的地址,内置数组并不知道自己的大小,内置数组无法使用关系和相等运算符进行比较也不能相互赋值。  </p>
<h2 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * ptr;</span><br></pre></td></tr></table></figure>
<p>指向const数据的非const指针,该类指针表示不能当过该指针修改其指向的数据(const数据),但该指针可以修改以用于指向其他数据(非const指针)。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr;</span><br></pre></td></tr></table></figure>
<p>指向非const数据的const指针,可以通过该指针修改其指向的数据(非const数据),但是该指针不能修改以指向其他数据(const指针)。  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> ptr;</span><br></pre></td></tr></table></figure>
<p>指向const数据的const指针,最严格。   </p>
<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>不同系统,各类型数据所占字节数可能不同,可以使用sizeof来确定,sizeof是编译时运算符,他的操作数不会被求值。  </p>
<h2 id="指针算数运算"><a href="#指针算数运算" class="headerlink" title="指针算数运算"></a>指针算数运算</h2><p>一个指针可以加减,以使其指向其他内存区域,当指针加/减一个整数时,其实是加/减这个整数与指针指向对象的字节大小的乘积。  </p>
<h2 id="指针赋值"><a href="#指针赋值" class="headerlink" title="指针赋值"></a>指针赋值</h2><p>如果两个指针是同一类型的,那么可以赋值,否则要使用强制类型转换。<br>void*是一种通用指针,任何类型的指针都可以直接赋值给void*类型的指针,反之则不行。  </p>
<h1 id="9-类-抛出异常"><a href="#9-类-抛出异常" class="headerlink" title="9.类/抛出异常"></a>9.类/抛出异常</h1><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><p>为了防止在构建程序时不小心重复包含头文件(可能有各种间接包含)带来的编译错误,一般使用#ifndef/#define/#endif<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TIME_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIME_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Time();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hour;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果没有定义”TIME_H“那么define和endif之间的代码就会被包含,这样通过定义TIME_H就可以防止重复包含,习惯上定义使用大写的头文件名,并用下划线代替圆点。  </p>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>析构函数名为类名前加”~“,当对像被销毁时,其析构函数隐式的被调用,主要用来释放内存,调用析构函数的顺序与构造函数完全相反。  </p>
<h2 id="const对象和const成员函数"><a href="#const对象和const成员函数" class="headerlink" title="const对象和const成员函数"></a>const对象和const成员函数</h2><p>变量和对象声明为const可能可以提升程序性能,因为编译器会为这些常量提供更多的优化。<br>对于const对象,其只能调用const成员函数,哪怕某些非const成员函数并没有修改数据。<br>如果某些对象作为类的成员存在,这些成员对象以在类的定义中声明的顺序(不是以构造函数中的成员初始化器的顺序)创建。在创建对象时,成员对象如果没有显示初始化,那么会自动调用成员对象的默认构造函数。如果成员对象的类没有构造函数且没有对该成员对象使用初始化器,那么无法通过编译。  </p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>类的友元在类的作用域之外定义,但是可以访问类的private数据。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Count</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">set_x</span><span class="params">(Count &amp;,<span class="keyword">int</span>)</span></span>;<span class="comment">//friend method</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassOne</span>;</span><span class="comment">//friend class</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Count()</span><br><span class="line">      :x(<span class="number">0</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> </span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_x</span><span class="params">(Count &amp; c,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  c.x = val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>set_x就是类Count的友元函数,其可以访问private数据x,ClassTwo是类Count的友元类,其中的所有函数都是Count的友元函数。  </p>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>与Java的this引用一样,指向当前对象,但this指针并不是对象的一部分,sizeof运算结果不包含this指针大小,this指针作为一个隐式参数被编译器传递个每个对象的每个非static函数,this指针类型取决于对象类型和函数类型。  </p>
<h2 id="static类成员"><a href="#static类成员" class="headerlink" title="static类成员"></a>static类成员</h2><p>static类成员的默认构造函数会被默认调用,可以不用手动初始化,使用类名::成员名引用static成员。<br>static函数与Java一样。  </p>
<h1 id="10-运算符重载-string类"><a href="#10-运算符重载-string类" class="headerlink" title="10.运算符重载:string类"></a>10.运算符重载:string类</h1><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>使用operator关键字指定要重载的运算符,重载运算符后,运算符的优先级不会改变,重载(),[],-&gt;即其他赋值运算符时,重载函数必须被声明为类成员函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> String &amp;) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">String y;</span><br><span class="line">String x;</span><br><span class="line">y&lt;x<span class="comment">// -&gt;  y.operator&lt;(x);</span></span><br></pre></td></tr></table></figure></p>
<p>对于上面的重载操作符,要求做操作数必须要改类的一个对象。同时还有另外一种重载形式。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> String &amp; a,<span class="keyword">const</span> String &amp; b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line">String x;</span><br><span class="line">String y;</span><br><span class="line">x&lt;y   <span class="comment">//  -&gt;  operator&lt;(x,y);</span></span><br></pre></td></tr></table></figure></p>
<p>当重载++/–操作符时,建议采用前置操作符,因为后值操作符时需要创建临时对象,影响性能。  </p>
<h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2><p>使用new运算符分配的内存在堆中,其无法随函数出入栈而自动收回,必须使用delete手动的释放内存。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Count* c = <span class="keyword">new</span> Count[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">delete</span> [] c;</span><br></pre></td></tr></table></figure></p>
<p>delete时,先会调用Count数组中每一个对象的析构函数,然后回收数组的内存空间,将该空间返回给自由存储区,此时该内存才可以继续被使用。在delete时,如果不加[],那么有可能只调用第一个对象的析构函数(各编译器实现不同)。  </p>
<h2 id="拷贝构造函数-赋值函数"><a href="#拷贝构造函数-赋值函数" class="headerlink" title="拷贝构造函数/赋值函数"></a>拷贝构造函数/赋值函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array integers1;</span><br><span class="line"><span class="function">Array <span class="title">integers2</span><span class="params">(integers1)</span> <span class="comment">//1.</span></span></span><br><span class="line"><span class="function">Array integers3 </span>= integers <span class="comment">// 2.</span></span><br><span class="line">Array integers4;</span><br><span class="line">integers4 = integers1; <span class="comment">//3.</span></span><br></pre></td></tr></table></figure>
<p>上述代码中1,2都是调用的Array类的拷贝构造函数,3调用的是赋值函数(运算符重载),=如果出现在变量声明的地方,那么就是拷贝构造函数。<br>在这两个函数中需要注意的是,如果只是把源对象的指针复制到目标对象的指针,那么在某一个对象调用析构函数释放这一块内存时,另一个对象可能就会出错。  </p>
<h2 id="类型转换-explicit构造函数"><a href="#类型转换-explicit构造函数" class="headerlink" title="类型转换/explicit构造函数"></a>类型转换/explicit构造函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Count::operatr <span class="keyword">char</span> *()</span><br><span class="line">Count s;</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> *&gt;(s);  <span class="comment">//  -&gt; s.operator char *();</span></span><br></pre></td></tr></table></figure>
<p>通过重载转换运算符,可以指定自己的类型转换方式。  </p>
<p>任何单参数的构造函数都可以被编译器用来执行隐式转换。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">private</span>;</span><br><span class="line">    <span class="keyword">int</span> * ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array:Array(<span class="keyword">int</span> size)</span><br><span class="line">  :ptr(<span class="keyword">new</span> <span class="keyword">int</span>[size])</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main</span><br><span class="line">&#123;</span><br><span class="line">  outputArray(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outputArray</span><span class="params">(<span class="keyword">const</span> Array&amp; <span class="built_in">array</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的main函数中,调用outputArray并传入3,但是outputArray接受的是Array对象的引用,于是编译器尝试将3转化为Array对象,发现Array类有一个单参数的构造函数,于是隐式调用该构造函数将3转化为一个临时的Array对象并传给outputArray函数,但这种情况可能并不是我们想要的,可以通过在单参数构造函数前加关键字explicit,来禁止该构造函数被隐式调用。  </p>
<h1 id="11-继承"><a href="#11-继承" class="headerlink" title="11.继承"></a>11.继承</h1><p>C++提供三种继承,public/protected/private。<br><img src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/C%2B%2Bextend.png" alt>  </p>
<h2 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Dog::Dog(<span class="keyword">int</span> a,<span class="keyword">int</span> b.<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span><br><span class="line">  :Animal(a,b,c),x(d);</span><br></pre></td></tr></table></figure>
<p>Dog public继承自Animal,基类的private成员已被派生类继承,但是派生类不能直接访问(可通过函数),友元是不能被继承的,继承时派生类继承了基类除了构造函数和析构函数外的所有函数,但是派生类在构造函数时需要主动的调用基类的构造函数以初始化那些继承到派生类中的基类成员,否则的话编译器会隐式调用基类的默认构造函数,如果没有的话,报错。派生类需要#include基类的头文件,以使编译器确定基类对象的大小  </p>
<h1 id="12-多态"><a href="#12-多态" class="headerlink" title="12.多态"></a>12.多态</h1><h2 id="派生类对象调用基类函数"><a href="#派生类对象调用基类函数" class="headerlink" title="派生类对象调用基类函数"></a>派生类对象调用基类函数</h2><p>将派生类对象赋给基类指针,通过该指针调用方法时调用的仍然是基类的方法,而不是子类重写的,因为编译器通过调用函数的句柄(指针或引用)来确定调用哪个版本的函数。  </p>
<h2 id="virtual函数-virtual析构函数-final函数"><a href="#virtual函数-virtual析构函数-final函数" class="headerlink" title="virtual函数/virtual析构函数/final函数"></a>virtual函数/virtual析构函数/final函数</h2><p>使用virtual函数后,通过真实的对象类型来决定调用版本,不再通过句柄类型决定。<br>只需在函数原型前加virtual关键词即可,一旦一个函数声明为virtual,那么从该类起往下的所有派生类中,该函数都是virtual的,但为了可读性,最好还是在所有派生类中主动声明virtual,如果在函数原型最后面使用override关键词,会使编译器主动检查该函数是否是重写了基类函数,virtual带来的多态只能通过指针或引用来使用。  </p>
<p>如果通过指向某一派生类对象的基类指针应用delete运算符,且该派生类的析构函数是非虚函数,那么编译器会报错。解决办法就是在基类中声明析构函数是虚函数,这样所有派生的析构函数都是虚函数。<br>为了防止基类指针delete派生类对象出错,应将任何含有虚函数的类的析构函数设置为virtual。  </p>
<p>final函数与Java一样,不能被子类重写,同时final类也不能被子类继承。  </p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>通过声明类的至少一个虚函数为纯虚函数(Java的抽象方法),可以使一个类成为抽象类。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span><span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>=0称为纯指示符,表明该函数必须被子类实现。  </p>
<h2 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h2><p>多态通过三级指针实现,当编译器编译含有至少一个virtual函数的类时,它会为这个类创建一个虚函数表(vtable),其中包含指向虚函数的指针,那么每一个类如果重写/实现了virtual函数,那么该类的vtable中对应的指针就会指向他自己的实现,否则就会指向其他父类的实现,那么每次调用虚函数时,都会通过vtable选择正确的虚函数实现。<br>第一级指针指的就是vtable中的函数指针,指向真正要调用的函数。<br>第二级指针指向的是对象所属的类的vtable的指针。<br>第三级指针就是对象的句柄(指针或引用)。  </p>
<h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BaseClass* base_ptr = <span class="keyword">dynamic_cast</span>&lt;BaseClass*&gt;(sub_ptr)</span><br></pre></td></tr></table></figure>
<p>与static_cast不判断类别直接进行转换不同的是,dynamic_cast会判断要转换的对象(sub_ptr指向的对象)是否是一个接受类型的对象(BaseClass类对象),如果是则直接赋值,如果不是,则赋nullptr。<br>dynamic_cast有丶像Java中instance of判断后再转换的模式。  </p>
<h1 id="17-异常处理"><a href="#17-异常处理" class="headerlink" title="17.异常处理"></a>17.异常处理</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>对于浮点数中的除数为0的情况,在一些C++的实现版本中是允许的,计算的结果是正负无穷大。<br>C++中的异常类的基类是exception,runtime_error是其派生类,从runtime_error继承的类只有一个构造函数,该构造函数接收错误信息字符串并传递给其基类runtime_error,what函数用于返回该错误信息。<br>catch处理器只能接收一个参数。  </p>
<h2 id="重新抛出异常"><a href="#重新抛出异常" class="headerlink" title="重新抛出异常"></a>重新抛出异常</h2><p>某种情况下,发生异常时,可能需要释放一些资源,但当前函数并不处理该异常,所以他可以捕获异常后使用throw;再次抛出异常。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">throw</span> exception();<span class="comment">//模拟异常被抛出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (exception &amp;)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//资源处理</span></span><br><span class="line">  <span class="keyword">throw</span>;<span class="comment">//重新抛出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="构造函数-析构函数的异常处理"><a href="#构造函数-析构函数的异常处理" class="headerlink" title="构造函数/析构函数的异常处理"></a>构造函数/析构函数的异常处理</h2><p>构造函数抛出异常前,已经构造好的那些成员对象的析构函数将被调用,析构函数应该捕捉异常以防止程序终止。<br>为防止使用new动态分配内存失败,可以使用set_new_handler方法并传入一个函数指针来进行处理,set_new_handler要求传入的函数不能有返回值,并且参数要为空。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"new error"</span>;</span><br><span class="line">  <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main</span><br><span class="line">&#123;</span><br><span class="line">  set_new_handler(consumer_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="uique-ptr"><a href="#uique-ptr" class="headerlink" title="uique_ptr"></a>uique_ptr</h2><p>使用new分配内存时,如果在delete之前出现了异常,那么可能会造成内存泄漏。<br>头文件memory提供了模板类uique_ptr,该类的对象维护了一个指向动态分配内存的指针,当uique_ptr对象的析构函数被调用时,他将先对其指针数据成员执行delete操作,它本身重载了./-&gt;操作符,所以将他当做普通指针使用。<br>假设函数B返回给函数A一个指向某对象的指针,然后函数A并没有手动delete该指针,那么就可能造成内存泄漏,但如果返回一个uique_ptr指针,当该指针被销毁时,他会自动的delete释放动态内存中的对象。  </p>
<h1 id="23-其他"><a href="#23-其他" class="headerlink" title="23.其他"></a>23.其他</h1><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><p>该运算符可以强制去除const和volatile的限定,建议少用const_cast，更应该从逻辑上解决”需要修改const变量“的情况。  </p>
<h2 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h2><p>如果一个数据总是要被修改,可以使用mutable关键字来声明该数据,这样甚至在const函数中也以修改该数据。  </p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>有点类似Java的包名,用于防止变量名重复,可定义匿名命名空间,或嵌套命名空间。<br>对于匿名命名空间,其变量只在当前文件中有效。  </p>
<h2 id="多重继承-virtual继承"><a href="#多重继承-virtual继承" class="headerlink" title="多重继承/virtual继承"></a>多重继承/virtual继承</h2><p>多重继承时可能引发二义性转换错误。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Multiple</span> :</span> <span class="keyword">public</span> One , <span class="keyword">public</span> Two</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">Multiple both;</span><br><span class="line">Base* ptr = &amp; both;<span class="comment">//error;</span></span><br></pre></td></tr></table></figure></p>
<p>在上述为指针变量赋值时会产生编译错误,因为both对象实际上包含了One/Two两个类的对象,即both包含了Base的两个子对象,ptr不知道该指向谁,引发二义性错误为解决这种问题,可以使用virtual继承。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">One</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Two</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Multiple</span> :</span> <span class="keyword">public</span> One , <span class="keyword">public</span> Two</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>将One/Two声明为virtual继承,并不改变One/Two的类对象是Base的子对象的事实,但是在构建Multiple对象时,编译器保证只有一个Base类子对象继承到了其中(具体是哪一个?????书里并没有说)。</p>
            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/09/10/Linux/" data-tooltip="Linux/存储基础" aria-label="上一篇: Linux/存储基础">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/26/C++ Primer Plus笔记1/" data-tooltip="C++Primer Plus读书笔记(一)" aria-label="下一篇: C++Primer Plus读书笔记(一)">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 一条咸鱼. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/09/10/Linux/" data-tooltip="Linux/存储基础" aria-label="上一篇: Linux/存储基础">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/26/C++ Primer Plus笔记1/" data-tooltip="C++Primer Plus读书笔记(一)" aria-label="下一篇: C++Primer Plus读书笔记(一)">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-times"></i>
    <ul class="share-options">
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
        
            <h4 id="about-card-name">一条咸鱼</h4>
        
            <div id="about-card-bio"><p>重庆</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>学生</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/sideCover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-vufjrm3fmbuttogo1hxuu0w9w0sesk5iyysjuguc2hdhufot9szxg8twijry.min.js"></script>
<!--SCRIPTS END-->

    



    </body>
</html>
