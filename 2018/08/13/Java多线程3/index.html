
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="一条咸鱼">
    <title>Java多线程(三) - 一条咸鱼</title>
    <meta name="author" content="一条咸鱼">
    
    
        <link rel="icon" href="http://yoursite.com/assets/images/favicon.ico">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"一条咸鱼","sameAs":[],"image":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"},"articleBody":"  \n\nThreadLocal介绍ThreadLocal提供了线程本地变量,它可以保证访问到的变量属于当前线程,每个线程都保存有一个变量副本,每个线程的变量都不同,而同一个线程在任何时候访问这个本地变量的结果都是一致的。当一个线程结束时,它所使用的所有 ThreadLocal 相对的实例副本都可被回收。ThreadLocal相当于提供了一种线程隔离,将变量与线程绑定的方法。ThreadLocal通常定义为private static类型。每个Thread实例中,都有ThreadLocalMap(ThreadLocal内部类)引用,第一次调用ThreadLocal#set(value),getMap()返回Thread#ThreadLocalMap对象(为null),createMap()实例化一个ThreadLocalMap并赋值给Thread#ThreadLocalMap。  \n12345678public void set(T value) &#123;      Thread t = Thread.currentThread();      ThreadLocalMap map = getMap(t);      if (map != null)          map.set(this, value);      else          createMap(t, value);  &#125;\nThreadLocalMap内部用一个Entry数组存储value,key就是ThreadLocal实例,通过ThreadLocal.threadLocalHashCode计算来确定value在Entry中的index,并通过线性探测法解决冲突。  \n1234567ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;      table = new Entry[INITIAL_CAPACITY];      int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);      table[i] = new Entry(firstKey, firstValue);      size = 1;      setThreshold(INITIAL_CAPACITY);  &#125;\n某一线程调用get()时,先获取到当前线程私有的ThreadLocalMap,再通过ThreadLocal作为key获得最终的value。  \n123456789101112public T get() &#123;    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null) &#123;        ThreadLocalMap.Entry e = map.getEntry(this);        if (e != null) &#123;            T result = (T)e.value;            return result;        &#125;    &#125;    return setInitialValue();&#125;\n以如下代码为例具体说明其作用:thread1和thread2分别拥有自己的threadLocalMap,当两个线程运行唯一的Runnable时,Runnable内部的ThreadLocal会获取到运行他的线程的Map并为该map设置值,获取时类似。可以看到在多个线程运行一个Runnable时,对于数据即没有冲突也没有加锁而是没有每个线程都有一个副本。  \n1234567891011121314151617181920212223public static class MyRunnable implements Runnable &#123;    private ThreadLocal threadLocal = new ThreadLocal();    @Override    public void run() &#123;        threadLocal.set((int) (Math.random() * 100D));        try &#123;        Thread.sleep(2000);        &#125; catch (InterruptedException e) &#123;        &#125;        System.out.println(threadLocal.get());    &#125;&#125;public static void main(String[] args) &#123;     MyRunnable sharedRunnableInstance = new MyRunnable();     Thread thread1 = new Thread(sharedRunnableInstance);     Thread thread2 = new Thread(sharedRunnableInstance);     thread1.start();     thread2.start();&#125;\n多个线程需要同一个变量的一个副本:一个ThreadLocal实例即可。多个线程需要多个变量的一个副本:需要多个ThreadLocal。  \nThreadLocal的内存泄漏ThreadLocalMap内部使用了一个Entry数组来存储Value,Entry本身继承弱引用同时存储value。如果ThreadLocal实例没有强引用指向他,他将被回收,那么此时ThreadLocalMap中以他作为key的那些value将无法再被访问到,但是这个value仍然有一条Thread-&gt;ThreadLocalMap-&gt;Entry-&gt;Value的强引用链。那么就会造成value的内存泄漏。  \n12345678static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;    Object value;    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;        super(k);        value = v;    &#125;&#125;\n这种内存泄漏的情况JDK本身已经考虑到,所以在get()/set()/remove()时一旦有机会就会尝试去清理key为null的value。      \nset()ThreadLocalMap.set()首先计算出当前key对应index上的Entry,如果key相等直接返回。  \n123456789101112131415161718192021for (Entry e = tab[i];         e != null;         e = tab[i = nextIndex(i, len)]) &#123;        ThreadLocal&lt;?&gt; k = e.get();        //key/k相等,对值进行更新即可        if (k == key) &#123;            e.value = value;            return;        &#125;        //k为空,需要替换并清理Entry数组        if (k == null) &#123;            replaceStaleEntry(key, value, i);            return;        &#125;    &#125;    //走到这里,说明既不冲突也暂时未发现key为null的Entry,那么插入一个新的Entry并尝试对数组进行清理    tab[i] = new Entry(key, value);    int sz = ++size;    //如果没能清理掉任何一个Entry且size大于扩容阈值,调用rehash扩容    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)        rehash();\n清理替换如果k为null则需要进行替换并清理replaceStaleEntry  \n123456789101112131415161718192021222324252627282930313233343536int slotToExpunge = staleSlot;    for (int i = prevIndex(staleSlot, len);         (e = tab[i]) != null;         i = prevIndex(i, len))        if (e.get() == null)            slotToExpunge = i;    //从过期槽位向后遍历    for (int i = nextIndex(staleSlot, len);         (e = tab[i]) != null;         i = nextIndex(i, len)) &#123;        ThreadLocal&lt;?&gt; k = e.get();        //找到与set()的key相等的Entry        if (k == key) &#123;            //更新value,交换过期Entry和当前Entry            e.value = value;            tab[i] = tab[staleSlot];            tab[staleSlot] = e;            //如果slotToExpunge和最初传入的过期槽位相等,即在先前的向前遍历过程中            //在过期槽位之前没有发现过期Entry,那么将i赋值给slotToExpunge(上一步中已经将过期Entry与i交换了)            if (slotToExpunge == staleSlot)                slotToExpunge = i;            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);            return;        &#125;        //如果k(ThreadLocal)为null且slotToExpunge和最初传入的过期槽位相等,即在先前的向前遍历过程中        //在过期槽位之前没有发现过期Entry,那么当前Entry就是要清理的Entry        if (k == null &amp;&amp; slotToExpunge == staleSlot)            slotToExpunge = i;    &#125;    //走到这里说明先前的向后遍历过程中没有发现k/key相等的Entry    //将过期槽位的value置null,帮助GC,然后插入新的Entry    tab[staleSlot].value = null;    tab[staleSlot] = new Entry(key, value);    //如果过期槽位和slotToExpunge不等,说明还有其他需要清理的Entry,清理之    if (slotToExpunge != staleSlot)        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n真正的清理工作由expungeStaleEntry来做  \n123456789101112131415161718192021222324252627282930313233private int expungeStaleEntry(int staleSlot) &#123;    Entry[] tab = table;    int len = tab.length;    //先清理掉当前过期Entry    tab[staleSlot].value = null;    tab[staleSlot] = null;    size--;    Entry e;    int i;    for (i = nextIndex(staleSlot, len);         (e = tab[i]) != null;         i = nextIndex(i, len)) &#123;        ThreadLocal&lt;?&gt; k = e.get();    //从传入的过期槽位向后遍历,如果发现了过期Entry,清理之        if (k == null) &#123;            e.value = null;            tab[i] = null;            size--;        &#125; else &#123;//如果不是过期Entry,重新计算其index            int h = k.threadLocalHashCode &amp; (len - 1);            if (h != i) &#123;                //第一次计算所得index若和其当前index不相等,则将当前index的Entry置null                //并继续计算-&gt;rehash过程                tab[i] = null;                while (tab[h] != null)                    h = nextIndex(h, len);                tab[h] = e;            &#125;        &#125;    &#125;    //至此,rehash和清理过程完成,返回最初传入的过期槽位的下一个Entry==null槽位    return i;&#125;\ncleanSomeSlots是一种随缘(启发式?)清理算法  \n12345678910111213141516171819private boolean cleanSomeSlots(int i, int n) &#123;      boolean removed = false;      Entry[] tab = table;      //n初始值就是len      int len = tab.length;      do &#123;          i = nextIndex(i, len);          Entry e = tab[i];          if (e != null &amp;&amp; e.get() == null) &#123;              //一旦发现过期Entry就将n重新置为len,并且调用清理方法进行清理              n = len;              removed = true;              i = expungeStaleEntry(i);          &#125;       //(n=n/2)!=0,注释说这种是对于\"不扫描\"和\"遍历\"的一种平衡       //这样的扫描方式有可能留有过期Entry      &#125; while ( (n &gt;&gt;&gt;= 1) != 0);      return removed;  &#125;\nrehash()/resize()接下来回到ThreadLocalMap.set()的最后一段,其有可能调用rehash()  \n1234567private void rehash() &#123;    //先清理    expungeStaleEntries();    //清理后如果size还＞扩容阈值的3/4,那么进行扩容,这里也可以看出Entry数组的真正可用量是数组长度的3/4    if (size &gt;= threshold - threshold / 4)        resize();&#125;\nresize代码很简单,就是引用复制  \n12345678910111213141516171819for (int j = 0; j &lt; oldLen; ++j) &#123;        //新数组长度是旧数组长度的两倍        Entry e = oldTab[j];        if (e != null) &#123;            ThreadLocal&lt;?&gt; k = e.get();            if (k == null) &#123;                e.value = null; // Help the GC            &#125; else &#123;                int h = k.threadLocalHashCode &amp; (newLen - 1);                while (newTab[h] != null)                    h = nextIndex(h, newLen);                newTab[h] = e;                count++;            &#125;        &#125;    &#125;    setThreshold(newLen);    size = count;    table = newTab;\nget()ThreadLocal.get()-&gt;ThreadLocalMap.getEntry(),一旦未命中就有机会清理过期Entry  \n12345678int i = key.threadLocalHashCode &amp; (table.length - 1);      Entry e = table[i];      //如果一次命中,直接返回      if (e != null &amp;&amp; e.get() == key)          return e;      else      //未命中(可能会清理过期Entry)          return getEntryAfterMiss(key, i, e);\ngetEntryAfterMiss代码也很简单  \n1234567891011while (e != null) &#123;      ThreadLocal&lt;?&gt; k = e.get();      if (k == key)          return e;      if (k == null)          expungeStaleEntry(i);      else          i = nextIndex(i, len);      e = tab[i];  &#125;  return null;\nThreadLocal关键代码解析完毕。回想最开始提到的ThreadLocal的内存泄漏问题可以发现,ThreadLocal的内存泄漏和弱引用并没有什么关系,关键在于ThreadLocalMap的生命周期基本是和Thread一样长的,只要没有手动remove,就有可能发生内存泄漏。  \nAQS/ReentrantLockAQS是并发工具的基础类,以下结合ReentrantLock公平模式解析源码    \n基本属性AQS使用Node(双向结点)封装那些等待锁的线程,其有独占和共享两种模式(锁的模式),内部的waitStatus表示该结点的等待状态12345678//表明该结点的线程已经取消等锁(超时或中断等原因)static final int CANCELLED =  1;//表明该结点的线程在释放锁时有责任去唤醒后继结点中的线程static final int SIGNAL    = -1;//表明该结点的线程处于条件等待状态static final int CONDITION = -2;//共享模式下,该结点线程释放共享锁时应该传播通知后面的所有结点static final int PROPAGATE = -3;\nAQS本身维护着Node队列,他有一个state属性用于表示获取锁的次数(可以重入)  \nacquire()/加锁ReentrantLock.lock()-&gt;AQS.acquire(1)  \n1234//先尝试获取锁,获取失败则要进入等待队列if (!tryAcquire(arg) &amp;&amp;    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))    selfInterrupt();\ntryAcquire()FariSync.tryAcquire尝试获取锁  \n12345678910111213141516171819202122final Thread current = Thread.currentThread();  //获取到AQS的state  int c = getState();  if (c == 0) &#123;      //如果没有线程获得锁,公平模式需要先查看是否还有其他线程在等待锁      if (!hasQueuedPredecessors() &amp;&amp;          compareAndSetState(0, acquires)) &#123;          //没有等待线程,且CAS上锁成功,设置当前线程为持有锁的线程          setExclusiveOwnerThread(current);          return true;      &#125;  &#125;  //如果有线程获得了锁,判断获得锁的线程是否是当前线程  else if (current == getExclusiveOwnerThread()) &#123;      int nextc = c + acquires;      if (nextc &lt; 0)          throw new Error(\"Maximum lock count exceeded\");      setState(nextc);      return true;  &#125;  //尝试获取失败  return false;\naddWaiter()如果尝试获取失败,调用addWaiter添加等待结点\n1234567891011121314151617Node node = new Node(Thread.currentThread(), mode);// Try the fast path of enq; backup to full enq on failureNode pred = tail;if (pred != null) &#123;    //设置tail结点为入队结点的前驱结点    node.prev = pred;    if (compareAndSetTail(pred, node)) &#123;        //如果CAS将入队结点成功设置为尾结点就可以返回        pred.next = node;        return node;    &#125;&#125;//走到这里,说明tail为null或者CAS操作失败(还有其他结点在竞争入队)//那么调用enq不断循环直到入队成功//注意到新入队的结点的waitStatuss=0enq(node);return node;\nenq()123456789101112131415for (;;) &#123;    Node t = tail;    //tail为null说明队列为空,初始化tail和head。当然,也有可能是多个线程在竞争初始化,所以仍然调用CAS    if (t == null) &#123;//可以看到head是一个空结点,并不包含线程        if (compareAndSetHead(new Node()))            tail = head;    &#125; else &#123;        node.prev = t;        //走到这里说明tail/head一定不为null,尝试设置当前结点为tail        if (compareAndSetTail(t, node)) &#123;            t.next = node;            return t;        &#125;    &#125;&#125;\nacquireQueued()入队完成后,回到acquireQueued(addWaiter(Node.EXCLUSIVE), arg)中  \n1234567891011121314151617181920212223try &#123;    boolean interrupted = false;    for (;;) &#123;        final Node p = node.predecessor();        //p是Node的前驱结点,如果p==head,那么当前结点再次尝试获取锁        // (因为他是持有锁的线程的下一个线程,所以他现在有可能获取的到锁)        if (p == head &amp;&amp; tryAcquire(arg)) &#123;            setHead(node);            p.next = null; // help GC            failed = false;            return interrupted;        &#125;        //走到这里说明当前线程有可能需要被挂起,先进行判断,如果应该被挂起,则进行挂起操作        //如果返回true,LockSupport直接将当前线程挂起即可        //否则进行下一次循环        if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;            parkAndCheckInterrupt())            interrupted = true;    &#125;&#125; finally &#123;    if (failed)        cancelAcquire(node);&#125;\n挂起shouldParkAfterFailedAcquire就是判断前驱结点状态,因为他要保证当前线程被挂起后,能在未来的某个时间被前驱结点唤醒,也即他的前驱结点状态要是SIGNAL  \n12345678910111213141516int ws = pred.waitStatus;if (ws == Node.SIGNAL)    //前驱结点状态为SIGNAL(说明前驱结点可以唤醒后继结点(当前结点))    return true;if (ws &gt; 0) &#123;    //&gt;0说明前驱结点已被取消(等待超时等原因)    do &#123;        //向前遍历找到一个没有取消的结点作为前驱        node.prev = pred = pred.prev;    &#125; while (pred.waitStatus &gt; 0);    pred.next = node;&#125; else &#123;    //如果是其他情况,将前驱结点设置为SIGNAL    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);&#125;return false;\n由于新入队的结点的waitStatus都是0,而他的waitStatus的更新依赖于后插入的结点的should判断,所以acquireQueued第一次循环很有可能并不挂起线程,而是在第一次should方法将前驱结点waitStatus设置为SIGNAL后,在第二次循环再挂起,原因是,如果第一次should判断没有返回true,第二次循环的时候,当前结点有可能已经是head的后继结点了,所以可以在for循环中,再尝试获取一次锁,这样做的目的是减少挂起次数。  \nrelease()/解锁ReentrantLock.unLocak()-&gt;AQS.release()  \n123456789//tryRelease返回true说明当前线程释放了所有的锁if (tryRelease(arg)) &#123;    Node h = head;    if (h != null &amp;&amp; h.waitStatus != 0)        //唤醒后继结点        unparkSuccessor(h);    return true;&#125;return false;\nacquire()唤醒唤醒后继结点后,后继节点中的线程就会回到acquireQueued方法中,此时后继结点的前驱结点就是head了,就可以再次尝试获取锁。  \n1234567891011121314//release调用链中,这里的Node就是head  int ws = node.waitStatus;  if (ws &lt; 0)      compareAndSetWaitStatus(node, ws, 0);  Node s = node.next;  if (s == null || s.waitStatus &gt; 0) &#123;      s = null;      //从tail向前遍历,找到可以唤醒的Node      for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)          if (t.waitStatus &lt;= 0)              s = t;  &#125;  if (s != null)      LockSupport.unpark(s.thread);\nacquireInterruptibly()/响应中断的加锁对于中断的相应,关键在于doAcquireInterruptibly()的最后一段。1234//如果在这里挂起的过程中如果线程被中断了,需要抛InterruptedException,      if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;          parkAndCheckInterrupt())          throw new InterruptedException();\n与不响应中断的acquireQueued对比发现,这里直接抛出了异常,而acquireQueued只是记录一下当前线程被中断过,换句话说,如果最后的上锁调用了acquireQueued(),那么在其他地方调用线程的interrupt方法可以唤醒线程(interrupt可以唤醒LockSupport.park),但是无法退出acquireQueued循环(因为他不抛异常而是直接进行下一次循环,会再次挂起),那么就有可能死锁。  \n细节1.在ReentrantLock.tryAcquire调用hasQueuedPredecessors方法时  \n12345Node t = tail;Node h = head;Node s;return h != t &amp;&amp;    ((s = h.next) == null || s.thread != Thread.currentThread());\n这里先获取了tail,再获取了head。考虑这么一种情况:A线程获取到锁,B线程尝试获取锁失败,进入enq准备将自己加入等待队列,A线程释放锁,C线程尝试获取锁发现state==0,调用hasQueuedPredecessors查看是否有线程在等待(B的enq还没开始执行),在判断的时候可能B线程正在调用enq入队,而enq中先设置的head,再设置的tail,那么在并发中”最差”的情况可能就是t==null,h!=null(为t赋值时,enq还没有为tail赋值),那么接下来的判断仍然会返回true(正确反映了B线程在等待队列中这一情况),然而如果先获取h=head,再t=tail,那么可能出现h==null,但t!=null的情况,将会返回false-&gt;返回错误!  \n123if (t == null) &#123;        if (compareAndSetHead(new Node()))            tail = head;\n\n\n\n在unparkSuccessor方法中,如果node.next==null,采用的是从tail反向遍历队列,也就是说结点的next字段为null,不足以说明该结点是队列中的最后一个结点(这句话在next声明处有注释说明),这是因为node本身是一个双向队列,无法使用CAS进行无锁的双向队列插入操作,所以结点插入自然就不是原子的,在addWaiter方法中,不论是fast path还是enq方法都是CAS设置tail,最后处理原队尾结点的next字段,所以从tail进行的反向遍历可以保证找到那些新插入的结点。\nAQS/ConditionAQS的内部类ConditionObject维护条件队列(单向列表,使用nextWaiter字段),每当有线程调用Condition.await()时,就会将当前线程包装为Node并添加到对应Condition的条件队列中然后释放锁,当调用Condition.signal()时就会将相应条件队列中第一个Node移除并添加到同步队列中等待获取锁。    \nawait()/等待123456789101112131415161718192021if (Thread.interrupted())      throw new InterruptedException();  //将当前线程封装为Node并添加到条件队列中  Node node = addConditionWaiter();  //释放当前线程持有的所有的锁并返回持有的所有的锁(有可能是重入的)  int savedState = fullyRelease(node);  int interruptMode = 0;  //isOnSyncQueue判断当前结点是否在同步队列中  while (!isOnSyncQueue(node)) &#123;      //线程最终在这里被挂起      LockSupport.park(this);      //如果线程被中断,退出循环      if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)          break;  &#125;  if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)      interruptMode = REINTERRUPT;  if (node.nextWaiter != null) // clean up if cancelled      unlinkCancelledWaiters();  if (interruptMode != 0)      reportInterruptAfterWait(interruptMode);\naddConditionWaiter()1234567891011121314Node t = lastWaiter;//如果最后一个节点取消了,将其清除if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;    //遍历清除条件队列中取消了的Node    unlinkCancelledWaiters();    t = lastWaiter;&#125;Node node = new Node(Thread.currentThread(), Node.CONDITION);if (t == null)    firstWaiter = node;else    t.nextWaiter = node;lastWaiter = node;return node;\nunlinkCancelledWaiters()就是简单的遍历链表\nisOnSyncQueue()12345678910//后如果node的前驱为null说明仍然在条件队列中(条件队列是单向链表,// 如果Node被转移到同步队列其前驱不会是null)if (node.waitStatus == Node.CONDITION || node.prev == null)    return false;if (node.next != null) //如果有后继结点一定在同步队列中,因为条件队列的\"后继\"通过nextWaiter属性表示    return true;//走到这里说明waitStatus不为CONDITION且前驱不为null,那么从同步队列的tail开始向前遍历尝试查找当前Node//注意:前驱不为null并不能说明当前Node已经加入同步队列,addWaiter中可以看到,结点入队时,先指定结点的前驱为tail,// 再尝试CAS将结点设置为tail,但是CAS操作可能会失败(此时为入队,但结点前驱不为null),失败后就要调用enq循环入队return findNodeFromTail(node);\n响应中断的await在响应中断的await方法中,doAcquireInterruptibly()会响应中断。  \n123456789101112131415161718192021222324  private void doAcquireInterruptibly(int arg)    throws InterruptedException &#123;    final Node node = addWaiter(Node.EXCLUSIVE);    boolean failed = true;    try &#123;        for (;;) &#123;            final Node p = node.predecessor();            if (p == head &amp;&amp; tryAcquire(arg)) &#123;                setHead(node);                p.next = null; // help GC                failed = false;                return;            &#125;            //如果在这里挂起的过程中如果线程被中断了,需要抛InterruptedException,            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;                parkAndCheckInterrupt())                throw new InterruptedException();        &#125;    &#125; finally &#123;        //抛异常后failed=true,取消acquire        if (failed)            cancelAcquire(node);    &#125;&#125;\nsignal()/转移123456789public final void signal() &#123;    //如果调用signal的线程不是当前占有锁的线程    if (!isHeldExclusively())        throw new IllegalMonitorStateException();    Node first = firstWaiter;    //唤醒条件队列中的第一个Node    if (first != null)        doSignal(first);&#125;\ndoSignal()1234567891011private void doSignal(Node first) &#123;     do &#123;         //更新firstWaiter         if ( (firstWaiter = first.nextWaiter) == null)             lastWaiter = null;         //取消引用         first.nextWaiter = null;         //如果转移失败,那么尝试转移firstWaiter(也就是first结点的下一个结点)(如果不为null的话)     &#125; while (!transferForSignal(first) &amp;&amp;              (first = firstWaiter) != null); &#125;\ntransferForSignal()该方法主要负责将Node从条件队列中转移到同步队列  \n123456789101112final boolean transferForSignal(Node node) &#123;    //新加入同步队列的Node的waitStatus是0,如果更新失败说明当前Node已经不是CONDITION(被取消或已被其他结点先行加入同步队列)    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))        return false;    //将当前Node入队,p是Node在同步队列中的前驱结点    Node p = enq(node);    int ws = p.waitStatus;    //如果前驱结点的waitStatus&gt;0(取消等待)或设置前驱结点的status为SIGNAL失败,那么需要唤醒当前结点的线程并返回true    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))        LockSupport.unpark(node.thread);    return true;&#125;\nawait()/唤醒后当Node被加入到同步队列/被唤醒后,继续回到await方法  \n1234567while (!isOnSyncQueue(node)) &#123;    //线程最终在这里被挂起    LockSupport.park(this);    //如果线程被中断,退出循环    if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)        break;&#125;\n虚假唤醒两种情况1.资源问题  \n\n线程A因没有资源等待在条件队列中  \n线程B放入一个资源,condition.signal()将线程A转到同步队列中-&gt;lock.unlock()  \n线程C进入,抢到锁,消耗资源。  \n线程B抢到锁,然而此时并没有资源可使用所以大部分情况下对于条件变量都会使用while判断而不是if。  \n\n2.系统底层问题(这个其实没有理解)  \n对于AQS中的await(),即使线程被唤醒,while循环仍然需要检查当前结点是否在同步队列中,这是因为LockSupport.park()/unpark()方法依赖于Linux底层的pthread_cond_wait/pthread_cond_signal,官方解释说pthread_cond_signal在多处理器情况下有可能唤醒多个线程,甚至在没有调用pthread_cond_signal的情况下,pthread_cond_wait也可能会返回。  \n疑问ReentrantLock和AQS中一共只有两处调用了LockSupport.unpark,分别在unparkSuccessor(唤醒同步队列中后继线程),transferForSignal(将结点从条件队列移到同步队列后唤醒结点线程回到await方法)。在await中结点线程被unpark唤醒后,while循环再次判断当前结点是否在同步队列中,然而transferForSignal方法中是先调用enq入队再unpark唤醒结点线程的,enq是不断循环最终一定能入队的一个方法,而且对于JDK来说,他是在Java层面维护的同步队列,所以貌似唯一可能出现”结点线程被唤醒然而while条件不满足(被唤醒的结点并不在同步队列)”的情况就是pthread_cond_signal唤醒超过一个线程(回到了上面说的…),也就是说在Java层面不可能出现while条件不满足的情况?然而,为什么在C层面会出现这种情况呢?  \n检查中断interruptMode可以取三值REINTERRUPT:代表await返回的时候,需要重新设置中断状态。THROW_IE:代表await返回的时候,需要抛出InterruptedException异常。0:说明在await期间,没有发生中断,无须进行任何处理。  \n1234567private int checkInterruptWhileWaiting(Node node) &#123;    //如果线程处于中断状态    return Thread.interrupted() ?            //如果是signal前中断,返回THROW_IE,否则返回REINTERRUPT        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :        0;&#125;\n这里的transfer主要就是判断中断的时机  \n123456789101112 final boolean transferAfterCancelledWait(Node node) &#123;    //因为signal中会将status置为0,所以如果这一步成功就说明是signal之前中断的    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) &#123;        //signal前中断,就再加入到同步队列中        enq(node);        return true;    &#125;    //这里说明signal将status设置为0,但signal可能还没有完成,等待signal完成(移入同步队列)    while (!isOnSyncQueue(node))        Thread.yield();    return false;&#125;\n可以看到即使线程被中断,一样会进入同步队列。  \nawait()最后12345678910111213//node就是最开始await的node,saveState就是该node需要的锁(资源)的数量//acquireQueued尝试获取锁(获取不到就等待),该放方法的返回值就是在获取锁的过程中是否有被中断//如果acquire返回true且interruptMode!=THROW_IE说明线程是在signal前被中断的,在稍后需要重新设置中断状态if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)    interruptMode = REINTERRUPT;//如果signal正常执行,那么node.nextWaiter已经被置为null,如果在signal后就已经被中断了,//那么仍然会在上面的checkInterruptWhileWaiting方法中将node移到同步队列(但是通过enq移入的,并没有将nextWaiter置null)//那么就需要清理清理同步队列if (node.nextWaiter != null) // clean up if cancelled    unlinkCancelledWaiters();if (interruptMode != 0)    //对线程的中断进行处理    reportInterruptAfterWait(interruptMode);\nawait()最后在返回前会处理中断。  \n123456789private void reportInterruptAfterWait(int interruptMode)    throws InterruptedException &#123;    //抛出中断异常    if (interruptMode == THROW_IE)        throw new InterruptedException();    //重新设置中断状态为true    else if (interruptMode == REINTERRUPT)        selfInterrupt();&#125;\n参考深入分析ThreadLocal内存泄漏问题ThreadLocal解析一行一行源码分析清楚AbstractQueuedSynchronizerJava的LockSupport.park()实现分析","dateCreated":"2018-08-13T21:31:37+08:00","dateModified":"2019-03-09T15:48:46+08:00","datePublished":"2018-08-13T21:31:37+08:00","description":"Java多线程(三)源码:ThreadLocal/AQS/ReentrantLock/Condition","headline":"Java多线程(三)","image":["https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/weekly3/Java.png","https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2018/08/13/Java多线程3/"},"publisher":{"@type":"Organization","name":"一条咸鱼","sameAs":[],"image":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg","logo":{"@type":"ImageObject","url":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"}},"url":"http://yoursite.com/2018/08/13/Java多线程3/","thumbnailUrl":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/weekly3/Java.png"}</script>
    <meta name="description" content="Java多线程(三)源码:ThreadLocal/AQS/ReentrantLock/Condition">
<meta property="og:type" content="blog">
<meta property="og:title" content="Java多线程(三)">
<meta property="og:url" content="http://yoursite.com/2018/08/13/Java多线程3/index.html">
<meta property="og:site_name" content="一条咸鱼">
<meta property="og:description" content="Java多线程(三)源码:ThreadLocal/AQS/ReentrantLock/Condition">
<meta property="og:locale" content="zh-cn">
<meta property="og:updated_time" content="2019-03-09T07:48:46.146Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java多线程(三)">
<meta name="twitter:description" content="Java多线程(三)源码:ThreadLocal/AQS/ReentrantLock/Condition">
<meta property="fb:app_id" content="[object Object]">
    
    
        
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"/>
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/weekly3/Java.png"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/weekly3/Java.png" />
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg" />
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-du2xmrqdqrl2ollgeiw050kpl6l4nbyz7bumjuurjgsxyopifvukebxc9lqe.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">一条咸鱼</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
                </a>
                <h4 class="sidebar-profile-name">一条咸鱼</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Java Developer</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="首页">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link open-algolia-search" href="/all-archives" title="归档">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/about" title="关于">
                    
                        <i class="sidebar-button-icon fa fa-user" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-center
                    post-header-cover--full" style="background-image:url('https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg');" data-behavior="4">
            
                <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            Java多线程(三)
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-08-13T21:31:37+08:00">
	
		    8月 13, 2018
    	
    </time>
    
</div>

    
</div>

            
        </div>

            <div id="main" data-behavior="4"
                 class="hasCover
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <!-- excerpt -->  <p></p>
<h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ThreadLocal"><span class="toc-text">ThreadLocal</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#介绍"><span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal的内存泄漏"><span class="toc-text">ThreadLocal的内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set"><span class="toc-text">set()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#清理替换"><span class="toc-text">清理替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rehash-resize"><span class="toc-text">rehash()/resize()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get"><span class="toc-text">get()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AQS-ReentrantLock"><span class="toc-text">AQS/ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本属性"><span class="toc-text">基本属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#acquire-加锁"><span class="toc-text">acquire()/加锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tryAcquire"><span class="toc-text">tryAcquire()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addWaiter"><span class="toc-text">addWaiter()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enq"><span class="toc-text">enq()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#acquireQueued"><span class="toc-text">acquireQueued()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#挂起"><span class="toc-text">挂起</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#release-解锁"><span class="toc-text">release()/解锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#acquire-唤醒"><span class="toc-text">acquire()唤醒</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#acquireInterruptibly-响应中断的加锁"><span class="toc-text">acquireInterruptibly()/响应中断的加锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#细节"><span class="toc-text">细节</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AQS-Condition"><span class="toc-text">AQS/Condition</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#await-等待"><span class="toc-text">await()/等待</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#addConditionWaiter"><span class="toc-text">addConditionWaiter()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#isOnSyncQueue"><span class="toc-text">isOnSyncQueue()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#响应中断的await"><span class="toc-text">响应中断的await</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#signal-转移"><span class="toc-text">signal()/转移</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#doSignal"><span class="toc-text">doSignal()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transferForSignal"><span class="toc-text">transferForSignal()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#await-唤醒后"><span class="toc-text">await()/唤醒后</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#虚假唤醒"><span class="toc-text">虚假唤醒</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#疑问"><span class="toc-text">疑问</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检查中断"><span class="toc-text">检查中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await-最后"><span class="toc-text">await()最后</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>ThreadLocal提供了线程本地变量,它可以保证访问到的变量属于当前线程,每个线程都保存有一个变量副本,每个线程的变量都不同,而同一个线程在任何时候访问这个本地变量的结果都是一致的。当一个线程结束时,它所使用的所有 ThreadLocal 相对的实例副本都可被回收。ThreadLocal相当于提供了一种线程隔离,将变量与线程绑定的方法。ThreadLocal通常定义为private static类型。<br>每个Thread实例中,都有ThreadLocalMap(ThreadLocal内部类)引用,第一次调用ThreadLocal#set(value),getMap()返回Thread#ThreadLocalMap对象(为null),createMap()实例化一个ThreadLocalMap并赋值给Thread#ThreadLocalMap。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">      Thread t = Thread.currentThread();</span><br><span class="line">      ThreadLocalMap map = getMap(t);</span><br><span class="line">      <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">          map.set(<span class="keyword">this</span>, value);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          createMap(t, value);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ThreadLocalMap内部用一个Entry数组存储value,key就是ThreadLocal实例,通过ThreadLocal.threadLocalHashCode计算来确定value在Entry中的index,并通过线性探测法解决冲突。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">      table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">      <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">      table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">      size = <span class="number">1</span>;</span><br><span class="line">      setThreshold(INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>某一线程调用get()时,先获取到当前线程私有的ThreadLocalMap,再通过ThreadLocal作为key获得最终的value。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以如下代码为例具体说明其作用:thread1和thread2分别拥有自己的threadLocalMap,当两个线程运行唯一的Runnable时,Runnable内部的ThreadLocal会获取到运行他的线程的Map并为该map设置值,获取时类似。可以看到在多个线程运行一个Runnable时,对于数据即没有冲突也没有加锁而是没有每个线程都有一个副本。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadLocal.set((<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>D));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     MyRunnable sharedRunnableInstance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">     Thread thread1 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</span><br><span class="line">     Thread thread2 = <span class="keyword">new</span> Thread(sharedRunnableInstance);</span><br><span class="line">     thread1.start();</span><br><span class="line">     thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个线程需要同一个变量的一个副本:一个ThreadLocal实例即可。<br>多个线程需要多个变量的一个副本:需要多个ThreadLocal。  </p>
<h2 id="ThreadLocal的内存泄漏"><a href="#ThreadLocal的内存泄漏" class="headerlink" title="ThreadLocal的内存泄漏"></a>ThreadLocal的内存泄漏</h2><p>ThreadLocalMap内部使用了一个Entry数组来存储Value,Entry本身继承弱引用同时存储value。如果ThreadLocal实例没有强引用指向他,他将被回收,那么此时ThreadLocalMap中以他作为key的那些value将无法再被访问到,但是这个value仍然有一条Thread-&gt;ThreadLocalMap-&gt;Entry-&gt;Value的强引用链。那么就会造成value的内存泄漏。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种内存泄漏的情况JDK本身已经考虑到,所以在get()/set()/remove()时一旦有机会就会尝试去清理key为null的value。      </p>
<h2 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h2><p>ThreadLocalMap.set()首先计算出当前key对应index上的Entry,如果key相等直接返回。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">//key/k相等,对值进行更新即可</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//k为空,需要替换并清理Entry数组</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里,说明既不冲突也暂时未发现key为null的Entry,那么插入一个新的Entry并尝试对数组进行清理</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">//如果没能清理掉任何一个Entry且size大于扩容阈值,调用rehash扩容</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br></pre></td></tr></table></figure>
<h3 id="清理替换"><a href="#清理替换" class="headerlink" title="清理替换"></a>清理替换</h3><p>如果k为null则需要进行替换并清理replaceStaleEntry  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    <span class="comment">//从过期槽位向后遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">//找到与set()的key相等的Entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="comment">//更新value,交换过期Entry和当前Entry</span></span><br><span class="line">            e.value = value;</span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line">            <span class="comment">//如果slotToExpunge和最初传入的过期槽位相等,即在先前的向前遍历过程中</span></span><br><span class="line">            <span class="comment">//在过期槽位之前没有发现过期Entry,那么将i赋值给slotToExpunge(上一步中已经将过期Entry与i交换了)</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果k(ThreadLocal)为null且slotToExpunge和最初传入的过期槽位相等,即在先前的向前遍历过程中</span></span><br><span class="line">        <span class="comment">//在过期槽位之前没有发现过期Entry,那么当前Entry就是要清理的Entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里说明先前的向后遍历过程中没有发现k/key相等的Entry</span></span><br><span class="line">    <span class="comment">//将过期槽位的value置null,帮助GC,然后插入新的Entry</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="comment">//如果过期槽位和slotToExpunge不等,说明还有其他需要清理的Entry,清理之</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br></pre></td></tr></table></figure>
<p>真正的清理工作由expungeStaleEntry来做  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">//先清理掉当前过期Entry</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">    <span class="comment">//从传入的过期槽位向后遍历,如果发现了过期Entry,清理之</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果不是过期Entry,重新计算其index</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                <span class="comment">//第一次计算所得index若和其当前index不相等,则将当前index的Entry置null</span></span><br><span class="line">                <span class="comment">//并继续计算-&gt;rehash过程</span></span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//至此,rehash和清理过程完成,返回最初传入的过期槽位的下一个Entry==null槽位</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cleanSomeSlots是一种随缘(启发式?)清理算法  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">      Entry[] tab = table;</span><br><span class="line">      <span class="comment">//n初始值就是len</span></span><br><span class="line">      <span class="keyword">int</span> len = tab.length;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">          i = nextIndex(i, len);</span><br><span class="line">          Entry e = tab[i];</span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//一旦发现过期Entry就将n重新置为len,并且调用清理方法进行清理</span></span><br><span class="line">              n = len;</span><br><span class="line">              removed = <span class="keyword">true</span>;</span><br><span class="line">              i = expungeStaleEntry(i);</span><br><span class="line">          &#125;</span><br><span class="line">       <span class="comment">//(n=n/2)!=0,注释说这种是对于"不扫描"和"遍历"的一种平衡</span></span><br><span class="line">       <span class="comment">//这样的扫描方式有可能留有过期Entry</span></span><br><span class="line">      &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> removed;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="rehash-resize"><a href="#rehash-resize" class="headerlink" title="rehash()/resize()"></a>rehash()/resize()</h3><p>接下来回到ThreadLocalMap.set()的最后一段,其有可能调用rehash()  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先清理</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="comment">//清理后如果size还＞扩容阈值的3/4,那么进行扩容,这里也可以看出Entry数组的真正可用量是数组长度的3/4</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>resize代码很简单,就是引用复制  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        <span class="comment">//新数组长度是旧数组长度的两倍</span></span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br></pre></td></tr></table></figure>
<h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p>ThreadLocal.get()-&gt;ThreadLocalMap.getEntry(),一旦未命中就有机会清理过期Entry  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">      Entry e = table[i];</span><br><span class="line">      <span class="comment">//如果一次命中,直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      <span class="comment">//未命中(可能会清理过期Entry)</span></span><br><span class="line">          <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br></pre></td></tr></table></figure>
<p>getEntryAfterMiss代码也很简单  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">      <span class="keyword">if</span> (k == key)</span><br><span class="line">          <span class="keyword">return</span> e;</span><br><span class="line">      <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">          expungeStaleEntry(i);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          i = nextIndex(i, len);</span><br><span class="line">      e = tab[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>ThreadLocal关键代码解析完毕。<br>回想最开始提到的ThreadLocal的内存泄漏问题可以发现,ThreadLocal的内存泄漏和弱引用并没有什么关系,关键在于ThreadLocalMap的生命周期基本是和Thread一样长的,只要没有手动remove,就有可能发生内存泄漏。  </p>
<h1 id="AQS-ReentrantLock"><a href="#AQS-ReentrantLock" class="headerlink" title="AQS/ReentrantLock"></a>AQS/ReentrantLock</h1><p>AQS是并发工具的基础类,以下结合ReentrantLock公平模式解析源码    </p>
<h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><p>AQS使用Node(双向结点)封装那些等待锁的线程,其有独占和共享两种模式(锁的模式),内部的waitStatus表示该结点的等待状态<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表明该结点的线程已经取消等锁(超时或中断等原因)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">//表明该结点的线程在释放锁时有责任去唤醒后继结点中的线程</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//表明该结点的线程处于条件等待状态</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">//共享模式下,该结点线程释放共享锁时应该传播通知后面的所有结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<p>AQS本身维护着Node队列,他有一个state属性用于表示获取锁的次数(可以重入)  </p>
<h2 id="acquire-加锁"><a href="#acquire-加锁" class="headerlink" title="acquire()/加锁"></a>acquire()/加锁</h2><p>ReentrantLock.lock()-&gt;AQS.acquire(1)  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先尝试获取锁,获取失败则要进入等待队列</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br></pre></td></tr></table></figure>
<h3 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire()"></a>tryAcquire()</h3><p>FariSync.tryAcquire尝试获取锁  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">  <span class="comment">//获取到AQS的state</span></span><br><span class="line">  <span class="keyword">int</span> c = getState();</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//如果没有线程获得锁,公平模式需要先查看是否还有其他线程在等待锁</span></span><br><span class="line">      <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">          compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">          <span class="comment">//没有等待线程,且CAS上锁成功,设置当前线程为持有锁的线程</span></span><br><span class="line">          setExclusiveOwnerThread(current);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果有线程获得了锁,判断获得锁的线程是否是当前线程</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">      <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">      <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">      setState(nextc);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//尝试获取失败</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<h4 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter()"></a>addWaiter()</h4><p>如果尝试获取失败,调用addWaiter添加等待结点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"><span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">Node pred = tail;</span><br><span class="line"><span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//设置tail结点为入队结点的前驱结点</span></span><br><span class="line">    node.prev = pred;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">        <span class="comment">//如果CAS将入队结点成功设置为尾结点就可以返回</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//走到这里,说明tail为null或者CAS操作失败(还有其他结点在竞争入队)</span></span><br><span class="line"><span class="comment">//那么调用enq不断循环直到入队成功</span></span><br><span class="line"><span class="comment">//注意到新入队的结点的waitStatuss=0</span></span><br><span class="line">enq(node);</span><br><span class="line"><span class="keyword">return</span> node;</span><br></pre></td></tr></table></figure>
<h4 id="enq"><a href="#enq" class="headerlink" title="enq()"></a>enq()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="comment">//tail为null说明队列为空,初始化tail和head。当然,也有可能是多个线程在竞争初始化,所以仍然调用CAS</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;<span class="comment">//可以看到head是一个空结点,并不包含线程</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">            tail = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node.prev = t;</span><br><span class="line">        <span class="comment">//走到这里说明tail/head一定不为null,尝试设置当前结点为tail</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">            t.next = node;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued()"></a>acquireQueued()</h3><p>入队完成后,回到acquireQueued(addWaiter(Node.EXCLUSIVE), arg)中  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">        <span class="comment">//p是Node的前驱结点,如果p==head,那么当前结点再次尝试获取锁</span></span><br><span class="line">        <span class="comment">// (因为他是持有锁的线程的下一个线程,所以他现在有可能获取的到锁)</span></span><br><span class="line">        <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            setHead(node);</span><br><span class="line">            p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> interrupted;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//走到这里说明当前线程有可能需要被挂起,先进行判断,如果应该被挂起,则进行挂起操作</span></span><br><span class="line">        <span class="comment">//如果返回true,LockSupport直接将当前线程挂起即可</span></span><br><span class="line">        <span class="comment">//否则进行下一次循环</span></span><br><span class="line">        <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">            parkAndCheckInterrupt())</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h4><p>shouldParkAfterFailedAcquire就是判断前驱结点状态,因为他要保证当前线程被挂起后,能在未来的某个时间被前驱结点唤醒,也即他的前驱结点状态要是SIGNAL  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line"><span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">    <span class="comment">//前驱结点状态为SIGNAL(说明前驱结点可以唤醒后继结点(当前结点))</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//&gt;0说明前驱结点已被取消(等待超时等原因)</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//向前遍历找到一个没有取消的结点作为前驱</span></span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line">    &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">    pred.next = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果是其他情况,将前驱结点设置为SIGNAL</span></span><br><span class="line">    compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p>由于新入队的结点的waitStatus都是0,而他的waitStatus的更新依赖于后插入的结点的should判断,所以acquireQueued第一次循环很有可能并不挂起线程,而是在第一次should方法将前驱结点waitStatus设置为SIGNAL后,在第二次循环再挂起,原因是,如果第一次should判断没有返回true,第二次循环的时候,当前结点有可能已经是head的后继结点了,所以可以在for循环中,再尝试获取一次锁,这样做的目的是减少挂起次数。  </p>
<h2 id="release-解锁"><a href="#release-解锁" class="headerlink" title="release()/解锁"></a>release()/解锁</h2><p>ReentrantLock.unLocak()-&gt;AQS.release()  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tryRelease返回true说明当前线程释放了所有的锁</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    Node h = head;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//唤醒后继结点</span></span><br><span class="line">        unparkSuccessor(h);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<h3 id="acquire-唤醒"><a href="#acquire-唤醒" class="headerlink" title="acquire()唤醒"></a>acquire()唤醒</h3><p>唤醒后继结点后,后继节点中的线程就会回到acquireQueued方法中,此时后继结点的前驱结点就是head了,就可以再次尝试获取锁。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//release调用链中,这里的Node就是head</span></span><br><span class="line">  <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">  <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">      compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">  Node s = node.next;</span><br><span class="line">  <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      s = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//从tail向前遍历,找到可以唤醒的Node</span></span><br><span class="line">      <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">          <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">              s = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">      LockSupport.unpark(s.thread);</span><br></pre></td></tr></table></figure>
<h2 id="acquireInterruptibly-响应中断的加锁"><a href="#acquireInterruptibly-响应中断的加锁" class="headerlink" title="acquireInterruptibly()/响应中断的加锁"></a>acquireInterruptibly()/响应中断的加锁</h2><p>对于中断的相应,关键在于doAcquireInterruptibly()的最后一段。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果在这里挂起的过程中如果线程被中断了,需要抛InterruptedException,</span></span><br><span class="line">      <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">          parkAndCheckInterrupt())</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br></pre></td></tr></table></figure></p>
<p>与不响应中断的acquireQueued对比发现,这里直接抛出了异常,而acquireQueued只是记录一下当前线程被中断过,换句话说,如果最后的上锁调用了acquireQueued(),那么在其他地方调用线程的interrupt方法可以唤醒线程(interrupt可以唤醒LockSupport.park),但是无法退出acquireQueued循环(因为他不抛异常而是直接进行下一次循环,会再次挂起),那么就有可能死锁。  </p>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>1.<br>在ReentrantLock.tryAcquire调用hasQueuedPredecessors方法时  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node t = tail;</span><br><span class="line">Node h = head;</span><br><span class="line">Node s;</span><br><span class="line"><span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">    ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br></pre></td></tr></table></figure>
<p>这里先获取了tail,再获取了head。<br>考虑这么一种情况:A线程获取到锁,B线程尝试获取锁失败,进入enq准备将自己加入等待队列,A线程释放锁,C线程尝试获取锁发现state==0,调用hasQueuedPredecessors查看是否有线程在等待(B的enq还没开始执行),在判断的时候可能B线程正在调用enq入队,而enq中先设置的head,再设置的tail,那么在并发中”最差”的情况可能就是t==null,h!=null(为t赋值时,enq还没有为tail赋值),那么接下来的判断仍然会返回true(正确反映了B线程在等待队列中这一情况),然而如果先获取h=head,再t=tail,那么可能出现h==null,但t!=null的情况,将会返回false-&gt;返回错误!  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">            tail = head;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li></li>
</ol>
<p>在unparkSuccessor方法中,如果node.next==null,采用的是从tail反向遍历队列,也就是说结点的next字段为null,不足以说明该结点是队列中的最后一个结点(这句话在next声明处有注释说明),这是因为node本身是一个双向队列,无法使用CAS进行无锁的双向队列插入操作,所以结点插入自然就不是原子的,在addWaiter方法中,不论是fast path还是enq方法都是CAS设置tail,最后处理原队尾结点的next字段,所以从tail进行的反向遍历可以保证找到那些新插入的结点。</p>
<h1 id="AQS-Condition"><a href="#AQS-Condition" class="headerlink" title="AQS/Condition"></a>AQS/Condition</h1><p>AQS的内部类ConditionObject维护条件队列(单向列表,使用nextWaiter字段),每当有线程调用Condition.await()时,就会将当前线程包装为Node并添加到对应Condition的条件队列中然后释放锁,当调用Condition.signal()时就会将相应条件队列中第一个Node移除并添加到同步队列中等待获取锁。    </p>
<h2 id="await-等待"><a href="#await-等待" class="headerlink" title="await()/等待"></a>await()/等待</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">  <span class="comment">//将当前线程封装为Node并添加到条件队列中</span></span><br><span class="line">  Node node = addConditionWaiter();</span><br><span class="line">  <span class="comment">//释放当前线程持有的所有的锁并返回持有的所有的锁(有可能是重入的)</span></span><br><span class="line">  <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">  <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//isOnSyncQueue判断当前结点是否在同步队列中</span></span><br><span class="line">  <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">      <span class="comment">//线程最终在这里被挂起</span></span><br><span class="line">      LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">      <span class="comment">//如果线程被中断,退出循环</span></span><br><span class="line">      <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">      interruptMode = REINTERRUPT;</span><br><span class="line">  <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">      unlinkCancelledWaiters();</span><br><span class="line">  <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">      reportInterruptAfterWait(interruptMode);</span><br></pre></td></tr></table></figure>
<h3 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter()"></a>addConditionWaiter()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Node t = lastWaiter;</span><br><span class="line"><span class="comment">//如果最后一个节点取消了,将其清除</span></span><br><span class="line"><span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">    <span class="comment">//遍历清除条件队列中取消了的Node</span></span><br><span class="line">    unlinkCancelledWaiters();</span><br><span class="line">    t = lastWaiter;</span><br><span class="line">&#125;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line"><span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">    firstWaiter = node;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    t.nextWaiter = node;</span><br><span class="line">lastWaiter = node;</span><br><span class="line"><span class="keyword">return</span> node;</span><br></pre></td></tr></table></figure>
<p>unlinkCancelledWaiters()就是简单的遍历链表</p>
<h3 id="isOnSyncQueue"><a href="#isOnSyncQueue" class="headerlink" title="isOnSyncQueue()"></a>isOnSyncQueue()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后如果node的前驱为null说明仍然在条件队列中(条件队列是单向链表,</span></span><br><span class="line"><span class="comment">// 如果Node被转移到同步队列其前驱不会是null)</span></span><br><span class="line"><span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">//如果有后继结点一定在同步队列中,因为条件队列的"后继"通过nextWaiter属性表示</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//走到这里说明waitStatus不为CONDITION且前驱不为null,那么从同步队列的tail开始向前遍历尝试查找当前Node</span></span><br><span class="line"><span class="comment">//注意:前驱不为null并不能说明当前Node已经加入同步队列,addWaiter中可以看到,结点入队时,先指定结点的前驱为tail,</span></span><br><span class="line"><span class="comment">// 再尝试CAS将结点设置为tail,但是CAS操作可能会失败(此时为入队,但结点前驱不为null),失败后就要调用enq循环入队</span></span><br><span class="line"><span class="keyword">return</span> findNodeFromTail(node);</span><br></pre></td></tr></table></figure>
<h3 id="响应中断的await"><a href="#响应中断的await" class="headerlink" title="响应中断的await"></a>响应中断的await</h3><p>在响应中断的await方法中,doAcquireInterruptibly()会响应中断。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果在这里挂起的过程中如果线程被中断了,需要抛InterruptedException,</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//抛异常后failed=true,取消acquire</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="signal-转移"><a href="#signal-转移" class="headerlink" title="signal()/转移"></a>signal()/转移</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果调用signal的线程不是当前占有锁的线程</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="comment">//唤醒条件队列中的第一个Node</span></span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="doSignal"><a href="#doSignal" class="headerlink" title="doSignal()"></a>doSignal()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">         <span class="comment">//更新firstWaiter</span></span><br><span class="line">         <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">             lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">//取消引用</span></span><br><span class="line">         first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">         <span class="comment">//如果转移失败,那么尝试转移firstWaiter(也就是first结点的下一个结点)(如果不为null的话)</span></span><br><span class="line">     &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">              (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="transferForSignal"><a href="#transferForSignal" class="headerlink" title="transferForSignal()"></a>transferForSignal()</h3><p>该方法主要负责将Node从条件队列中转移到同步队列  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新加入同步队列的Node的waitStatus是0,如果更新失败说明当前Node已经不是CONDITION(被取消或已被其他结点先行加入同步队列)</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//将当前Node入队,p是Node在同步队列中的前驱结点</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">//如果前驱结点的waitStatus&gt;0(取消等待)或设置前驱结点的status为SIGNAL失败,那么需要唤醒当前结点的线程并返回true</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="await-唤醒后"><a href="#await-唤醒后" class="headerlink" title="await()/唤醒后"></a>await()/唤醒后</h2><p>当Node被加入到同步队列/被唤醒后,继续回到await方法  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    <span class="comment">//线程最终在这里被挂起</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//如果线程被中断,退出循环</span></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h3><p>两种情况<br>1.资源问题  </p>
<ul>
<li>线程A因没有资源等待在条件队列中  </li>
<li>线程B放入一个资源,condition.signal()将线程A转到同步队列中-&gt;lock.unlock()  </li>
<li>线程C进入,抢到锁,消耗资源。  </li>
<li>线程B抢到锁,然而此时并没有资源可使用<br>所以大部分情况下对于条件变量都会使用while判断而不是if。  </li>
</ul>
<p>2.系统底层问题(这个其实没有理解)  </p>
<p>对于AQS中的await(),即使线程被唤醒,while循环仍然需要检查当前结点是否在同步队列中,这是因为LockSupport.park()/unpark()方法依赖于Linux底层的pthread_cond_wait/pthread_cond_signal,官方解释说pthread_cond_signal在多处理器情况下有可能唤醒多个线程,甚至在没有调用pthread_cond_signal的情况下,pthread_cond_wait也可能会返回。  </p>
<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><p>ReentrantLock和AQS中一共只有两处调用了LockSupport.unpark,分别在unparkSuccessor(唤醒同步队列中后继线程),transferForSignal(将结点从条件队列移到同步队列后唤醒结点线程回到await方法)。<br>在await中结点线程被unpark唤醒后,while循环再次判断当前结点是否在同步队列中,然而transferForSignal方法中是先调用enq入队再unpark唤醒结点线程的,enq是不断循环最终一定能入队的一个方法,而且对于JDK来说,他是在Java层面维护的同步队列,所以貌似唯一可能出现”结点线程被唤醒然而while条件不满足(被唤醒的结点并不在同步队列)”的情况就是pthread_cond_signal唤醒超过一个线程(回到了上面说的…),也就是说在Java层面不可能出现while条件不满足的情况?然而,为什么在C层面会出现这种情况呢?  </p>
<h3 id="检查中断"><a href="#检查中断" class="headerlink" title="检查中断"></a>检查中断</h3><p>interruptMode可以取三值<br>REINTERRUPT:代表await返回的时候,需要重新设置中断状态。<br>THROW_IE:代表await返回的时候,需要抛出InterruptedException异常。<br>0:说明在await期间,没有发生中断,无须进行任何处理。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果线程处于中断状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">            <span class="comment">//如果是signal前中断,返回THROW_IE,否则返回REINTERRUPT</span></span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的transfer主要就是判断中断的时机  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//因为signal中会将status置为0,所以如果这一步成功就说明是signal之前中断的</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">//signal前中断,就再加入到同步队列中</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里说明signal将status设置为0,但signal可能还没有完成,等待signal完成(移入同步队列)</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到即使线程被中断,一样会进入同步队列。  </p>
<h3 id="await-最后"><a href="#await-最后" class="headerlink" title="await()最后"></a>await()最后</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//node就是最开始await的node,saveState就是该node需要的锁(资源)的数量</span></span><br><span class="line"><span class="comment">//acquireQueued尝试获取锁(获取不到就等待),该放方法的返回值就是在获取锁的过程中是否有被中断</span></span><br><span class="line"><span class="comment">//如果acquire返回true且interruptMode!=THROW_IE说明线程是在signal前被中断的,在稍后需要重新设置中断状态</span></span><br><span class="line"><span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">    interruptMode = REINTERRUPT;</span><br><span class="line"><span class="comment">//如果signal正常执行,那么node.nextWaiter已经被置为null,如果在signal后就已经被中断了,</span></span><br><span class="line"><span class="comment">//那么仍然会在上面的checkInterruptWhileWaiting方法中将node移到同步队列(但是通过enq移入的,并没有将nextWaiter置null)</span></span><br><span class="line"><span class="comment">//那么就需要清理清理同步队列</span></span><br><span class="line"><span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">    unlinkCancelledWaiters();</span><br><span class="line"><span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//对线程的中断进行处理</span></span><br><span class="line">    reportInterruptAfterWait(interruptMode);</span><br></pre></td></tr></table></figure>
<p>await()最后在返回前会处理中断。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//重新设置中断状态为true</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.xiaohansong.com/2016/08/06/ThreadLocal-memory-leak/" target="_blank" rel="noopener">深入分析ThreadLocal内存泄漏问题</a><br><a href="http://donald-draper.iteye.com/blog/2368159" target="_blank" rel="noopener">ThreadLocal解析</a><br><a href="https://javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">一行一行源码分析清楚AbstractQueuedSynchronizer</a><br><a href="https://blog.csdn.net/hengyunabc/article/details/28126139" target="_blank" rel="noopener">Java的LockSupport.park()实现分析</a></p>
            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/16/Java多线程4/" data-tooltip="Java多线程(四)" aria-label="上一篇: Java多线程(四)">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/10/Java多线程2/" data-tooltip="Java多线程(二)" aria-label="下一篇: Java多线程(二)">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 一条咸鱼. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/16/Java多线程4/" data-tooltip="Java多线程(四)" aria-label="上一篇: Java多线程(四)">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/10/Java多线程2/" data-tooltip="Java多线程(二)" aria-label="下一篇: Java多线程(二)">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-times"></i>
    <ul class="share-options">
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
        
            <h4 id="about-card-name">一条咸鱼</h4>
        
            <div id="about-card-bio"><p>重庆</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>学生</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/sideCover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-vufjrm3fmbuttogo1hxuu0w9w0sesk5iyysjuguc2hdhufot9szxg8twijry.min.js"></script>
<!--SCRIPTS END-->

    



    </body>
</html>
