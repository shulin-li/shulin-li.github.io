
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="一条咸鱼">
    <title>Java多线程(六) - 一条咸鱼</title>
    <meta name="author" content="一条咸鱼">
    
    
        <link rel="icon" href="http://yoursite.com/assets/images/favicon.ico">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"一条咸鱼","sameAs":[],"image":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"},"articleBody":"  \n\nHashMapJDK7put()123456789101112131415161718192021public V put(K key, V value) &#123;    if (key == null)//对于key为null的value,将其插入到table[0]。        return putForNullKey(value);    int hash = hash(key);    int i = indexFor(hash, table.length);    //如果key对应的Entry已经存在于table中,更新值    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;        Object k;        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;            V oldValue = e.value;            e.value = value;            //每当有Entry被overwrite,就会调用这个方法,HashMap的这个方法是空实现            e.recordAccess(this);            return oldValue;        &#125;    &#125;    //新加入的key,modCount记录的是map被修改的次数    modCount++;    addEntry(hash, key, value, i);    return null;&#125;\naddEntry()1234567891011void addEntry(int hash, K key, V value, int bucketIndex) &#123;    //如果当前容量大于扩容阈值,并且table[index]有元素,resize扩容    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;        resize(2 * table.length);        //重新计算hash值和index        hash = (null != key) ? hash(key) : 0;        bucketIndex = indexFor(hash, table.length);    &#125;    //实例化Entry并加入到map中    createEntry(hash, key, value, bucketIndex);&#125;\ntransfer()/转移tableresize就是实例化一个两倍原容量的table,调用transfer转移Entry。1234567891011121314151617void transfer(Entry[] newTable, boolean rehash) &#123;    int newCapacity = newTable.length;    for (Entry&lt;K,V&gt; e : table) &#123;// e:   a-&gt;b-&gt;c        //处理table[x]上的链表,处理完以后链表被反转(如果oldTable上的链表在newTable上还是被hash到一个index上的话)        while(null != e) &#123;            Entry&lt;K,V&gt; next = e.next; // next = b , e = a            if (rehash) &#123;                //重新计算hash值和index                e.hash = null == e.key ? 0 : hash(e.key);            &#125;            int i = indexFor(e.hash, newCapacity);            e.next = newTable[i]; // a.next = null            newTable[i] = e;     // 插入e            e = next;     // e = b        &#125;    &#125;&#125;\nget()就是根据key找到Entry并返回value。  \nHashMap并发下的问题假设初始情况下,map内如图此时两个线程AB调用put,由于容量&gt;=扩容阈值,所以两个线程各自实例化一个newTable然后两个线程都会调用transfer(),线程B执行到Entry&lt;K,V&gt; next = e.next,e指向结点a,next指向结点b-&gt;线程A执行完transfer,假设abc经过rehash后仍然在同一个index,但是线程A没有将newTable赋值给table线程B开始工作,内部的引用关系如图当线程B执行完transfer后,引用关系如图如果最终线程A将newTable赋值给table,当get的时候就可能会出现死循环问题,如果线程B最终将newTable赋值给table,不但会出现死循环问题还会丢失数据C。  \n上述死循环问题的原因所在就是对于链表的反序转移,JDK1.8解决了死循环问题,但是仍然会出现元素丢失问题。  \nJDK8putVal()put()就是直接调用putVal()\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    //第一次put,初始化Node数组    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    //计算要插入的结点的index,如果此处还未插入过结点,直接插入    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    else &#123;        //需要将要插入的结点插入到链表或红黑树中        //此时p指的是table[index]        Node&lt;K,V&gt; e; K k;        //如果p的key与要插入的key相等,用e备份p        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        //如果p是树节点,调用putTreeVal插入一个新树节点        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else &#123;            for (int binCount = 0; ; ++binCount) &#123;                //p处是一个链表,从p向后遍历插入一个新结点或更新值                if ((e = p.next) == null) &#123;                    p.next = newNode(hash, key, value, null);                    //如果插入结点后,链表长度超过8,需要将链表转化为红黑树                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                &#125;                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            &#125;        &#125;//e!=null说明在index处的Node就是要插入的key对应的Node,更新值,返回旧值        if (e != null) &#123; // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        &#125;    &#125;    ++modCount;//判断是否扩容    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);//空实现    return null;&#125;\nresize()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879final Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab = table;    int oldCap = (oldTab == null) ? 0 : oldTab.length;    int oldThr = threshold;    int newCap, newThr = 0;    if (oldCap &gt; 0) &#123;//扩容        //设置一些newTable的属性        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            return oldTab;        &#125;        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; 1;    &#125;    else if (oldThr &gt; 0) //实例化HashMap时指定了容量,随后第一次调用put()        newCap = oldThr;    else &#123;  //实例化HashMap时未指定容量,第一次调用put()        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;    if (newThr == 0) &#123;        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    &#125;    threshold = newThr;        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    table = newTab;    //扩容后的结点转移    if (oldTab != null) &#123;        for (int j = 0; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            if ((e = oldTab[j]) != null) &#123;                oldTab[j] = null;                if (e.next == null)                    newTab[e.hash &amp; (newCap - 1)] = e;                //如果是红黑树结点,将其分开成两棵树或链表                else if (e instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else &#123; //对于链表,保证原先的顺序                    //loHead/loTail表示的是在newTable中index与oldTable中的index相同的链表                    //hiHead/hiTail表示的是newTable中index=oldTable中index+oldCap的链表                    Node&lt;K,V&gt; loHead = null, loTail = null;                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    do &#123;                        next = e.next;                        //通过结点的hash与oldCap的按位与,可以直接计算出e的新的位置                        if ((e.hash &amp; oldCap) == 0) &#123;                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        &#125;                        else &#123;                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        &#125;                    &#125; while ((e = next) != null);                    //此时已经将先前的链表转化为新的两个链表,链表直接插入newTable即可                    if (loTail != null) &#123;                        loTail.next = null;                        newTab[j] = loHead;                    &#125;                    if (hiTail != null) &#123;                        hiTail.next = null;                        newTab[j + oldCap] = hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    return newTab;&#125;\n对于新index的计算:假设扩容前,size为8,元素A的hash为13,元素B的hash为5,他们在oldTable中的index都是5,可以看出,处于同一index的Node的hash要么相同,要么相差n*oldCap,同时可以发现如果元素hash&amp;oldCap&gt;1,那么说明元素hash本身大于oldCap,那么在扩容的时候该元素的新index就是原index+oldCap,通过这样的与运算判断,就可以不用重新计算hash值,提升了性能。  \nJDK8中的扩容通过两个引用(head/tail)保证了链表的顺序,从而避免了JDK7中的死循环,但是当多线程调用put(),且恰好向同一个index中添加元素时还是可能出现数据丢失的情况(被覆盖了)。\nLongAdderJDK8新增的类,为了改善AtomicLong在高并发情况下多线程CAS失败,自旋浪费CPU资源的情况。    \nCell父类Striped64的内部类,每一个Cell都可以看做一个AtomicLong,竞争激烈的情况下,操作LongAdder时,就是在操作具体的某一个Cell。  \nbase父类Striped64的一个属性,在进行加减操作时,先尝试CAS修改base,如果不成功,说明竞争激烈,那么再hash映射修改Cell。  \nadd()12345678910111213public void add(long x) &#123;    Cell[] as; long b, v; int m; Cell a;    //先尝试直接CAS操作base    if ((as = cells) != null || !casBase(b = base, b + x)) &#123;        boolean uncontended = true;        //CAS操作cell.value        if (as == null || (m = as.length - 1) &lt; 0 ||            (a = as[getProbe() &amp; m]) == null ||            !(uncontended = a.cas(v = a.value, v + x)))            //调用父类的操作            longAccumulate(x, null, uncontended);    &#125;&#125;\n关键内容都在父类中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081final void longAccumulate(long x, LongBinaryOperator fn,                          boolean wasUncontended) &#123;    int h;    if ((h = getProbe()) == 0) &#123;        ThreadLocalRandom.current(); // force initialization        h = getProbe();        wasUncontended = true;    &#125;    boolean collide = false; //线程hash到的cell不是null,该值就是true,同时也可以表示扩容意向    for (;;) &#123;        Cell[] as; Cell a; int n; long v;        if ((as = cells) != null &amp;&amp; (n = as.length) &gt; 0) &#123;//cells已被初始化            if ((a = as[(n - 1) &amp; h]) == null) &#123;//当前线程hash到的cell为null                if (cellsBusy == 0) &#123;                    Cell r = new Cell(x);                    if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;//尝试CAS加锁                        boolean created = false;                        try &#123;               // Recheck under lock                            Cell[] rs; int m, j;                            if ((rs = cells) != null &amp;&amp;                                (m = rs.length) &gt; 0 &amp;&amp;                                rs[j = (m - 1) &amp; h] == null) &#123;//没有其他线程对这个位置的cell进行实例化                                rs[j] = r;                                created = true;                            &#125;                        &#125; finally &#123;                            cellsBusy = 0;//相当于释放锁,volatile变量直接赋值无需CAS                        &#125;                        if (created)                            break;                        continue;   //其他线程初始化了这个位置的cell                    &#125;                &#125;                collide = false;            &#125;            else if (!wasUncontended)    //传入false说明发生了线程竞争                wasUncontended = true;   // Continue after rehash            else if (a.cas(v = a.value, ((fn == null) ? v + x :                                         fn.applyAsLong(v, x))))                //尝试CAS更新cell.value成功,直接返回                break;            else if (n &gt;= NCPU || cells != as)//如果有其他线程扩容了cells                collide = false;            else if (!collide)//走到这里说明当前线程hash到的cell不为null,但是CAS操作失败了,说明竞争比较激烈                collide = true;//扩容意向置为true            else if (cellsBusy == 0 &amp;&amp; casCellsBusy()) &#123;//CAS上锁                try &#123;                    if (cells == as) &#123;  //cells扩容                        Cell[] rs = new Cell[n &lt;&lt; 1];                        for (int i = 0; i &lt; n; ++i)                            rs[i] = as[i];                        cells = rs;                    &#125;                &#125; finally &#123;                    cellsBusy = 0;                &#125;                collide = false;  //扩容意向设为false                continue;         //重新尝试            &#125;            h = advanceProbe(h);//重新给当前线程生成一个hash值(以降低竞争程度)        &#125;//这个else对应的是cells还未初始化,尝试CAS加锁以初始化cells        else if (cellsBusy == 0 &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;            boolean init = false;            try &#123;                           // Initialize table                if (cells == as) &#123;                    Cell[] rs = new Cell[2];                    rs[h &amp; 1] = new Cell(x);                    cells = rs;                    init = true;                &#125;            &#125; finally &#123;                cellsBusy = 0;            &#125;            if (init)                break;        &#125;//有其他线程正在初始化cells,当前线程直接在base上进行累加操作        else if (casBase(v = base, ((fn == null) ? v + x :                                    fn.applyAsLong(v, x))))            break;    &#125;&#125;\nsum()1234567891011public long sum() &#123;    Cell[] as = cells; Cell a;    long sum = base;    if (as != null) &#123;        for (int i = 0; i &lt; as.length; ++i) &#123;            if ((a = as[i]) != null)                sum += a.value;        &#125;    &#125;//返回的和并不一定准确,LondAdder保证的是结果的最终正确性    return sum;&#125;\nsum()不保证实时性。\nConcurrentHashMap内部类/属性ForwardingNode他是一个暂时类,他的hash固定为MOVED(-1),主要用作扩容时的一个标志位,其中有一个nextTable引用,如果读操作碰到某个bucket是ForwardingNode,就会调用他的find方法,随后ForwardingNode会在nextTable中寻找。  \nTreeBin红黑树的代理操作类,可以看做是红黑树的根结点。  \nbucketbucket指的是Map中的index(位置),由于ConcurrentHashMap的多数据结构,每个index处可能只是一个Node结点,也可能是一个链表,也可能是一颗红黑树,bucket算是一个统称。   \nCounterCell/baseCountConcurrentLinkedQueue使用LongAdder的思想计数。等同于Cell和base,所以ConcurrentHashMap的总Node数等于baseCount+CounterCell。  \nsizeCtl各种操作的一个记录为,sizeCtl=-1说明正在初始化table;sizeCtl&gt;0表明下一次扩容的threshold;sizeCtl&lt;-1说明正在多线程扩容,其值=-(基数+扩容线程数),基数是每次扩容时均不同的一个值。  \ntransferIndex用于记录扩容的任务其实下标,ConcurrentHashMap的扩容是多线程的,他的思想是每个线程负责一部分bucket的转移(默认16个),transferIndex&lt;=0时说明没有扩容任务了,当要扩容时,他的值从table.length-1向0不断移动(由高向低执行扩容任务)。  \ninitTable()1234567891011121314151617181920212223242526private final Node&lt;K,V&gt;[] initTable() &#123;    Node&lt;K,V&gt;[] tab; int sc;    while ((tab = table) == null || tab.length == 0) &#123;        if ((sc = sizeCtl) &lt; 0)//说明当前正有其他线程在做初始化工作            Thread.yield();        //CAS更新sizeCtl为-1表示自己在做初始化        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123;            try &#123;//再一次的判断table是否被初始化,假设线程AB都在initTable方法内,A已经初始化完table,sizeCtl&gt;0                //随后B进行第一个if判断(sc&gt;0),再else if CAS加锁,如果没有这一次的再判断,table将会被初始化两次                if ((tab = table) == null || tab.length == 0) &#123;                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;                    //默认容量为16                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];                    table = tab = nt;                    //sc=0.75*n                    sc = n - (n &gt;&gt;&gt; 2);//loadFactor已经无用了,统一使用0.75                &#125;            &#125; finally &#123;                //更新sizeCtl                sizeCtl = sc;            &#125;            break;        &#125;    &#125;    return tab;&#125;\nput()关键方法一样在putVal中。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768final V putVal(K key, V value, boolean onlyIfAbsent) &#123;    if (key == null || value == null) throw new NullPointerException();    int hash = spread(key.hashCode());    int binCount = 0;//记录对应的链表的长度    for (Node&lt;K,V&gt;[] tab = table;;) &#123;        Node&lt;K,V&gt; f; int n, i, fh;        if (tab == null || (n = tab.length) == 0)            tab = initTable();//初始化table        //如果bucket处没有Node,则将要插入的KV实例化为Node并CAS插入进table        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;            if (casTabAt(tab, i, null,                         new Node&lt;K,V&gt;(hash, key, value, null)))                break;                   // no lock when adding to empty bin        &#125;//表示该bucket的结点是ForwardingNode        else if ((fh = f.hash) == MOVED)            //帮助扩容            tab = helpTransfer(tab, f);        else &#123;            V oldVal = null;            //对当前bucket上锁            synchronized (f) &#123;                if (tabAt(tab, i) == f) &#123;                    if (fh &gt;= 0) &#123;//&gt;=0说明是链表                        binCount = 1;                        //遍历链表                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;                            K ek;                            //如果找到了相同的key,更新值                            if (e.hash == hash &amp;&amp;                                ((ek = e.key) == key ||                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;                                oldVal = e.val;                                if (!onlyIfAbsent)                                    e.val = value;                                break;                            &#125;//链表后插入新结点                            Node&lt;K,V&gt; pred = e;                            if ((e = e.next) == null) &#123;                                pred.next = new Node&lt;K,V&gt;(hash, key,                                                          value, null);                                break;                            &#125;                        &#125;                    &#125;//红黑树中插入一个结点                    else if (f instanceof TreeBin) &#123;                        Node&lt;K,V&gt; p;                        binCount = 2;                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                                       value)) != null) &#123;                            oldVal = p.val;                            if (!onlyIfAbsent)                                p.val = value;                        &#125;                    &#125;                &#125;            &#125;            if (binCount != 0) &#123;//查看是否要将链表转化为红黑树                if (binCount &gt;= TREEIFY_THRESHOLD)                    treeifyBin(tab, i);                if (oldVal != null)                    return oldVal;                break;            &#125;        &#125;    &#125;//更新总结点数。    addCount(1L, binCount);    return null;&#125;\ntransfer()在HashMap的扩容时说过,扩容后bucket的index要么是oldIndex,要么是oldTable.length+oldIndex,所以可以看出,在扩容的时候各bucket之间是互不影响的,即newTable上的每个bucket只会有一个线程操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;    int n = tab.length, stride;    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)        stride = MIN_TRANSFER_STRIDE; // 计算每个线程负责的任务数(需要转移的bucket个数)    if (nextTab == null) &#123;        try &#123;            @SuppressWarnings(\"unchecked\")            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];            nextTab = nt;        &#125; catch (Throwable ex) &#123;      // 处理OOM或table过大            sizeCtl = Integer.MAX_VALUE;            return;        &#125;        nextTable = nextTab;        transferIndex = n;//第一个转移的线程将该变量设置为数组的最后位置    &#125;    int nextn = nextTab.length;    //ForwardingNode是一个\"标志\",在putVal中可以看到,遇到ForwardingNode会帮助扩容(下面也有体现)    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);    boolean advance = true; //表明某bucket是否处理完    boolean finishing = false; // to ensure sweep before committing nextTab    for (int i = 0, bound = 0;;) &#123;        Node&lt;K,V&gt; f; int fh;        while (advance) &#123;//这个while循环负责确定每个线程的任务范围            int nextIndex, nextBound;            if (--i &gt;= bound || finishing)//这个地方--i,不断完成任务                advance = false;            //nextIndex&lt;=0说明所有的bucket转移工作都做完了(从后向前转移)            else if ((nextIndex = transferIndex) &lt;= 0) &#123;                i = -1;                advance = false;            &#125;            else if (U.compareAndSwapInt                     (this, TRANSFERINDEX, nextIndex,                      nextBound = (nextIndex &gt; stride ?                                   nextIndex - stride : 0))) &#123;                //可以看出bound就是每次扩容任务的bucket边界(bound-transferIndex)                bound = nextBound;                i = nextIndex - 1;//此处的i就是任务范围内最大的bucket的index                advance = false;            &#125;        &#125;//i&lt;0说明当前线程的所有任务都已经完成,后面两个判断没有找到原因......        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123;            int sc;            if (finishing) &#123;                nextTable = null;                table = nextTab;                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);                return;            &#125;            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)                    return;                //走到此处,上面的return没有执行说明当前线程是最后一个完成任务的线程,那么总的转移完成                finishing = advance = true;                i = n; // 进行最后的检查,此时oldTable的所有结点应该都是ForwardingNode,所以很快就能检查完                // ,如果有某个bucket没有处理,在这一步会进行处理            &#125;        &#125;//如果i处为null,把ForwardingNode插入到这里,意义在于:如果有其他线程往此处put,会发现这是一个ForwardingNode        //就会来主动帮助扩容        else if ((f = tabAt(tab, i)) == null)            advance = casTabAt(tab, i, null, fwd);        else if ((fh = f.hash) == MOVED)            advance = true; // MOVED表示该bucket是一个ForwardingNode(重新检查时应该在这个分支)        else &#123;//处理转移工作,对bucket加锁,防止其他线程对他put操作            synchronized (f) &#123;                if (tabAt(tab, i) == f) &#123;                    Node&lt;K,V&gt; ln, hn;                    if (fh &gt;= 0) &#123;//链表操作                        int runBit = fh &amp; n;                        Node&lt;K,V&gt; lastRun = f;                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;                            int b = p.hash &amp; n;                            if (b != runBit) &#123;                                runBit = b;                                lastRun = p;                            &#125;                        &#125;                        if (runBit == 0) &#123;                            ln = lastRun;                            hn = null;                        &#125;                        else &#123;                            hn = lastRun;                            ln = null;                        &#125;                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;                            int ph = p.hash; K pk = p.key; V pv = p.val;                            if ((ph &amp; n) == 0)                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);                            else                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);                        &#125;//分别将两个链表放到原index和原index+oldTable.length处(与HashMap一样)                        setTabAt(nextTab, i, ln);                        setTabAt(nextTab, i + n, hn);                        //把ForwardingNode放到原数组的i处(这个ForwardingNode中有nextTab)                        setTabAt(tab, i, fwd);                        advance = true;                    &#125;//如果是红黑树                    else if (f instanceof TreeBin) &#123;                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;                        TreeNode&lt;K,V&gt; lo = null, loTail = null;                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;                        int lc = 0, hc = 0;                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123;                            int h = e.hash;                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;                                (h, e.key, e.val, null, null);                            if ((h &amp; n) == 0) &#123;                                if ((p.prev = loTail) == null)                                    lo = p;                                else                                    loTail.next = p;                                loTail = p;                                ++lc;                            &#125;                            else &#123;                                if ((p.prev = hiTail) == null)                                    hi = p;                                else                                    hiTail.next = p;                                hiTail = p;                                ++hc;                            &#125;                        &#125;//结点数小于6的转回为链表                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;                        setTabAt(nextTab, i, ln);                        setTabAt(nextTab, i + n, hn);                        setTabAt(tab, i, fwd);                        advance = true;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\ntransfer的问题在扩容时并没有直接将sizeCtl设置为(-(线程数+1))而是使用了一个跟table容量有关的随机值作为基数,再加线程数,这是为了防止ABA问题,ConcurrentHashMap中多处调用transfer,下面以addCount为例。  \n12345678910111213141516171819202122232425262728293031323334353637private final void addCount(long x, int check) &#123;    CounterCell[] as; long b, s;    //与LongAdder类似的操作流程    if ((as = counterCells) != null ||        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123;        CounterCell a; long v; int m;        boolean uncontended = true;        if (as == null || (m = as.length - 1) &lt; 0 ||            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||            !(uncontended =              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;            fullAddCount(x, uncontended);            return;        &#125;        if (check &lt;= 1)            return;        s = sumCount();    &#125;    if (check &gt;= 0) &#123;        Node&lt;K,V&gt;[] tab, nt; int n, sc;        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;//A            int rs = resizeStamp(n);            if (sc &lt; 0) &#123;//B    这里的判断就是防止ABA问题                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||                    transferIndex &lt;= 0)                    break;                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))                    transfer(tab, nt);            &#125;            else if (U.compareAndSwapInt(this, SIZECTL, sc,                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))                transfer(tab, null);            s = sumCount();        &#125;    &#125;&#125;\n\n以下的分析基本照搬参考3…….  \n\n在标记A处,为sc,tab赋值,假设线程A在扩容-&gt;线程B执行到A处(sc=-2,tab指向扩容前长度为n的table),线程B休息-&gt;线程A已经完成扩容(table长度为2n)-&gt;不断put-&gt;线程C再次扩容(2n-4n)-&gt;线程B醒来;如果没有resizeStamp,sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT等等这些操作(因为现在假设sizeCtl直接设置为(-(线程数+1))),执行nt=nextTable操作,不为null(现在的nt已经是长度为4n的table了),接下来进行CAS修改sizeCtl操作(注意这里sc为-2,所以是不会CAS失败的,但其实早已完成了一轮扩容了,现在出现了ABA问题),调用transfer(tab,nt)(tab指向的还是长度为n的table,nt指向的已经是长度4n的nextTable了),在transfer方法内为线程B分配了任务,但其任务结点应该都是ForwardingNode(因为他的tab指向的是被废弃了的table),如果线程B是最后一个退出transfer方法的,他需要负责检查是否全部转移完,然而他的tab是错误的,所以他的检查认为所有任务都已经完成,最终结果就是分配给他的任务并没有完成,也就是说还有部分bucket没有从2n的table转移到4n的table中。  \nConcurrentHashMap使用resizeStamp方法以及很多移位比较操作来解决这种ABA问题,他通过之前所说的”与table长度相关的一个基数”来将sizeCtl与table.length绑定,而不是简单地记录线程数,这样在CAS操作sizeCtl时就避免了ABA问题,但是在transfer方法内仍然有一些判断是处理这种情况的,并不清楚还有哪些情况可能引发前面所说的ABA问题……\n参考老生常谈,HashMap的死循环Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析jdk1.8 LongAdder源码学习Java集合类框架学习 5.3—— ConcurrentHashMap(JDK1.8)","dateCreated":"2018-08-21T14:44:27+08:00","dateModified":"2019-03-09T11:42:05+08:00","datePublished":"2018-08-21T14:44:27+08:00","description":"Java多线程(六)源码:HashMap/LongAdder/ConcurrentHashMap","headline":"Java多线程(六)","image":["https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/weekly3/Java.png","https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2018/08/21/Java多线程6/"},"publisher":{"@type":"Organization","name":"一条咸鱼","sameAs":[],"image":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg","logo":{"@type":"ImageObject","url":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"}},"url":"http://yoursite.com/2018/08/21/Java多线程6/","thumbnailUrl":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/weekly3/Java.png"}</script>
    <meta name="description" content="Java多线程(六)源码:HashMap/LongAdder/ConcurrentHashMap">
<meta property="og:type" content="blog">
<meta property="og:title" content="Java多线程(六)">
<meta property="og:url" content="http://yoursite.com/2018/08/21/Java多线程6/index.html">
<meta property="og:site_name" content="一条咸鱼">
<meta property="og:description" content="Java多线程(六)源码:HashMap/LongAdder/ConcurrentHashMap">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/thread7/1.png">
<meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/thread7/2.png">
<meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/thread7/3.png">
<meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/thread7/4.png">
<meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/thread7/6.png">
<meta property="og:updated_time" content="2019-03-09T03:42:05.978Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java多线程(六)">
<meta name="twitter:description" content="Java多线程(六)源码:HashMap/LongAdder/ConcurrentHashMap">
<meta name="twitter:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/thread7/1.png">
<meta property="fb:app_id" content="[object Object]">
    
    
        
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"/>
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/weekly3/Java.png"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/weekly3/Java.png" />
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg" />
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-du2xmrqdqrl2ollgeiw050kpl6l4nbyz7bumjuurjgsxyopifvukebxc9lqe.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">一条咸鱼</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
                </a>
                <h4 class="sidebar-profile-name">一条咸鱼</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Java Developer</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="首页">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link open-algolia-search" href="/all-archives" title="归档">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/about" title="关于">
                    
                        <i class="sidebar-button-icon fa fa-user" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-center
                    post-header-cover--full" style="background-image:url('https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg');" data-behavior="4">
            
                <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            Java多线程(六)
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-08-21T14:44:27+08:00">
	
		    8月 21, 2018
    	
    </time>
    
</div>

    
</div>

            
        </div>

            <div id="main" data-behavior="4"
                 class="hasCover
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <!-- excerpt -->  <p></p>
<h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK7"><span class="toc-text">JDK7</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#put"><span class="toc-text">put()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addEntry"><span class="toc-text">addEntry()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#transfer-转移table"><span class="toc-text">transfer()/转移table</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap并发下的问题"><span class="toc-text">HashMap并发下的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8"><span class="toc-text">JDK8</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#putVal"><span class="toc-text">putVal()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resize"><span class="toc-text">resize()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LongAdder"><span class="toc-text">LongAdder</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Cell"><span class="toc-text">Cell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#base"><span class="toc-text">base</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#add"><span class="toc-text">add()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sum"><span class="toc-text">sum()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#内部类-属性"><span class="toc-text">内部类/属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ForwardingNode"><span class="toc-text">ForwardingNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeBin"><span class="toc-text">TreeBin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bucket"><span class="toc-text">bucket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CounterCell-baseCount"><span class="toc-text">CounterCell/baseCount</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sizeCtl"><span class="toc-text">sizeCtl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#transferIndex"><span class="toc-text">transferIndex</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#initTable"><span class="toc-text">initTable()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#put-1"><span class="toc-text">put()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#transfer"><span class="toc-text">transfer()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#transfer的问题"><span class="toc-text">transfer的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h2><h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)<span class="comment">//对于key为null的value,将其插入到table[0]。</span></span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">//如果key对应的Entry已经存在于table中,更新值</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="comment">//每当有Entry被overwrite,就会调用这个方法,HashMap的这个方法是空实现</span></span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新加入的key,modCount记录的是map被修改的次数</span></span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="addEntry"><a href="#addEntry" class="headerlink" title="addEntry()"></a>addEntry()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前容量大于扩容阈值,并且table[index]有元素,resize扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">//重新计算hash值和index</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实例化Entry并加入到map中</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="transfer-转移table"><a href="#transfer-转移table" class="headerlink" title="transfer()/转移table"></a>transfer()/转移table</h4><p>resize就是实例化一个两倍原容量的table,调用transfer转移Entry。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;<span class="comment">// e:   a-&gt;b-&gt;c</span></span><br><span class="line">        <span class="comment">//处理table[x]上的链表,处理完以后链表被反转(如果oldTable上的链表在newTable上还是被hash到一个index上的话)</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next; <span class="comment">// next = b , e = a</span></span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                <span class="comment">//重新计算hash值和index</span></span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i]; <span class="comment">// a.next = null</span></span><br><span class="line">            newTable[i] = e;     <span class="comment">// 插入e</span></span><br><span class="line">            e = next;     <span class="comment">// e = b</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>get()就是根据key找到Entry并返回value。  </p>
<h3 id="HashMap并发下的问题"><a href="#HashMap并发下的问题" class="headerlink" title="HashMap并发下的问题"></a>HashMap并发下的问题</h3><p>假设初始情况下,map内如图<br><img src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/thread7/1.png" alt><br>此时两个线程AB调用put,由于容量&gt;=扩容阈值,所以两个线程各自实例化一个newTable<br><img src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/thread7/2.png" alt><br>然后两个线程都会调用transfer(),线程B执行到Entry&lt;K,V&gt; next = e.next,e指向结点a,next指向结点b-&gt;线程A执行完transfer,假设abc经过rehash后仍然在同一个index,但是线程A没有将newTable赋值给table<br><img src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/thread7/3.png" alt><br>线程B开始工作,内部的引用关系如图<br><img src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/thread7/4.png" alt><br>当线程B执行完transfer后,引用关系如图<br><img src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/thread7/6.png" alt><br>如果最终线程A将newTable赋值给table,当get的时候就可能会出现死循环问题,如果线程B最终将newTable赋值给table,不但会出现死循环问题还会丢失数据C。  </p>
<p>上述死循环问题的原因所在就是对于链表的反序转移,JDK1.8解决了死循环问题,但是仍然会出现元素丢失问题。  </p>
<h2 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h2><h3 id="putVal"><a href="#putVal" class="headerlink" title="putVal()"></a>putVal()</h3><p>put()就是直接调用putVal()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//第一次put,初始化Node数组</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//计算要插入的结点的index,如果此处还未插入过结点,直接插入</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//需要将要插入的结点插入到链表或红黑树中</span></span><br><span class="line">        <span class="comment">//此时p指的是table[index]</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果p的key与要插入的key相等,用e备份p</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果p是树节点,调用putTreeVal插入一个新树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//p处是一个链表,从p向后遍历插入一个新结点或更新值</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//如果插入结点后,链表长度超过8,需要将链表转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//e!=null说明在index处的Node就是要插入的key对应的Node,更新值,返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;<span class="comment">//判断是否扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">//空实现</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//扩容</span></span><br><span class="line">        <span class="comment">//设置一些newTable的属性</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">//实例化HashMap时指定了容量,随后第一次调用put()</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">//实例化HashMap时未指定容量,第一次调用put()</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//扩容后的结点转移</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果是红黑树结点,将其分开成两棵树或链表</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">//对于链表,保证原先的顺序</span></span><br><span class="line">                    <span class="comment">//loHead/loTail表示的是在newTable中index与oldTable中的index相同的链表</span></span><br><span class="line">                    <span class="comment">//hiHead/hiTail表示的是newTable中index=oldTable中index+oldCap的链表</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//通过结点的hash与oldCap的按位与,可以直接计算出e的新的位置</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//此时已经将先前的链表转化为新的两个链表,链表直接插入newTable即可</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于新index的计算:<br>假设扩容前,size为8,元素A的hash为13,元素B的hash为5,他们在oldTable中的index都是5,可以看出,处于同一index的Node的hash要么相同,要么相差n*oldCap,同时可以发现如果元素hash&amp;oldCap&gt;1,那么说明元素hash本身大于oldCap,那么在扩容的时候该元素的新index就是原index+oldCap,通过这样的与运算判断,就可以不用重新计算hash值,提升了性能。  </p>
<p>JDK8中的扩容通过两个引用(head/tail)保证了链表的顺序,从而避免了JDK7中的死循环,但是当多线程调用put(),且恰好向同一个index中添加元素时还是可能出现数据丢失的情况(被覆盖了)。</p>
<h1 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h1><p>JDK8新增的类,为了改善AtomicLong在高并发情况下多线程CAS失败,自旋浪费CPU资源的情况。    </p>
<h2 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a>Cell</h2><p>父类Striped64的内部类,每一个Cell都可以看做一个AtomicLong,竞争激烈的情况下,操作LongAdder时,就是在操作具体的某一个Cell。  </p>
<h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><p>父类Striped64的一个属性,在进行加减操作时,先尝试CAS修改base,如果不成功,说明竞争激烈,那么再hash映射修改Cell。  </p>
<h2 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">    <span class="comment">//先尝试直接CAS操作base</span></span><br><span class="line">    <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//CAS操作cell.value</span></span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended = a.cas(v = a.value, v + x)))</span><br><span class="line">            <span class="comment">//调用父类的操作</span></span><br><span class="line">            longAccumulate(x, <span class="keyword">null</span>, uncontended);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键内容都在父类中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">        h = getProbe();</span><br><span class="line">        wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> collide = <span class="keyword">false</span>; <span class="comment">//线程hash到的cell不是null,该值就是true,同时也可以表示扩容意向</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;<span class="comment">//cells已被初始化</span></span><br><span class="line">            <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;<span class="comment">//当前线程hash到的cell为null</span></span><br><span class="line">                <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;</span><br><span class="line">                    Cell r = <span class="keyword">new</span> Cell(x);</span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;<span class="comment">//尝试CAS加锁</span></span><br><span class="line">                        <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                            Cell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                            <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;<span class="comment">//没有其他线程对这个位置的cell进行实例化</span></span><br><span class="line">                                rs[j] = r;</span><br><span class="line">                                created = <span class="keyword">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            cellsBusy = <span class="number">0</span>;<span class="comment">//相当于释放锁,volatile变量直接赋值无需CAS</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (created)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;   <span class="comment">//其他线程初始化了这个位置的cell</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)    <span class="comment">//传入false说明发生了线程竞争</span></span><br><span class="line">                wasUncontended = <span class="keyword">true</span>;   <span class="comment">// Continue after rehash</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                         fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="comment">//尝试CAS更新cell.value成功,直接返回</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)<span class="comment">//如果有其他线程扩容了cells</span></span><br><span class="line">                collide = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!collide)<span class="comment">//走到这里说明当前线程hash到的cell不为null,但是CAS操作失败了,说明竞争比较激烈</span></span><br><span class="line">                collide = <span class="keyword">true</span>;<span class="comment">//扩容意向置为true</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;<span class="comment">//CAS上锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;  <span class="comment">//cells扩容</span></span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                            rs[i] = as[i];</span><br><span class="line">                        cells = rs;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                collide = <span class="keyword">false</span>;  <span class="comment">//扩容意向设为false</span></span><br><span class="line">                <span class="keyword">continue</span>;         <span class="comment">//重新尝试</span></span><br><span class="line">            &#125;</span><br><span class="line">            h = advanceProbe(h);<span class="comment">//重新给当前线程生成一个hash值(以降低竞争程度)</span></span><br><span class="line">        &#125;<span class="comment">//这个else对应的是cells还未初始化,尝试CAS加锁以初始化cells</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                    Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</span><br><span class="line">                    rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);</span><br><span class="line">                    cells = rs;</span><br><span class="line">                    init = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                cellsBusy = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (init)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="comment">//有其他线程正在初始化cells,当前线程直接在base上进行累加操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                    fn.applyAsLong(v, x))))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="sum"><a href="#sum" class="headerlink" title="sum()"></a>sum()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cell[] as = cells; Cell a;</span><br><span class="line">    <span class="keyword">long</span> sum = base;</span><br><span class="line">    <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                sum += a.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//返回的和并不一定准确,LondAdder保证的是结果的最终正确性</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sum()不保证实时性。</p>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="内部类-属性"><a href="#内部类-属性" class="headerlink" title="内部类/属性"></a>内部类/属性</h2><h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h3><p>他是一个暂时类,他的hash固定为MOVED(-1),主要用作扩容时的一个标志位,其中有一个nextTable引用,如果读操作碰到某个bucket是ForwardingNode,就会调用他的find方法,随后ForwardingNode会在nextTable中寻找。  </p>
<h3 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h3><p>红黑树的代理操作类,可以看做是红黑树的根结点。  </p>
<h3 id="bucket"><a href="#bucket" class="headerlink" title="bucket"></a>bucket</h3><p>bucket指的是Map中的index(位置),由于ConcurrentHashMap的多数据结构,每个index处可能只是一个Node结点,也可能是一个链表,也可能是一颗红黑树,bucket算是一个统称。   </p>
<h3 id="CounterCell-baseCount"><a href="#CounterCell-baseCount" class="headerlink" title="CounterCell/baseCount"></a>CounterCell/baseCount</h3><p>ConcurrentLinkedQueue使用LongAdder的思想计数。等同于Cell和base,所以ConcurrentHashMap的总Node数等于baseCount+CounterCell。  </p>
<h3 id="sizeCtl"><a href="#sizeCtl" class="headerlink" title="sizeCtl"></a>sizeCtl</h3><p>各种操作的一个记录为,sizeCtl=-1说明正在初始化table;sizeCtl&gt;0表明下一次扩容的threshold;sizeCtl&lt;-1说明正在多线程扩容,其值=-(基数+扩容线程数),基数是每次扩容时均不同的一个值。  </p>
<h3 id="transferIndex"><a href="#transferIndex" class="headerlink" title="transferIndex"></a>transferIndex</h3><p>用于记录扩容的任务其实下标,ConcurrentHashMap的扩容是多线程的,他的思想是每个线程负责一部分bucket的转移(默认16个),transferIndex&lt;=0时说明没有扩容任务了,当要扩容时,他的值从table.length-1向0不断移动(由高向低执行扩容任务)。  </p>
<h2 id="initTable"><a href="#initTable" class="headerlink" title="initTable()"></a>initTable()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)<span class="comment">//说明当前正有其他线程在做初始化工作</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="comment">//CAS更新sizeCtl为-1表示自己在做初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;<span class="comment">//再一次的判断table是否被初始化,假设线程AB都在initTable方法内,A已经初始化完table,sizeCtl&gt;0</span></span><br><span class="line">                <span class="comment">//随后B进行第一个if判断(sc&gt;0),再else if CAS加锁,如果没有这一次的再判断,table将会被初始化两次</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="comment">//默认容量为16</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">//sc=0.75*n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);<span class="comment">//loadFactor已经无用了,统一使用0.75</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//更新sizeCtl</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="put-1"><a href="#put-1" class="headerlink" title="put()"></a>put()</h2><p>关键方法一样在putVal中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;<span class="comment">//记录对应的链表的长度</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();<span class="comment">//初始化table</span></span><br><span class="line">        <span class="comment">//如果bucket处没有Node,则将要插入的KV实例化为Node并CAS插入进table</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;<span class="comment">//表示该bucket的结点是ForwardingNode</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">//帮助扩容</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//对当前bucket上锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;<span class="comment">//&gt;=0说明是链表</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//遍历链表</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">//如果找到了相同的key,更新值</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;<span class="comment">//链表后插入新结点</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="comment">//红黑树中插入一个结点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;<span class="comment">//查看是否要将链表转化为红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//更新总结点数。</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="transfer"><a href="#transfer" class="headerlink" title="transfer()"></a>transfer()</h2><p>在HashMap的扩容时说过,扩容后bucket的index要么是oldIndex,要么是oldTable.length+oldIndex,所以可以看出,在扩容的时候各bucket之间是互不影响的,即newTable上的每个bucket只会有一个线程操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; <span class="comment">// 计算每个线程负责的任务数(需要转移的bucket个数)</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// 处理OOM或table过大</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;<span class="comment">//第一个转移的线程将该变量设置为数组的最后位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    <span class="comment">//ForwardingNode是一个"标志",在putVal中可以看到,遇到ForwardingNode会帮助扩容(下面也有体现)</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>; <span class="comment">//表明某bucket是否处理完</span></span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;<span class="comment">//这个while循环负责确定每个线程的任务范围</span></span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)<span class="comment">//这个地方--i,不断完成任务</span></span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//nextIndex&lt;=0说明所有的bucket转移工作都做完了(从后向前转移)</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="comment">//可以看出bound就是每次扩容任务的bucket边界(bound-transferIndex)</span></span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;<span class="comment">//此处的i就是任务范围内最大的bucket的index</span></span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//i&lt;0说明当前线程的所有任务都已经完成,后面两个判断没有找到原因......</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//走到此处,上面的return没有执行说明当前线程是最后一个完成任务的线程,那么总的转移完成</span></span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// 进行最后的检查,此时oldTable的所有结点应该都是ForwardingNode,所以很快就能检查完</span></span><br><span class="line">                <span class="comment">// ,如果有某个bucket没有处理,在这一步会进行处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//如果i处为null,把ForwardingNode插入到这里,意义在于:如果有其他线程往此处put,会发现这是一个ForwardingNode</span></span><br><span class="line">        <span class="comment">//就会来主动帮助扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// MOVED表示该bucket是一个ForwardingNode(重新检查时应该在这个分支)</span></span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//处理转移工作,对bucket加锁,防止其他线程对他put操作</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;<span class="comment">//链表操作</span></span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;<span class="comment">//分别将两个链表放到原index和原index+oldTable.length处(与HashMap一样)</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">//把ForwardingNode放到原数组的i处(这个ForwardingNode中有nextTab)</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="comment">//如果是红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                        TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    lo = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = p;</span><br><span class="line">                                loTail = p;</span><br><span class="line">                                ++lc;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                    hi = p;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = p;</span><br><span class="line">                                hiTail = p;</span><br><span class="line">                                ++hc;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="comment">//结点数小于6的转回为链表</span></span><br><span class="line">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                            (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                            (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="transfer的问题"><a href="#transfer的问题" class="headerlink" title="transfer的问题"></a>transfer的问题</h3><p>在扩容时并没有直接将sizeCtl设置为(-(线程数+1))而是使用了一个跟table容量有关的随机值作为基数,再加线程数,这是为了防止ABA问题,ConcurrentHashMap中多处调用transfer,下面以addCount为例。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">//与LongAdder类似的操作流程</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">        <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">            !(uncontended =</span><br><span class="line">              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">            fullAddCount(x, uncontended);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;<span class="comment">//A</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;<span class="comment">//B    这里的判断就是防止ABA问题</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以下的分析基本照搬参考3…….  </li>
</ul>
<p>在标记A处,为sc,tab赋值,假设线程A在扩容-&gt;线程B执行到A处(sc=-2,tab指向扩容前长度为n的table),线程B休息-&gt;线程A已经完成扩容(table长度为2n)-&gt;不断put-&gt;线程C再次扩容(2n-4n)-&gt;线程B醒来;如果没有resizeStamp,sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT等等这些操作(因为现在假设sizeCtl直接设置为(-(线程数+1))),执行nt=nextTable操作,不为null(现在的nt已经是长度为4n的table了),接下来进行CAS修改sizeCtl操作(注意这里sc为-2,所以是不会CAS失败的,但其实早已完成了一轮扩容了,现在出现了ABA问题),调用transfer(tab,nt)(tab指向的还是长度为n的table,nt指向的已经是长度4n的nextTable了),在transfer方法内为线程B分配了任务,但其任务结点应该都是ForwardingNode(因为他的tab指向的是被废弃了的table),如果线程B是最后一个退出transfer方法的,他需要负责检查是否全部转移完,然而他的tab是错误的,所以他的检查认为所有任务都已经完成,最终结果就是分配给他的任务并没有完成,也就是说还有部分bucket没有从2n的table转移到4n的table中。  </p>
<p>ConcurrentHashMap使用resizeStamp方法以及很多移位比较操作来解决这种ABA问题,他通过之前所说的”与table长度相关的一个基数”来将sizeCtl与table.length绑定,而不是简单地记录线程数,这样在CAS操作sizeCtl时就避免了ABA问题,但是在transfer方法内仍然有一些判断是处理这种情况的,并不清楚还有哪些情况可能引发前面所说的ABA问题……</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/1e9cf0ac07f4" target="_blank" rel="noopener">老生常谈,HashMap的死循环</a><br><a href="https://javadoop.com/post/hashmap" target="_blank" rel="noopener">Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</a><br><a href="https://blog.csdn.net/u011392897/article/details/60480108" target="_blank" rel="noopener">jdk1.8 LongAdder源码学习</a><br><a href="https://blog.csdn.net/u011392897/article/details/60479937" target="_blank" rel="noopener">Java集合类框架学习 5.3—— ConcurrentHashMap(JDK1.8)</a></p>
            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/21/Java多线程7/" data-tooltip="Java多线程(七)" aria-label="上一篇: Java多线程(七)">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/17/Java多线程5/" data-tooltip="Java多线程(五)" aria-label="下一篇: Java多线程(五)">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 一条咸鱼. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/21/Java多线程7/" data-tooltip="Java多线程(七)" aria-label="上一篇: Java多线程(七)">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/17/Java多线程5/" data-tooltip="Java多线程(五)" aria-label="下一篇: Java多线程(五)">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-times"></i>
    <ul class="share-options">
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
        
            <h4 id="about-card-name">一条咸鱼</h4>
        
            <div id="about-card-bio"><p>重庆</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>学生</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/sideCover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-vufjrm3fmbuttogo1hxuu0w9w0sesk5iyysjuguc2hdhufot9szxg8twijry.min.js"></script>
<!--SCRIPTS END-->

    



    </body>
</html>
