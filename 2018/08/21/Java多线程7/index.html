
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="一条咸鱼">
    <title>Java多线程(七) - 一条咸鱼</title>
    <meta name="author" content="一条咸鱼">
    
    
        <link rel="icon" href="http://yoursite.com/assets/images/favicon.ico">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"一条咸鱼","sameAs":[],"image":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"},"articleBody":"  \n\nLinkedBlockingQueue属性LinkedBlockingQueue使用两个ReentrantLock(putLock/takeLock),以及两个Condition(notFull=putLock.newCondition()/notEmpty=takeLock.newCondition())来协调多线程间的put/take操作。在实例化LinkedBlockingQueue时,内部实例化一个value为null的Node并赋值给head和last(表示最后一个结点)。  \nput()/阻塞式的插入12345678910111213141516171819202122232425public void put(E e) throws InterruptedException &#123;    if (e == null) throw new NullPointerException();    int c = -1;    Node&lt;E&gt; node = new Node&lt;E&gt;(e);    final ReentrantLock putLock = this.putLock;    final AtomicInteger count = this.count;    putLock.lockInterruptibly();    try &#123;        //如果已满,在非满的条件队列中阻塞        while (count.get() == capacity) &#123;            notFull.await();//while防止伪唤醒        &#125;//入队(更新last)        enqueue(node);        //增加count,c是增加前值        c = count.getAndIncrement();        //如果此时没满        if (c + 1 &lt; capacity)            //唤醒等待在非满条件队列上的线程            notFull.signal();    &#125; finally &#123;        putLock.unlock();    &#125;//c==0说明当前Node入队前是空的    if (c == 0)//调用notEmpty唤醒等待在非空队列中的线程        signalNotEmpty();&#125;\ntake()/阻塞式的获取123456789101112131415161718192021public E take() throws InterruptedException &#123;    E x;    int c = -1;    final AtomicInteger count = this.count;    final ReentrantLock takeLock = this.takeLock;    takeLock.lockInterruptibly();    try &#123;//队列为空,当前线程需要等待在非空条件队列中        while (count.get() == 0) &#123;            notEmpty.await();        &#125;//从队列中弹出一个Node.value(更新head结点)        x = dequeue();        c = count.getAndDecrement();        if (c &gt; 1)//如果之前的数量&gt;1,唤醒那些等待在非空条件队列中的结点            notEmpty.signal();    &#125; finally &#123;        takeLock.unlock();    &#125;    if (c == capacity)        signalNotFull();    return x;&#125;\noffer()/非阻塞式的插入12345678public boolean offer(E e) &#123;    if (e == null) throw new NullPointerException();    final AtomicInteger count = this.count;    if (count.get() == capacity)        return false;//已满直接返回   //其余操作基本相同于put()    //......&#125;\npoll()/非阻塞式的获取123456public E poll() &#123;    final AtomicInteger count = this.count;    if (count.get() == 0)        return null;    //......&#125;\n细节在put()/take()方法中,都使用了线程局部变量来进行具体的lock()/unlock()操作,这是因为局部变量调用要快于成员变量。  \ncascading notifies考虑一种情况:当前队列中元素数为0,两个消费者A,B  await在notEmpty条件队列上,此时一个生产者put了一个元素,put后发现之前队列为空,所以调用signalNotEmpty(这个方法需要获取takeLock)去唤醒一个消费者线程。被唤醒的消费者A将生产者刚刚put的元素出队后,count-1操作前,又来了一个生产者将元素放入并++count(此时count为2),消费者A继续执行,发现getAndDecrement返回为2,也就是说明在他被唤醒(说明队列里至少有一个元素了)到他take完一个元素后这段时间内又有其他的put操作(因为get返回&gt;1),此时他就会去继续调用notEmpty.signal去唤醒消费者B,如果有需要B同样会唤醒另一个消费者,这种唤醒就称之为cascading notifies(级联唤醒)。如果没有对于getAndDecrement返回值的判断,可能就会出现消费者B的饥饿,那么为了防止消费者饥饿,需要每次put后都调用signalNotEmpty,但这个方法需要获取takeLock,也就是说每当put的时候,生产者需要同时获取putLock和takeLock,这无疑降低了并发性能。    \nself-linkself-link指的就是结点的后继结点指向自身(h.next=h),这种代码在并发库中大量出现,凡是有这种代码的地方,注释大多都解释说”help GC”。假设程序运行了一段时间,Queue已经进入了Old Gen,新生成的元素仍然在Young Gen。假设元素A进入队列,随后BC进入队列(A-&gt;B-&gt;C引用链)后来元素A进入Old Gen,随后元素A出队(A在Old Gen),随后DE入队,BC出队列,此时BCDE都在Young Gen,但是仍然有一条A-&gt;B-&gt;C的引用链,因为A在old Gen,BC在Young Gen,Old Gen回收频率小于Young Gen,所以Old Gen中的A连带导致Young Gen中的BC都无法被回收,最简单的解决办法就是出队的时候设置A.next=null,但是LinkedBlockingQueue内置的弱一致性迭代器使得不能这么做。迭代器实例化1234567891011Itr() &#123;    //获取takeLock/putLock    fullyLock();    try &#123;//如果第一个结点不为null,获取第一个结点的value        current = head.next;        if (current != null)            currentElement = current.item;    &#125; finally &#123;        fullyUnlock();    &#125;&#125;\n遍历方法next()1234567891011121314public E next() &#123;    fullyLock();//获取全锁    try &#123;        if (current == null)            throw new NoSuchElementException();        E x = currentElement;        lastRet = current;        current = nextNode(current);//获取下一个结点        currentElement = (current == null) ? null : current.item;        return x;    &#125; finally &#123;        fullyUnlock();    &#125;&#125;\nhasNext()只要current不为null,就返回true。nextNode()12345678910private Node&lt;E&gt; nextNode(Node&lt;E&gt; p) &#123;    for (;;) &#123;        Node&lt;E&gt; s = p.next;        if (s == p)//一个元素的next指向自己,返回第一个元素            return head.next;        if (s == null || s.item != null)            return s;        p = s;    &#125;&#125;\n假设队列中有A-&gt;B-&gt;C三个元素。实例化迭代器(current=A)-&gt;AB出队列(A.next=A)-&gt;迭代器遍历,先输出A.element(弱一致性的体现,A已经出队,仍能输出)-&gt;调用next函数-&gt;nexeNode,由于s==p,所以返回head.next(也就是结点C),输出结点C,遍历结束。如果使用next==null,那么将无法找到仍然在队列中的C,如果仍要使用next==null且要能遍历到C需要在nextNode函数中s==null的时候返回head.next,但这样遍历将会出现死循环,因为最后一个结点的next就是null。  \nConcurrentLinkedQueue实例化new ConcurrentLinkedQueue()时会实例化一个item域为null的Node,并赋值给tail和head。\nhead和tail在注释中,Doug Lea解释了这两个变量123456789101112131415161718192021/** * 不变:   1.队列中所有未删除的结点都可以通过succ(head)找到   2.head一定不为null   3.(tmp = head).next != tmp || tmp != head一定为真,也就是head的next域不可能指向自己   可变:   1.head.item可能为null,也可能不为null   2.从head未必能找到tail */private transient volatile Node&lt;E&gt; head;/** * 不变:   1.队列中的最后一个结点,一定可以通过succ(tail)找到   2.tail一定不为null   可变:   1.tail.item可能为null也可能不为null   2.从head未必能找到tail   3.tail.next可能指向tail */private transient volatile Node&lt;E&gt; tail;\n补充说明1234567static volatile String tail = \"oldTail\";public static void main(String[] args) &#123;    String t = tail;    tail = \"newTail\";    boolean isEqual = t != (t=tail);    System.out.println(\"----\"+isEqual);&#125;\n对于这段代码,最终输出的isEqual为true,最开始自己想的是”t != (t=tail)”的执行顺序应该是将t指向”newTail”,然后”t!=t”一定是false,但是通过IDEA的反编译class12345678910111213141516static volatile String tail = \"oldTail\";public Test() &#123;&#125;public static void main(String[] args) &#123;    String t = tail;    tail = \"newTail\";    System.out.println(tail == t);    String var10000 = t;    t = tail;    boolean isEqual = var10000 != tail;    System.out.println(\"----\" + isEqual);    System.out.println(t);    System.out.println(tail);&#125;\n可以看到,在isEqual判断赋值前定义了一个var10000变量存储t,然后更新t,在真正的判断时比较的是var10000和tail是否相等(自然不相等,所以是true)。ConcurrentLinkedQueue在找寻真正尾结点时使用的就是这类代码。  \noffer()12345678910111213141516171819202122232425public boolean offer(E e) &#123;    checkNotNull(e);    final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);    for (Node&lt;E&gt; t = tail, p = t;;) &#123;        Node&lt;E&gt; q = p.next;        if (q == null) &#123; //已经遍历到最后一个结点            if (p.casNext(null, newNode)) &#123;//CAS插入next结点成功                if (p != t) //理想情况是当要插入的结点和当前tail结点相差一个结点时,再更新tail                    casTail(t, newNode);//CAS失败无所谓,通过多次循环+最后下面的两个else判断总是可以找到真正的尾结点                return true;            &#125;           //CAS竞争失败,继续循环重试        &#125;//这个判断表明当前结点已经出队(self-link),这个下面解释        else if (p == q)            //正如前面说到的,这里先比较oldt(表示老的t引用)和tail是否相等(可能有其他线程更新了tail)            //再将tail引用赋值给newt(新的t引用),如果oldt和tail不相等(判断条件为true),那么更新p为newt            //如果tail没有更新过,说明只是有其他线程将当前结点出队了,那么从head开始重新找            p = (t != (t = tail)) ? t : head;        else            //单线程环境下,判断肯定为false,更新p为q(相当于正常的向后遍历)            //&amp;&amp;后面的操作与上一个else if意义一样            //多线程offer环境下,向后遍历一次后,p!=t为true,判断tail是否发生了变化,并让其指向tail或者next            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;    &#125;&#125;\npoll()123456789101112131415161718192021222324public E poll() &#123;    restartFromHead:    for (;;) &#123;        for (Node&lt;E&gt; h = head, p = h, q;;) &#123;            E item = p.item;            //item==null的结点表示已删除结点            if (item != null &amp;&amp; p.casItem(item, null)) &#123;                //CAS操作成功                if (p != h) // 与offer类似,理想状态下隔一个结点才更新head                    //updateHead将原head结点的next指向自身                    updateHead(h, ((q = p.next) != null) ? q : p);                return item;            &#125;//走到这里说明当前队列没有结点了,尝试更新head然后返回null            else if ((q = p.next) == null) &#123;                updateHead(h, p);                return null;            &#125;//此处说明拿到了过期的head(其他线程调用了updateHead),一切从头开始            else if (p == q)                continue restartFromHead;            else//否则继续向后遍历(因为head的延迟更新,所以可能q才是真的头结点)                p = q;        &#125;    &#125;&#125;\noffer()解释对于offer()的p==q判断,考虑新加入一个结点后,队列如图所示随后多个线程执行了poll(确保更新了head),那么此时head指向结点1,而tail指向的是被updateHead更新过的结点,该结点的next域就指向自身,p==q判断处理的就是这种情况。  \nisEmpty()isEmpty()-&gt;first()1234567891011121314151617Node&lt;E&gt; first() &#123;    restartFromHead:    for (;;) &#123;        for (Node&lt;E&gt; h = head, p = h, q;;) &#123;            boolean hasItem = (p.item != null);            if (hasItem || (q = p.next) == null) &#123;                //如果有数据或者已经遍历到尾部了,尝试更新head并返回结点或null                updateHead(h, p);                return hasItem ? p : null;            &#125;//与poll类似            else if (p == q)                continue restartFromHead;            else                p = q;        &#125;    &#125;&#125;\n对于ConcurrentLinkedQueue的非空判断一定要使用isEmpty()而不要使用size()&gt;0,因为size的每次调用都会完整的遍历一次Queue。\n参考LinkedBlockingQueue之cascading notifies和self-link并发容器之ConcurrentLinkedQueue【Java并发编程】—–“J.U.C”：ConcurrentLinkedQueue","dateCreated":"2018-08-21T17:35:37+08:00","dateModified":"2019-07-23T21:53:51+08:00","datePublished":"2018-08-21T17:35:37+08:00","description":"Java多线程(七)源码:LinkedBlockingQueue/ConcurrentLinkedQueue","headline":"Java多线程(七)","image":["https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/weekly3/Java.png","https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2018/08/21/Java多线程7/"},"publisher":{"@type":"Organization","name":"一条咸鱼","sameAs":[],"image":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg","logo":{"@type":"ImageObject","url":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"}},"url":"http://yoursite.com/2018/08/21/Java多线程7/","thumbnailUrl":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/weekly3/Java.png"}</script>
    <meta name="description" content="Java多线程(七)源码:LinkedBlockingQueue/ConcurrentLinkedQueue">
<meta property="og:type" content="blog">
<meta property="og:title" content="Java多线程(七)">
<meta property="og:url" content="http://yoursite.com/2018/08/21/Java多线程7/index.html">
<meta property="og:site_name" content="一条咸鱼">
<meta property="og:description" content="Java多线程(七)源码:LinkedBlockingQueue/ConcurrentLinkedQueue">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/thread/1.png">
<meta property="og:updated_time" content="2019-07-23T13:53:51.912Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java多线程(七)">
<meta name="twitter:description" content="Java多线程(七)源码:LinkedBlockingQueue/ConcurrentLinkedQueue">
<meta name="twitter:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/thread/1.png">
<meta property="fb:app_id" content="[object Object]">
    
    
        
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"/>
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/weekly3/Java.png"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/weekly3/Java.png" />
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg" />
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-du2xmrqdqrl2ollgeiw050kpl6l4nbyz7bumjuurjgsxyopifvukebxc9lqe.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">一条咸鱼</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
                </a>
                <h4 class="sidebar-profile-name">一条咸鱼</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Java Developer</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="首页">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link open-algolia-search" href="/all-archives" title="归档">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/about" title="关于">
                    
                        <i class="sidebar-button-icon fa fa-user" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-center
                    post-header-cover--full" style="background-image:url('https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg');" data-behavior="4">
            
                <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            Java多线程(七)
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-08-21T17:35:37+08:00">
	
		    8月 21, 2018
    	
    </time>
    
</div>

    
</div>

            
        </div>

            <div id="main" data-behavior="4"
                 class="hasCover
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <!-- excerpt -->  <p></p>
<h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#LinkedBlockingQueue"><span class="toc-text">LinkedBlockingQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#属性"><span class="toc-text">属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#put-阻塞式的插入"><span class="toc-text">put()/阻塞式的插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#take-阻塞式的获取"><span class="toc-text">take()/阻塞式的获取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#offer-非阻塞式的插入"><span class="toc-text">offer()/非阻塞式的插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poll-非阻塞式的获取"><span class="toc-text">poll()/非阻塞式的获取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#细节"><span class="toc-text">细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cascading-notifies"><span class="toc-text">cascading notifies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#self-link"><span class="toc-text">self-link</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ConcurrentLinkedQueue"><span class="toc-text">ConcurrentLinkedQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#实例化"><span class="toc-text">实例化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#head和tail"><span class="toc-text">head和tail</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#补充说明"><span class="toc-text">补充说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#offer"><span class="toc-text">offer()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poll"><span class="toc-text">poll()</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#offer-解释"><span class="toc-text">offer()解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#isEmpty"><span class="toc-text">isEmpty()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol>
<h1 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h1><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>LinkedBlockingQueue使用两个ReentrantLock(putLock/takeLock),以及两个Condition(notFull=putLock.newCondition()/notEmpty=takeLock.newCondition())来协调多线程间的put/take操作。在实例化LinkedBlockingQueue时,内部实例化一个value为null的Node并赋值给head和last(表示最后一个结点)。  </p>
<h2 id="put-阻塞式的插入"><a href="#put-阻塞式的插入" class="headerlink" title="put()/阻塞式的插入"></a>put()/阻塞式的插入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果已满,在非满的条件队列中阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();<span class="comment">//while防止伪唤醒</span></span><br><span class="line">        &#125;<span class="comment">//入队(更新last)</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">//增加count,c是增加前值</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">//如果此时没满</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            <span class="comment">//唤醒等待在非满条件队列上的线程</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;<span class="comment">//c==0说明当前Node入队前是空的</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)<span class="comment">//调用notEmpty唤醒等待在非空队列中的线程</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="take-阻塞式的获取"><a href="#take-阻塞式的获取" class="headerlink" title="take()/阻塞式的获取"></a>take()/阻塞式的获取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">//队列为空,当前线程需要等待在非空条件队列中</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;<span class="comment">//从队列中弹出一个Node.value(更新head结点)</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)<span class="comment">//如果之前的数量&gt;1,唤醒那些等待在非空条件队列中的结点</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="offer-非阻塞式的插入"><a href="#offer-非阻塞式的插入" class="headerlink" title="offer()/非阻塞式的插入"></a>offer()/非阻塞式的插入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//已满直接返回</span></span><br><span class="line">   <span class="comment">//其余操作基本相同于put()</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="poll-非阻塞式的获取"><a href="#poll-非阻塞式的获取" class="headerlink" title="poll()/非阻塞式的获取"></a>poll()/非阻塞式的获取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>在put()/take()方法中,都使用了线程局部变量来进行具体的lock()/unlock()操作,这是因为局部变量调用要快于成员变量。  </p>
<h3 id="cascading-notifies"><a href="#cascading-notifies" class="headerlink" title="cascading notifies"></a>cascading notifies</h3><p>考虑一种情况:当前队列中元素数为0,两个消费者A,B  await在notEmpty条件队列上,此时一个生产者put了一个元素,put后发现之前队列为空,所以调用signalNotEmpty(这个方法需要获取takeLock)去唤醒一个消费者线程。<br>被唤醒的消费者A将生产者刚刚put的元素出队后,count-1操作前,又来了一个生产者将元素放入并++count(此时count为2),消费者A继续执行,发现getAndDecrement返回为2,也就是说明在他被唤醒(说明队列里至少有一个元素了)到他take完一个元素后这段时间内又有其他的put操作(因为get返回&gt;1),此时他就会去继续调用notEmpty.signal去唤醒消费者B,如果有需要B同样会唤醒另一个消费者,这种唤醒就称之为cascading notifies(级联唤醒)。如果没有对于getAndDecrement返回值的判断,可能就会出现消费者B的饥饿,那么为了防止消费者饥饿,需要每次put后都调用signalNotEmpty,但这个方法需要获取takeLock,也就是说每当put的时候,生产者需要同时获取putLock和takeLock,这无疑降低了并发性能。    </p>
<h3 id="self-link"><a href="#self-link" class="headerlink" title="self-link"></a>self-link</h3><p>self-link指的就是结点的后继结点指向自身(h.next=h),这种代码在并发库中大量出现,凡是有这种代码的地方,注释大多都解释说”help GC”。<br>假设程序运行了一段时间,Queue已经进入了Old Gen,新生成的元素仍然在Young Gen。假设元素A进入队列,随后BC进入队列(A-&gt;B-&gt;C引用链)后来元素A进入Old Gen,随后元素A出队(A在Old Gen),随后DE入队,BC出队列,此时BCDE都在Young Gen,但是仍然有一条A-&gt;B-&gt;C的引用链,因为A在old Gen,BC在Young Gen,Old Gen回收频率小于Young Gen,所以Old Gen中的A连带导致Young Gen中的BC都无法被回收,最简单的解决办法就是出队的时候设置A.next=null,但是LinkedBlockingQueue内置的弱一致性迭代器使得不能这么做。<br>迭代器实例化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Itr() &#123;</span><br><span class="line">    <span class="comment">//获取takeLock/putLock</span></span><br><span class="line">    fullyLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">//如果第一个结点不为null,获取第一个结点的value</span></span><br><span class="line">        current = head.next;</span><br><span class="line">        <span class="keyword">if</span> (current != <span class="keyword">null</span>)</span><br><span class="line">            currentElement = current.item;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>遍历方法next()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fullyLock();<span class="comment">//获取全锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        E x = currentElement;</span><br><span class="line">        lastRet = current;</span><br><span class="line">        current = nextNode(current);<span class="comment">//获取下一个结点</span></span><br><span class="line">        currentElement = (current == <span class="keyword">null</span>) ? <span class="keyword">null</span> : current.item;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>hasNext()只要current不为null,就返回true。<br>nextNode()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;E&gt; <span class="title">nextNode</span><span class="params">(Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node&lt;E&gt; s = p.next;</span><br><span class="line">        <span class="keyword">if</span> (s == p)<span class="comment">//一个元素的next指向自己,返回第一个元素</span></span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.item != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设队列中有A-&gt;B-&gt;C三个元素。实例化迭代器(current=A)-&gt;AB出队列(A.next=A)-&gt;迭代器遍历,先输出A.element(弱一致性的体现,A已经出队,仍能输出)-&gt;调用next函数-&gt;nexeNode,由于s==p,所以返回head.next(也就是结点C),输出结点C,遍历结束。<br>如果使用next==null,那么将无法找到仍然在队列中的C,如果仍要使用next==null且要能遍历到C需要在nextNode函数中s==null的时候返回head.next,但这样遍历将会出现死循环,因为最后一个结点的next就是null。  </p>
<h1 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h1><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><p>new ConcurrentLinkedQueue()时会实例化一个item域为null的Node,并赋值给tail和head。</p>
<h2 id="head和tail"><a href="#head和tail" class="headerlink" title="head和tail"></a>head和tail</h2><p>在注释中,Doug Lea解释了这两个变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不变:</span></span><br><span class="line"><span class="comment">   1.队列中所有未删除的结点都可以通过succ(head)找到</span></span><br><span class="line"><span class="comment">   2.head一定不为null</span></span><br><span class="line"><span class="comment">   3.(tmp = head).next != tmp || tmp != head一定为真,也就是head的next域不可能指向自己</span></span><br><span class="line"><span class="comment">   可变:</span></span><br><span class="line"><span class="comment">   1.head.item可能为null,也可能不为null</span></span><br><span class="line"><span class="comment">   2.从head未必能找到tail</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不变:</span></span><br><span class="line"><span class="comment">   1.队列中的最后一个结点,一定可以通过succ(tail)找到</span></span><br><span class="line"><span class="comment">   2.tail一定不为null</span></span><br><span class="line"><span class="comment">   可变:</span></span><br><span class="line"><span class="comment">   1.tail.item可能为null也可能不为null</span></span><br><span class="line"><span class="comment">   2.从head未必能找到tail</span></span><br><span class="line"><span class="comment">   3.tail.next可能指向tail</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br></pre></td></tr></table></figure></p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> String tail = <span class="string">"oldTail"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String t = tail;</span><br><span class="line">    tail = <span class="string">"newTail"</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isEqual = t != (t=tail);</span><br><span class="line">    System.out.println(<span class="string">"----"</span>+isEqual);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这段代码,最终输出的isEqual为true,最开始自己想的是”t != (t=tail)”的执行顺序应该是将t指向”newTail”,然后”t!=t”一定是false,但是通过IDEA的反编译class<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> String tail = <span class="string">"oldTail"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String t = tail;</span><br><span class="line">    tail = <span class="string">"newTail"</span>;</span><br><span class="line">    System.out.println(tail == t);</span><br><span class="line">    String var10000 = t;</span><br><span class="line">    t = tail;</span><br><span class="line">    <span class="keyword">boolean</span> isEqual = var10000 != tail;</span><br><span class="line">    System.out.println(<span class="string">"----"</span> + isEqual);</span><br><span class="line">    System.out.println(t);</span><br><span class="line">    System.out.println(tail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到,在isEqual判断赋值前定义了一个var10000变量存储t,然后更新t,在真正的判断时比较的是var10000和tail是否相等(自然不相等,所以是true)。ConcurrentLinkedQueue在找寻真正尾结点时使用的就是这类代码。  </p>
<h2 id="offer"><a href="#offer" class="headerlink" title="offer()"></a>offer()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123; <span class="comment">//已经遍历到最后一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;<span class="comment">//CAS插入next结点成功</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">//理想情况是当要插入的结点和当前tail结点相差一个结点时,再更新tail</span></span><br><span class="line">                    casTail(t, newNode);<span class="comment">//CAS失败无所谓,通过多次循环+最后下面的两个else判断总是可以找到真正的尾结点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//CAS竞争失败,继续循环重试</span></span><br><span class="line">        &#125;<span class="comment">//这个判断表明当前结点已经出队(self-link),这个下面解释</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">//正如前面说到的,这里先比较oldt(表示老的t引用)和tail是否相等(可能有其他线程更新了tail)</span></span><br><span class="line">            <span class="comment">//再将tail引用赋值给newt(新的t引用),如果oldt和tail不相等(判断条件为true),那么更新p为newt</span></span><br><span class="line">            <span class="comment">//如果tail没有更新过,说明只是有其他线程将当前结点出队了,那么从head开始重新找</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//单线程环境下,判断肯定为false,更新p为q(相当于正常的向后遍历)</span></span><br><span class="line">            <span class="comment">//&amp;&amp;后面的操作与上一个else if意义一样</span></span><br><span class="line">            <span class="comment">//多线程offer环境下,向后遍历一次后,p!=t为true,判断tail是否发生了变化,并让其指向tail或者next</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll()"></a>poll()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            E item = p.item;</span><br><span class="line">            <span class="comment">//item==null的结点表示已删除结点</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="comment">//CAS操作成功</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// 与offer类似,理想状态下隔一个结点才更新head</span></span><br><span class="line">                    <span class="comment">//updateHead将原head结点的next指向自身</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;<span class="comment">//走到这里说明当前队列没有结点了,尝试更新head然后返回null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="comment">//此处说明拿到了过期的head(其他线程调用了updateHead),一切从头开始</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//否则继续向后遍历(因为head的延迟更新,所以可能q才是真的头结点)</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="offer-解释"><a href="#offer-解释" class="headerlink" title="offer()解释"></a>offer()解释</h3><p>对于offer()的p==q判断,考虑新加入一个结点后,队列如图所示<br><img src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/thread/1.png" alt><br>随后多个线程执行了poll(确保更新了head),那么此时head指向结点1,而tail指向的是被updateHead更新过的结点,该结点的next域就指向自身,p==q判断处理的就是这种情况。  </p>
<h2 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a>isEmpty()</h2><p>isEmpty()-&gt;first()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> hasItem = (p.item != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (hasItem || (q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果有数据或者已经遍历到尾部了,尝试更新head并返回结点或null</span></span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> hasItem ? p : <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="comment">//与poll类似</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于ConcurrentLinkedQueue的非空判断一定要使用isEmpty()而不要使用size()&gt;0,因为size的每次调用都会完整的遍历一次Queue。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/02f5d25f3519" target="_blank" rel="noopener">LinkedBlockingQueue之cascading notifies和self-link</a><br><a href="https://juejin.im/post/5aeeae756fb9a07ab11112af" target="_blank" rel="noopener">并发容器之ConcurrentLinkedQueue</a><br><a href="https://www.jianshu.com/p/32d6526494fd" target="_blank" rel="noopener">【Java并发编程】—–“J.U.C”：ConcurrentLinkedQueue</a></p>
            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/22/Java多线程8/" data-tooltip="Java多线程(八)" aria-label="上一篇: Java多线程(八)">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/21/Java多线程6/" data-tooltip="Java多线程(六)" aria-label="下一篇: Java多线程(六)">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 一条咸鱼. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/22/Java多线程8/" data-tooltip="Java多线程(八)" aria-label="上一篇: Java多线程(八)">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/08/21/Java多线程6/" data-tooltip="Java多线程(六)" aria-label="下一篇: Java多线程(六)">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-times"></i>
    <ul class="share-options">
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
        
            <h4 id="about-card-name">一条咸鱼</h4>
        
            <div id="about-card-bio"><p>重庆</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>学生</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/sideCover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-vufjrm3fmbuttogo1hxuu0w9w0sesk5iyysjuguc2hdhufot9szxg8twijry.min.js"></script>
<!--SCRIPTS END-->

    



    </body>
</html>
