
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="一条咸鱼">
    <title>Netty基础源码 - 一条咸鱼</title>
    <meta name="author" content="一条咸鱼">
    
    
        <link rel="icon" href="http://yoursite.com/assets/images/favicon.ico">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"一条咸鱼","sameAs":[],"image":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"},"articleBody":"\n\nClient源码分析EchoClient12345678910111213141516171819202122232425262728293031public final class EchoClient &#123;    static final String HOST = System.getProperty(\"host\", \"127.0.0.1\");    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\"));    static final int SIZE = Integer.parseInt(System.getProperty(\"size\", \"256\"));    public static void main(String[] args) throws Exception &#123;        // Configure the client.        EventLoopGroup group = new NioEventLoopGroup();        try &#123;            Bootstrap b = new Bootstrap();            b.group(group)             .channel(NioSocketChannel.class)             .option(ChannelOption.TCP_NODELAY, true)             .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                 @Override                 public void initChannel(SocketChannel ch) throws Exception &#123;                     ChannelPipeline p = ch.pipeline();                     p.addLast(new EchoClientHandler());                 &#125;             &#125;);            // Start the client.            ChannelFuture f = b.connect(HOST, PORT).sync();            // Wait until the connection is closed.            f.channel().closeFuture().sync();        &#125; finally &#123;            // Shut down the event loop to terminate all threads.            group.shutdownGracefully();        &#125;    &#125;&#125;\nEchoClientHandler1234567891011121314151617181920212223242526272829303132333435363738public class EchoClientHandler extends ChannelInboundHandlerAdapter &#123;    private final ByteBuf firstMessage;    /**     * Creates a client-side handler.     */    public EchoClientHandler() &#123;        firstMessage = Unpooled.buffer(EchoClient.SIZE);        for (int i = 0; i &lt; firstMessage.capacity(); i ++) &#123;            firstMessage.writeByte((byte) i);        &#125;    &#125;    @Override    public void channelActive(ChannelHandlerContext ctx) &#123;        ctx.writeAndFlush(firstMessage);    &#125;    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;        ByteBuf in = (ByteBuf) msg;        System.out.println(in.toString());        ctx.write(msg);    &#125;    @Override    public void channelReadComplete(ChannelHandlerContext ctx) &#123;       ctx.flush();    &#125;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123;        // Close the connection when an exception is raised.        cause.printStackTrace();        ctx.close();    &#125;&#125;\nBootStrap#Connect该方法与Server的bind方法类似,最终走到BootStrap#doResolveAndConnect1234private ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) &#123;    final ChannelFuture regFuture = initAndRegister();    //......&#125;\n这里的initAndRegister与ServerBootStrap的调用一样(都是父类AbstractBootStrap中的方法),但这次创建的Channel是NioSocketChannel1234//可以看到,这里记录的interestSet是OP_READprotected AbstractNioByteChannel(Channel parent, SelectableChannel ch) &#123;    super(parent, ch, SelectionKey.OP_READ);&#125;\n其中调用的init方法是BootStrap的实现1234567891011void init(Channel channel) throws Exception &#123;    ChannelPipeline p = channel.pipeline();    //添加自己实现的EchoClientHandler    p.addLast(config.handler());    设置options    final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();    synchronized (options) &#123;        setChannelOptions(channel, options, logger);    &#125;    //......&#125;\n回想Server端的init方法中的addLast是添加了一个ChannelInitializer用于初始化客户端连接所对应的channel,Client端这里则直接将handler添加到pipeline上,这里填一下相关代码1234567891011//handler就是echoClientHandlernewCtx = newContext(group, filterName(name, handler), handler);addLast0(newCtx);if (!registered) &#123;    //修改newCtx的handlerState为ADD_PENDING    newCtx.setAddPending();    //封装newCtx为PendingHandlerAddedTask并赋值给pendingHandlerCallbackHead    //稍后会调用    callHandlerCallbackLater(newCtx, true);    return this;&#125;\n接下来的register方法链与Server端一致,都是使用eventLoop线程去执行register—&gt;register0,但是在register0中调用AbstractChannel#invokeHandlerAddedIfNeeded时调用我们刚刚说的pendingHandlerCallbackHead,最终调用initChannel方法将EchoClientHandler添加到Client端的pipeline上,同样的,该handler对应的context也被实例化,并通过addLast0加入到context链中。随后initAndRegister返回,由于Server端分析时已经分析过Listener的作用流程,所以这里假设eventLoop线程在主线程if判断时已经做完具体的register工作,即已经将channel注册到Selector上,但并没有设置事件。继续看doResolveAndConnect123456789101112private ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) &#123;    //直接看doResolveAndConnect0    if (regFuture.isDone()) &#123;        if (!regFuture.isSuccess()) &#123;            return regFuture;        &#125;        //newPromise就是以channel为参数实例化DefaultChannelPromise        return doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());    &#125; else &#123;        //......    &#125;&#125;\nBootStrap#doResolveAndConnect0这个方法等效于Server端的doBind012345678910111213private ChannelFuture doResolveAndConnect0(final Channel channel, SocketAddress remoteAddress,                  final SocketAddress localAddress, final ChannelPromise promise) &#123;    try &#123;        final EventLoop eventLoop = channel.eventLoop();        final AddressResolver&lt;SocketAddress&gt; resolver = this.resolver.getResolver(eventLoop);        if (!resolver.isSupported(remoteAddress) || resolver.isResolved(remoteAddress)) &#123;            // Resolver has no idea about what to do with the specified remote address or it's resolved already.            doConnect(remoteAddress, localAddress, promise);            return promise;        &#125;        //......&#125;\nthis.resolver是AddressResolverGroup实例,他其中保存了一个map(Map&lt;EventExecutor, AddressResolver&gt;)接下来看getResolver方法123456789101112131415161718192021222324252627282930public AddressResolver&lt;T&gt; getResolver(final EventExecutor executor) &#123;    AddressResolver&lt;T&gt; r;    synchronized (resolvers) &#123;        //第一次调用肯定返回null        r = resolvers.get(executor);        if (r == null) &#123;            final AddressResolver&lt;T&gt; newResolver;            try &#123;                //newResolver返回的是一个DefaultNameResolver实例                newResolver = newResolver(executor);            &#125; catch (Exception e) &#123;                throw new IllegalStateException(\"failed to create a new resolver\", e);            &#125;            resolvers.put(executor, newResolver);            //这个terminationFuture可能是对应于\"关闭客户端线程\"            executor.terminationFuture().addListener(new FutureListener&lt;Object&gt;() &#123;                @Override                public void operationComplete(Future&lt;Object&gt; future) throws Exception &#123;                    synchronized (resolvers) &#123;                        resolvers.remove(executor);                    &#125;                    newResolver.close();                &#125;            &#125;);            r = newResolver;        &#125;    &#125;    return r;&#125;\n该方法返回后,doResolveAndConnect0中的if判断为真,这个if判断用到了一个matcher来进行isSupported判断,内部使用isInstance判断,对于本例来说返回false,接下来看doConnect方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758  private static void doConnect(          final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise connectPromise) &#123;      final Channel channel = connectPromise.channel();      channel.eventLoop().execute(new Runnable() &#123;          @Override          public void run() &#123;              //本例的localAddress为null              if (localAddress == null) &#123;                  channel.connect(remoteAddress, connectPromise);              &#125; else &#123;                  channel.connect(remoteAddress, localAddress, connectPromise);              &#125;              //这个Listener用于在future失败时关闭channel              connectPromise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);          &#125;      &#125;);  &#125;  //channel.connect方法一顿调用最终走到AbstractNioUnsafe#connect  public final void connect(          final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) &#123;          //还没有进行真正的socket connect,isActive返回false          boolean wasActive = isActive();          if (doConnect(remoteAddress, localAddress)) &#123;              fulfillConnectPromise(promise, wasActive);          &#125; else &#123;              //.....          &#125;      &#125; catch (Throwable t) &#123;          //......      &#125;  &#125; //一路调用,走到NioSocketChannel#doConnect   protected boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception &#123;    if (localAddress != null) &#123;        doBind0(localAddress);    &#125;    boolean success = false;    try &#123;        //这里用的JDK底层的connect,这个方法对于非阻塞的channel,这个方法直接返回false        boolean connected = SocketUtils.connect(javaChannel(), remoteAddress);        if (!connected) &#123;            //向selectionKey注册CONNECT事件            selectionKey().interestOps(SelectionKey.OP_CONNECT);        &#125;        success = true;        return connected;    &#125; finally &#123;        if (!success) &#123;            doClose();        &#125;    &#125;&#125;\n至此channel已经完成了注册,并且在等到OP_CONNECT事件。在Server端分析时说过register方法是被包装为一个task并通过NioEventLoop的无限循环来处理该task,在NioEventLoop的循环中,不断调用了Selector.select方法,当连接完成时,我们需要调用processSelectedKeys()来处理这个事件12345678910111213141516171819202122232425262728293031323334353637private void processSelectedKeysOptimized() &#123;    for (int i = 0; i &lt; selectedKeys.size; ++i) &#123;        final SelectionKey k = selectedKeys.keys[i];        selectedKeys.keys[i] = null;        //这里的attachment返回的就是SocketChannel,因为我们在register时将channel参数作为了        //attachment        final Object a = k.attachment();        //if判断为true        if (a instanceof AbstractNioChannel) &#123;            processSelectedKey(k, (AbstractNioChannel) a);        &#125; else &#123;            //...        &#125;        //...    &#125;&#125;//NioEventLoop#processSelectedKey处理各种各样的事件,目前只分析CONNECT事件private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) &#123;    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();    //...    try &#123;        //返回OP_CONNECT        int readyOps = k.readyOps();        //if判断为true        if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) &#123;            //ops为0            int ops = k.interestOps();            ops &amp;= ~SelectionKey.OP_CONNECT;            k.interestOps(ops);            //重点方法            unsafe.finishConnect();        &#125;    //...    &#125; catch (CancelledKeyException ignored) &#123;        unsafe.close(unsafe.voidPromise());    &#125;&#125;\nunsafe.finishConnect()处理两件事:“Active事件的传播”,OP_READ的设置,其中重要的方法是fulfillConnectPromise12345678910111213141516171819202122232425262728293031323334353637383940  //AbstractNioUnsafe#fulfillConnectPromise    private void fulfillConnectPromise(ChannelPromise promise, boolean wasActive) &#123;     //...    if (!wasActive &amp;&amp; active) &#123;        pipeline().fireChannelActive();    &#125;    //...&#125;  //最终走到AbstractChannelHandlerContext#invokeChannelActive  //next现在指向的是HeadContext实例  static void invokeChannelActive(final AbstractChannelHandlerContext next) &#123;    EventExecutor executor = next.executor();    if (executor.inEventLoop()) &#123;        next.invokeChannelActive();    &#125; else &#123;        executor.execute(new Runnable() &#123;            @Override            public void run() &#123;                next.invokeChannelActive();            &#125;        &#125;);     &#125;  &#125;  //HeadContext的invokeChannelActive实现如下,ctx指向的是headContext    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;      ctx.fireChannelActive();      readIfIsAutoRead();  &#125;  //  public ChannelHandlerContext fireChannelActive() &#123;    //findContextInbound通过context的next引用和inbound属性循环找,找到第一个inboundContext    //本例来说,就是EchoClientHandler对应的Context,最终通过这个context找到我们的handler    //并调用channelActive方法,本例中该方法并没有继续调用fireChannelActive,所以active事件的传播到此为止    invokeChannelActive(findContextInbound());    return this;  &#125;\n这里打断一下,HeadContext#channelActive中还调用了readIfisAutoRead方法,这个方法主要做的就是设置selectionKey的interestOps(同Server端分析的一样),他最终将初始化时指定的OP_READ设置进去。在分析write之前,我们先回过来分析EchoClientHandler中关于ByteBuf相关的操作  \nBytebuf相关Bytebuf的分类\nheap/direct:堆上内存/堆外内存  \npooled/unpooled:是否基于对象池  \nunsafe/safe:get/set方法是否通过UNSAFE对象直接操作    \n\n这里以PooledUnsafeDirectByteBuf为例进行分析123ByteBuf byteBuf1 = PooledByteBufAllocator.DEFAULT.buffer(1024);//&lt;8192ByteBuf byteBuf2 = PooledByteBufAllocator.DEFAULT.buffer(1024*16);//&gt;8192&amp;&amp;&lt;16MBByteBuf byteBuf3 = PooledByteBufAllocator.DEFAULT.buffer(1024*1024*32);//&gt;16MB\nDEFAULT是PooledUnsafeDirectByteBuf的实例,实例化过程中会进行很多参数值的判断确认,这里全都使用默认值接下来的内存分配分析按照代码顺序分析  \nAllocator实例化12345678910111213141516171819202122232425262728293031323334353637383940414243444546public PooledByteBufAllocator(boolean preferDirect, int nHeapArena, int nDirectArena, int pageSize, int maxOrder,                              int tinyCacheSize, int smallCacheSize, int normalCacheSize,                              boolean useCacheForAllThreads, int directMemoryCacheAlignment) &#123;    super(preferDirect);//true    threadCache = new PoolThreadLocalCache(useCacheForAllThreads);//true    this.tinyCacheSize = tinyCacheSize;//512    this.smallCacheSize = smallCacheSize;//256    this.normalCacheSize = normalCacheSize;//64    //最终chunkSize计算值为16MB    chunkSize = validateAndCalculateChunkSize(pageSize, maxOrder);//8192,11    //最终pageShifts计算值为13    int pageShifts = validateAndCalculatePageShifts(pageSize);//8192    if (nHeapArena &gt; 0) &#123;//16        heapArenas = newArenaArray(nHeapArena);        List&lt;PoolArenaMetric&gt; metrics = new ArrayList&lt;PoolArenaMetric&gt;(heapArenas.length);        for (int i = 0; i &lt; heapArenas.length; i ++) &#123;            PoolArena.HeapArena arena = new PoolArena.HeapArena(this,                    pageSize, maxOrder, pageShifts, chunkSize,                    directMemoryCacheAlignment);            heapArenas[i] = arena;            metrics.add(arena);        &#125;        heapArenaMetrics = Collections.unmodifiableList(metrics);    &#125; else &#123;        heapArenas = null;        heapArenaMetrics = Collections.emptyList();    &#125;//至此,实例化了16个heapArena,每个heapArena中有一个长度为32的PoolSubpage数组(tiny)和    //长度为4的PoolSubpage数组(small),以及六个chunkList    if (nDirectArena &gt; 0) &#123;//16        directArenas = newArenaArray(nDirectArena);        List&lt;PoolArenaMetric&gt; metrics = new ArrayList&lt;PoolArenaMetric&gt;(directArenas.length);        for (int i = 0; i &lt; directArenas.length; i ++) &#123;            PoolArena.DirectArena arena = new PoolArena.DirectArena(                    this, pageSize, maxOrder, pageShifts, chunkSize, directMemoryCacheAlignment);            directArenas[i] = arena;            metrics.add(arena);        &#125;        directArenaMetrics = Collections.unmodifiableList(metrics);    &#125; else &#123;        directArenas = null;        directArenaMetrics = Collections.emptyList();    &#125;//至此又实例化了16个directArena,其中成员变量实例化过程与heapArena完全一样    metric = new PooledByteBufAllocatorMetric(this);&#125;\nPoolArena实例化directArena和heapArena的实例化方法都是调用父类的实例化方法,PoolArena123456789101112131415161718192021222324252627282930313233343536373839404142protected PoolArena(PooledByteBufAllocator parent, int pageSize,      int maxOrder, int pageShifts, int chunkSize, int cacheAlignment) &#123;    //...数据记录    //创建长度为32的PoolSubpage数组(数组成员全null)    tinySubpagePools = newSubpagePoolArray(numTinySubpagePools);//32    for (int i = 0; i &lt; tinySubpagePools.length; i ++) &#123;        //数组中每个元素都是PoolSubpage实例,pageSize为8192        tinySubpagePools[i] = newSubpagePoolHead(pageSize);    &#125;    numSmallSubpagePools = pageShifts - 9;//4    //数组长度为4,其余与上面类似    smallSubpagePools = newSubpagePoolArray(numSmallSubpagePools);    for (int i = 0; i &lt; smallSubpagePools.length; i ++) &#123;        smallSubpagePools[i] = newSubpagePoolHead(pageSize);    &#125;    //这里实例化六个ChunkList负责管理Arena中的chunk,每个list中的chunk的使用率有要求    //0-25/25-50/50-75/75-100,每个chunk大小16MB,使用率就是根据chunk使用大小和16MB的比值计算    q100 = new PoolChunkList&lt;T&gt;(this, null, 100, Integer.MAX_VALUE, chunkSize);//maxCapacity为0    q075 = new PoolChunkList&lt;T&gt;(this, q100, 75, 100, chunkSize);//maxCapacity为4MB    q050 = new PoolChunkList&lt;T&gt;(this, q075, 50, 100, chunkSize);//maxCapacity为8MB    q025 = new PoolChunkList&lt;T&gt;(this, q050, 25, 75, chunkSize);//maxCapacity为12MB    q000 = new PoolChunkList&lt;T&gt;(this, q025, 1, 50, chunkSize);//maxCapacity约等于16MB    qInit = new PoolChunkList&lt;T&gt;(this, q000, Integer.MIN_VALUE, 25, chunkSize);//maxCapacity约等于16MB    //将六个list组成双向列表    q100.prevList(q075);    q075.prevList(q050);    q050.prevList(q025);    q025.prevList(q000);    q000.prevList(null);    qInit.prevList(qInit);    //管理这六个list    List&lt;PoolChunkListMetric&gt; metrics = new ArrayList&lt;PoolChunkListMetric&gt;(6);    metrics.add(qInit);    metrics.add(q000);    metrics.add(q025);    metrics.add(q050);    metrics.add(q075);    metrics.add(q100);    chunkListMetrics = Collections.unmodifiableList(metrics);&#125;\n至此,PooledBytebufAllocator和DirectArena&amp;HeaoArena(各16个)已经实例化完毕,接下来调用buffer(1024)分配指定大小内存。  \n1024内存分配#1buffer方法判断当前是否支持堆外内存分配(默认情况下支持),最终调用PooledBytebufAllocator#newDirectBuffer,这个方法比较长,分段看1234protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) &#123;    PoolThreadCache cache = threadCache.get();    //...&#125;\nthreadCache是内存分配器的成员变量1final class PoolThreadLocalCache extends FastThreadLocal&lt;PoolThreadCache&gt;&#123;&#125;\n实例化PoolThreadCache当前线程第一次调用get,得到的值肯定为null,上一篇对于FastThreadLocal的分析可知,会调用initValue方法进行值的初始化12345678910111213141516protected synchronized PoolThreadCache initialValue() &#123;    //为当前线程寻找使用最少的Arena(线程和Arena是绑定的)    final PoolArena&lt;byte[]&gt; heapArena = leastUsedArena(heapArenas);    final PoolArena&lt;ByteBuffer&gt; directArena = leastUsedArena(directArenas);    Thread current = Thread.currentThread();    if (useCacheForAllThreads || current instanceof FastThreadLocalThread) &#123;        //当前threadLocal的get返回的就是这个PoolThreadCache        return new PoolThreadCache(    //512          256              64                heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,                //32K                                   8K                DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);    &#125;    // No caching so just use 0 as sizes.    return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0);&#125;\n为当前线程找好Arena后,要实例化属于当前线程的PooLThreadCache123456789101112131415161718192021222324PoolThreadCache(PoolArena&lt;byte[]&gt; heapArena, PoolArena&lt;ByteBuffer&gt; directArena,                int tinyCacheSize, int smallCacheSize, int normalCacheSize,                int maxCachedBufferCapacity, int freeSweepAllocationThreshold) &#123;    this.freeSweepAllocationThreshold = freeSweepAllocationThreshold;    this.heapArena = heapArena;    this.directArena = directArena;    if (directArena != null) &#123;        tinySubPageDirectCaches = createSubPageCaches(                tinyCacheSize, PoolArena.numTinySubpagePools, SizeClass.Tiny);        smallSubPageDirectCaches = createSubPageCaches(                smallCacheSize, directArena.numSmallSubpagePools, SizeClass.Small);        numShiftsNormalDirect = log2(directArena.pageSize);        normalDirectCaches = createNormalCaches(                normalCacheSize, maxCachedBufferCapacity, directArena);        //至此PoolThreadCache中tinySubPageDirectCaches被实例化为长度为32的SubPageMemoryRegionCache数组,        //每个SubPageMemoryRegionCache包含一个长度为cacheSize(512)的Queue(Object[512])        //smallSubPageDirectCaches被实例化为长度为4的SubPageMemoryRegionCache数组,SubPageMemoryRegionCache        //中包含的Queue长度为256,normalDirectCaches是长度为3的NormalMemoryRegionCache,其中Queue长度为64        //更新Arena的相关线程数        directArena.numThreadCaches.getAndIncrement();    &#125;     //heapArena的操作跟directArena完全一样  &#125;\n此时,get方法返回该cache  \n1024内存分配#2123456789protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) &#123;    PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;    final ByteBuf buf;    if (directArena != null) &#123;        buf = directArena.allocate(cache, initialCapacity, maxCapacity);    &#125; else &#123;      //...    &#125;&#125;\ndirectArena方法是父类方法,其中又将allocate分为两步1234567891011121314151617181920212223242526272829303132333435363738394041424344PooledByteBuf&lt;T&gt; allocate(PoolThreadCache cache, int reqCapacity, int maxCapacity) &#123;    PooledByteBuf&lt;T&gt; buf = newByteBuf(maxCapacity);    allocate(cache, buf, reqCapacity);    return buf;&#125;//newByteBuf方法比较简单  static PooledUnsafeDirectByteBuf newInstance(int maxCapacity) &#123;    //RECYCLER内部有个threadLocal这个get会为当前线程创建一个Stack和DefaultHandle    //并设置handle.value为PooledUnsafeDirectByteBuf实例并返回该实例    PooledUnsafeDirectByteBuf buf = RECYCLER.get();    //设置buf的readerIndex/writerIndex/maxCapacity/引用计数+1    buf.reuse(maxCapacity);    return buf;&#125;//allocate方法  private void allocate(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, final int reqCapacity) &#123;    //这个方法相当于将reqCapacity标准化,本例1024就是标准数    final int normCapacity = normalizeCapacity(reqCapacity);    if (isTinyOrSmall(normCapacity)) &#123; // capacity &lt; pageSize(8192),本例capacity为1024,if为真        int tableIdx;        PoolSubpage&lt;T&gt;[] table;        boolean tiny = isTiny(normCapacity);//1024&lt;512,tiny=false        if(tiny)&#123;//......        &#125;else &#123;            //当前情况下,线程第一次获取Buffer,这个方法返回false            if (cache.allocateSmall(this, buf, reqCapacity, normCapacity)) &#123;                return;            &#125;            tableIdx = smallIdx(normCapacity);            table = smallSubpagePools;        &#125;        final PoolSubpage&lt;T&gt; head = table[tableIdx];        //这里有一段代码但当前情况下并不会有结果...        synchronized (this) &#123;            allocateNormal(buf, reqCapacity, normCapacity);        &#125;        //...    &#125;    //分配其他大小的内存,先不分析&#125;\n经过层层判断,最终会调用allocateNormal进行真正的堆外内存分配,这一步内存的分配是在PoolArena中进行,前面说过默认情况下每个线程都会关联两个Arena(heap/direct),而一个Arana也可能关联多个线程,所以这个方法必须在synchronized(this)块中被调用123456789101112131415private void allocateNormal(PooledByteBuf&lt;T&gt; buf, int reqCapacity, int normCapacity) &#123;    //这些chunkList都没有chunk实例,所以allocate全部返回false    if (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||        q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||        q075.allocate(buf, reqCapacity, normCapacity)) &#123;        return;    &#125;//实例化pageSize为8192,chunkSize为16MB的chunk(另外两个参数暂不清楚作用)    PoolChunk&lt;T&gt; c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);    long handle = c.allocate(normCapacity);    assert handle &gt; 0;    //initBuf中主要做的就是在PooledUnsafeDirectBytebuf中记录当前buffer的内存地址    c.initBuf(buf, handle, reqCapacity);    //将新创建的chunk添加到qInit中,add方法内部会判断chunk的使用率以将其添加到正确的chunkList中    qInit.add(c);&#125;\nPoolChunk实例化newChunk会先调用UNSAFE的native方法用malloc分配16MB的堆外内存,并将该ByteBuffer作为参数传给chunk的构造方法12345678910111213141516171819202122232425262728293031323334PoolChunk(PoolArena&lt;T&gt; arena, T memory, int pageSize, int maxOrder, int pageShifts, int chunkSize, int offset) &#123;    //T就是ByteBuffer类型    unpooled = false;    this.arena = arena;    this.memory = memory;//这就是UNSAFE分配的堆外内存的ByteBuffer实例    this.pageSize = pageSize;    this.pageShifts = pageShifts;    this.maxOrder = maxOrder;    this.chunkSize = chunkSize;    this.offset = offset;    unusable = (byte) (maxOrder + 1);//12    log2ChunkSize = log2(chunkSize);//24    subpageOverflowMask = ~(pageSize - 1);//-8192    //记录当前chunk中可用大小    freeBytes = chunkSize;    assert maxOrder &lt; 30 : \"maxOrder should be &lt; 30, but is: \" + maxOrder;    maxSubpageAllocs = 1 &lt;&lt; maxOrder;//2048    //4K大小的memoryMap/depthMap    memoryMap = new byte[maxSubpageAllocs &lt;&lt; 1];    depthMap = new byte[memoryMap.length];    int memoryMapIndex = 1;    //初始化memoryMap/depthMap    for (int d = 0; d &lt;= maxOrder; ++ d) &#123; // move down the tree one level at a time        int depth = 1 &lt;&lt; d;        for (int p = 0; p &lt; depth; ++ p) &#123;            // in each level traverse left to right and set value to the depth of subtree            memoryMap[memoryMapIndex] = (byte) d;            depthMap[memoryMapIndex] = (byte) d;            memoryMapIndex ++;        &#125;    &#125;    //创建长度为2048的PoolSubpage数组,意味着每一个chunk被分为2048个page,一个page8K    subpages = newSubpageArray(maxSubpageAllocs);&#125;\nPoolChunk的Page管理在上面的chunk实例化过程中可以看到,chunk被分为2048个大小为8K的page,同时初始化了两个map(其实是byte数组),chunk通过这两个数组来管理2048个page的分配2048个page当做叶子结点组成完全二叉树共需要4K个结点底层的共2048(下标分别为2048-4095)个结点表示chunk分配的最小粒度page,对应到memoryMap中,index下标表示树中结点索引值,memoryMap[index]值表示树结点所在层级,如memoryMap[2048]=11表示第2048个结点在树的第11层。如果分配内存小于pageSize,则直接在第11层找结点即可,如果大于pageSize,小于2*pageSize,则在第10层寻找结点,以此类推。同时memoryMap[index]的值还表明了当前结点子结点的分配情况,如1024结点本应该在10层,即memoryMap[1024]=10,但当其子结点(2048或2049)被分配出去以后,会触发map的更新操作,导致2048结点本身以及其父结点,祖父节点,曾祖父结点(好像没这个说法)直到追溯到根节点……依次加1,那么memory[1024]=11,memory[512]=10…….这样从memoryMap[index]实际值和初始值对比就能知道结点分配情况:如果实际值与理论初始值相等,说明两个子结点都没有被分配,如果等于初始值+1说明有一个子结点已被分配,如果等于12(chunk中以unusable记录)则表明当前结点下的所有子结点都被分配。\n1024内存分配#3接下来的1long handle = c.allocate(normCapacity);\n最终调用PoolChunk#allocateSubpage123456789101112131415161718192021222324252627private long allocateSubpage(int normCapacity) &#123;    //从Arena中的smallSubpagePools拿到一个PoolSubpage    PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity);    synchronized (head) &#123;        int d = maxOrder;//maxOrder记录的是chunk中的Page树最大层级,即11        int id = allocateNode(d);//因为是分配小于8K的内存,所以直接从第11层分配即可        if (id &lt; 0) &#123;            return id;        &#125;        final PoolSubpage&lt;T&gt;[] subpages = this.subpages;        final int pageSize = this.pageSize;        //分出去一个page,更新空闲内存值        freeBytes -= pageSize;        int subpageIdx = subpageIdx(id);        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx];        if (subpage == null) &#123;//subpages未进行实例化,subpage为null,            //PoolSubpage构造方法中会将this与参数中的head通过next,prev引用连接起来            subpage = new PoolSubpage&lt;T&gt;(head, this, id, runOffset(id), pageSize, normCapacity);            subpages[subpageIdx] = subpage;        &#125; else &#123;            subpage.init(head, normCapacity);        &#125;        return subpage.allocate();    &#125;&#125;\nallocateNode寻找结点和值更新1234567891011121314151617181920212223242526272829303132333435363738394041private int allocateNode(int d) &#123;    int id = 1;    int initial = - (1 &lt;&lt; d); // has last d bits = 0 and rest all = 1    //返回memoryMap[id]    byte val = value(id);    if (val &gt; d) &#123; // unusable        return -1;    &#125;    while (val &lt; d || (id &amp; initial) == 0) &#123;        id &lt;&lt;= 1;        val = value(id);        if (val &gt; d) &#123;            //这个求兄弟树ID的方法可以学一下！！！！！！！！！！            id ^= 1;            val = value(id);        &#125;    &#125;    //将memoryMap[id]设置为unusable(12)表示当前结点已经分配出去了    setValue(id, unusable);    //更新父结点的值    updateParentsAlloc(id);    return id;&#125;//父结点更新过程private void updateParentsAlloc(int id) &#123;    while (id &gt; 1) &#123;        //除2得父结点的index        int parentId = id &gt;&gt;&gt; 1;        //val1和val2是parent结点的两个子结点        byte val1 = value(id);        byte val2 = value(id ^ 1);        //可以看到父结点值是两子结点的小值,假设2048结点被分配出去了(设置为12)父结点一路更新+1        //随后2049页也被分出去了,1024结点会被设为12,但由于是取小值所有512结点仍然是10        //说明结点仅仅一棵子树全部分配当前结点仍然不会是12        byte val = val1 &lt; val2 ? val1 : val2;        setValue(parentId, val);        id = parentId;    &#125;&#125;\nPoolSubpage的实例化12345678PoolSubpage(PoolSubpage&lt;T&gt; head, PoolChunk&lt;T&gt; chunk, int memoryMapIdx, int runOffset, int pageSize, int elemSize) &#123;    this.chunk = chunk;    this.memoryMapIdx = memoryMapIdx;    this.runOffset = runOffset;//记录的是当前page在其所属chunk的ByteBuffer中的偏移量    this.pageSize = pageSize;    bitmap = new long[pageSize &gt;&gt;&gt; 10]; //该bitmap用来进一步划分page    init(head, elemSize);&#125;\nbitmap是长度为8的long数组,因为内存分配的最小单位是16,一个page8192,最多分为512份,一个long长64所以8个long刚好表示。1234567891011121314151617181920void init(PoolSubpage&lt;T&gt; head, int elemSize) &#123;    doNotDestroy = true;    this.elemSize = elemSize;    if (elemSize != 0) &#123;        //当前page被分为8段(8192/1024)        maxNumElems = numAvail = pageSize / elemSize;        //下一个可用的段是0号段        nextAvail = 0;        //bitmapLength记录需要几个long才能描述该page,本例需要1个即可        bitmapLength = maxNumElems &gt;&gt;&gt; 6;        if ((maxNumElems &amp; 63) != 0) &#123;            bitmapLength ++;        &#125;        for (int i = 0; i &lt; bitmapLength; i ++) &#123;            bitmap[i] = 0;        &#125;    &#125;//将当前page添加到PooArena的smallSubpagePools中    addToPool(head);&#125;\n最终1024大小内存分配完毕,返回buffer。    \n16K内存分配与1024分配不同在于PoolArane#allocate1234567891011121314151617private void allocate(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, final int reqCapacity) &#123;    //normCapacity=reqCapacity=1024*    final int normCapacity = normalizeCapacity(reqCapacity);    if (normCapacity &lt;= chunkSize) &#123;        if (cache.allocateNormal(this, buf, reqCapacity, normCapacity)) &#123;            // was able to allocate out of the cache so move on            return;        &#125;        synchronized (this) &#123;            allocateNormal(buf, reqCapacity, normCapacity);            ++allocationsNormal;        &#125;    &#125; else &#123;        // Huge allocations are never served via the cache so just call allocateHuge        allocateHuge(buf, reqCapacity);    &#125;&#125;\n在allocateNormal中首先通过chunkList进行内存分配,由于我们之前在1024分配时,实例化了qInit中的head(chunk实例),所以代码走到PoolChunkList(qInit)#allocate12345678910111213141516for (PoolChunk&lt;T&gt; cur = head;;) &#123;    long handle = cur.allocate(normCapacity);    if (handle &lt; 0) &#123;        cur = cur.next;        if (cur == null) &#123;            return false;        &#125;    &#125; else &#123;        cur.initBuf(buf, handle, reqCapacity);        if (cur.usage() &gt;= maxUsage) &#123;            remove(cur);            nextList.add(cur);        &#125;        return true;    &#125;&#125;\n在chunk中从第10层开始找结点以进行分配,最终分配1025号结点(由于之前分配了1024的内存,所以1024号结点的值已经为11)找到结点后,调用PoolChunk#initBuf-&gt;buf.init记录内存地址最终返回这块Bytebuf,内存分配完毕。  \n32MB内存分配之前的分析已经有看到,对于大块内存的分配,在PoolArena#allocate中会调用allocateHuge123456private void allocateHuge(PooledByteBuf&lt;T&gt; buf, int reqCapacity) &#123;    PoolChunk&lt;T&gt; chunk = newUnpooledChunk(reqCapacity);    activeBytesHuge.add(chunk.chunkSize());    buf.initUnpooled(chunk, reqCapacity);    allocationsHuge.increment();&#125;\n超大内存的分配比较简单,因为netty对于这种内存并不使用Pool进行池化,只是按照指定大小创建chunk并在Arena.activeBytesHuge中记录这个chunk的大小,随后调用init方法进行记录内存地址等初始化操作。\nRecyclerRecycler是netty实现的一个对象池,概念上和linux内存管理中的SLAB有点像,也是为指定类型创建对象池,在前面的分析中有提到他(PooledUnsafeDirectByteBuf中的RECYCLER变量)。123456private static final Recycler&lt;PooledUnsafeDirectByteBuf&gt; RECYCLER = new Recycler&lt;PooledUnsafeDirectByteBuf&gt;() &#123;    @Override    protected PooledUnsafeDirectByteBuf newObject(Handle&lt;PooledUnsafeDirectByteBuf&gt; handle) &#123;        return new PooledUnsafeDirectByteBuf(handle, 0);    &#125;&#125;;\nDefaultHandle: Netty中的对象包装类,其成员变量value是真正被缓存的对象Stack: Netty自己实现的栈,与线程通过FastThreadLocal绑定,其中有一个DefaultHandle数组用于存储本线程回收的对象WeakOrderQueue: Netty中通过Recycler获取对象时的线程(假设为A)可能与回收(Handle#recycle)对象时的线程(假设为B)不是一个线程,对于这种情况会将Handle回收到WeakOrderQueue中Link: WeakOrderQueue的内部类,其中包含一个DefaultHandle数组,真正存放上面说到的“get线程和recycle线程不同”的handle  \nDefaultHandle#recycle先从回收方法看起,这里仍然假设A线程获取对象,B线程回收对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public void recycle(Object object) &#123;    //...    stack.push(this);&#125;//Stack#push  void push(DefaultHandle&lt;?&gt; item) &#123;    Thread currentThread = Thread.currentThread();    if (threadRef.get() == currentThread) &#123;        pushNow(item);    &#125; else &#123;        pushLater(item, currentThread);    &#125;&#125;//pushNow很简单,进行一些stack中DefaultHandle数组size的判断(拒绝?扩容?直接存?),然后存在数组中即可  //重点看pushLater    private void pushLater(DefaultHandle&lt;?&gt; item, Thread thread) &#123;        //DELAYED_RECYCLED是FastThreadLocal实例,返回的是一个WeakHashMap        //Map中以Stack实例(A线程的Stack)做key,Queue做value        Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled = DELAYED_RECYCLED.get();        WeakOrderQueue queue = delayedRecycled.get(this);        if (queue == null) &#123;            if (delayedRecycled.size() &gt;= maxDelayedQueues) &#123;                //Map容量无法再存放Queue了,添加一个哑队列,该缓存对象直接被丢弃                delayedRecycled.put(this, WeakOrderQueue.DUMMY);                return;            &#125;            //尝试创建一个新的Queue,最终调用的是WeakOrderQueue#newQueue进行Queue实例化            if ((queue = WeakOrderQueue.allocate(this, thread)) == null) &#123;                // drop object                return;            &#125;//将刚刚实例化的Queue加入当前线程的WeakHashMap中            delayedRecycled.put(this, queue);        &#125; else if (queue == WeakOrderQueue.DUMMY) &#123;            // drop object            return;        &#125;//缓存对象加入到Queue中        queue.add(item);    &#125;    //WeakOrderQueue的实例化      private WeakOrderQueue(Stack&lt;?&gt; stack, Thread thread) &#123;        //Link实例化时会实例化初始大小的DefaultHandle数组        tail = new Link();        head = new Head(stack.availableSharedCapacity);        head.link = tail;        owner = new WeakReference&lt;Thread&gt;(thread);    &#125;   //WeakOrderQueue#add    void add(DefaultHandle&lt;?&gt; handle) &#123;        handle.lastRecycledId = id;        Link tail = this.tail;        int writeIndex;        if ((writeIndex = tail.get()) == LINK_CAPACITY) &#123;            if (!head.reserveSpace(LINK_CAPACITY)) &#123;                // Drop it.                return;            &#125;            //如果当前tail已满且可以创建新的Link,那么创建Link并加入链表            this.tail = tail = tail.next = new Link();            writeIndex = tail.get();        &#125;//存储缓存对象        tail.elements[writeIndex] = handle;        handle.stack = null;        tail.lazySet(writeIndex + 1);    &#125;\n现在回看一下recycle方法Stack#push方法判断回收线程是stack对应的线程,直接将缓存对象加入stack的DufaultHandle数组中,否则调用pushLaterpushLater中通过FashThreadLocal拿到属于当前线程(B)的一个WeakHashMap&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;,创建一个WeakOrderQueue,实例化Queue过程中将该Queue设置到了Stack的head变量中,然后以当前Stack做键进行存储,最终调用WeakOrderQueue#add存储缓存对象。  \nRecycler#get这里假设线程A调用get想要获得一个缓存对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public final T get() &#123;    if (maxCapacityPerThread == 0) &#123;        return newObject((Handle&lt;T&gt;) NOOP_HANDLE);    &#125;    //threadLocal触发的initValue会创建一个属于当前线程的stack    Stack&lt;T&gt; stack = threadLocal.get();    DefaultHandle&lt;T&gt; handle = stack.pop();    //第一次pop为null    if (handle == null) &#123;        handle = stack.newHandle();        //value就是PooledUnsafeDirectBytebuf实例        handle.value = newObject(handle);    &#125;    return (T) handle.value;&#125;//Stack#pop  DefaultHandle&lt;T&gt; pop() &#123;    int size = this.size;    if (size == 0) &#123;        if (!scavenge()) &#123;            return null;        &#125;        size = this.size;    &#125;    size --;    DefaultHandle ret = elements[size];    elements[size] = null;    if (ret.lastRecycledId != ret.recycleId) &#123;        throw new IllegalStateException(\"recycled multiple times\");    &#125;    ret.recycleId = 0;    ret.lastRecycledId = 0;    this.size = size;    return ret;&#125;//scavenge内部调用了scavengeSome尝试从Queue中获取缓存对象boolean scavengeSome() &#123;    WeakOrderQueue prev;    WeakOrderQueue cursor = this.cursor;    if (cursor == null) &#123;        prev = null;        cursor = head;        if (cursor == null) &#123;            return false;        &#125;    &#125; else &#123;        prev = this.prev;    &#125;    boolean success = false;    do &#123;//this就是Stack实例,调用transfer方法尝试转移Queue中对象到该stack中        if (cursor.transfer(this)) &#123;            success = true;            break;        &#125;//如果没有转移成功,通过next遍历Queue依次尝试进行transfer获取对象        WeakOrderQueue next = cursor.next;        if (cursor.owner.get() == null) &#123;            if (cursor.hasFinalData()) &#123;                for (;;) &#123;                    if (cursor.transfer(this)) &#123;                        success = true;                    &#125; else &#123;                        break;                    &#125;                &#125;            &#125;            if (prev != null) &#123;                prev.setNext(next);            &#125;        &#125; else &#123;            prev = cursor;        &#125;        cursor = next;    &#125; while (cursor != null &amp;&amp; !success);    this.prev = prev;    this.cursor = cursor;    return success;&#125;\n……………..未完待续\n内存策略总结读写操作接下来,继续沿着EchoClientHandler的channelActive中ctx.writeAndFlush调用进行分析,他最终会走到AbstractChannelHandlerContext#write12345678910111213141516171819202122//这里的promise就是writeAndFlush返回的future,msg是写的内容private void write(Object msg, boolean flush, ChannelPromise promise) &#123;    //outbound是向前找,这里next就是HeadContext    AbstractChannelHandlerContext next = findContextOutbound();    final Object m = pipeline.touch(msg, next);    EventExecutor executor = next.executor();    if (executor.inEventLoop()) &#123;        if (flush) &#123;            next.invokeWriteAndFlush(m, promise);        &#125; else &#123;            next.invokeWrite(m, promise);        &#125;    &#125; else &#123;        AbstractWriteTask task;        if (flush) &#123;            task = WriteAndFlushTask.newInstance(next, m, promise);        &#125;  else &#123;            task = WriteTask.newInstance(next, m, promise);        &#125;        safeExecute(executor, task, promise, m);    &#125;&#125;\n……………..未完待续","dateCreated":"2018-09-24T15:21:31+08:00","dateModified":"2019-07-17T23:04:36+08:00","datePublished":"2018-09-24T15:21:31+08:00","description":"Netty基本架构(4.1.x-fianll)/基本源码(Nio Client端连接及读写操作)","headline":"Netty基础源码","image":["https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/nettyCover.png","https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2018/09/24/Netty基础源码2/"},"publisher":{"@type":"Organization","name":"一条咸鱼","sameAs":[],"image":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg","logo":{"@type":"ImageObject","url":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"}},"url":"http://yoursite.com/2018/09/24/Netty基础源码2/","thumbnailUrl":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/nettyCover.png"}</script>
    <meta name="description" content="Netty基本架构(4.1.x-fianll)/基本源码(Nio Client端连接及读写操作)">
<meta property="og:type" content="blog">
<meta property="og:title" content="Netty基础源码">
<meta property="og:url" content="http://yoursite.com/2018/09/24/Netty基础源码2/index.html">
<meta property="og:site_name" content="一条咸鱼">
<meta property="og:description" content="Netty基本架构(4.1.x-fianll)/基本源码(Nio Client端连接及读写操作)">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/1/allocator.png">
<meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/1/init.png">
<meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/1/chunk.jpg">
<meta property="og:updated_time" content="2019-07-17T15:04:36.571Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Netty基础源码">
<meta name="twitter:description" content="Netty基本架构(4.1.x-fianll)/基本源码(Nio Client端连接及读写操作)">
<meta name="twitter:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/1/allocator.png">
<meta property="fb:app_id" content="[object Object]">
    
    
        
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"/>
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/nettyCover.png"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/nettyCover.png" />
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg" />
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-du2xmrqdqrl2ollgeiw050kpl6l4nbyz7bumjuurjgsxyopifvukebxc9lqe.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">一条咸鱼</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
                </a>
                <h4 class="sidebar-profile-name">一条咸鱼</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Java Developer</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="首页">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link open-algolia-search" href="/all-archives" title="归档">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/about" title="关于">
                    
                        <i class="sidebar-button-icon fa fa-user" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-center
                    post-header-cover--full" style="background-image:url('https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg');" data-behavior="4">
            
                <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            Netty基础源码
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-09-24T15:21:31+08:00">
	
		    9月 24, 2018
    	
    </time>
    
</div>

    
</div>

            
        </div>

            <div id="main" data-behavior="4"
                 class="hasCover
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <!-- excerpt -->
<h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Client源码分析"><span class="toc-text">Client源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EchoClient"><span class="toc-text">EchoClient</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EchoClientHandler"><span class="toc-text">EchoClientHandler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BootStrap-Connect"><span class="toc-text">BootStrap#Connect</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BootStrap-doResolveAndConnect0"><span class="toc-text">BootStrap#doResolveAndConnect0</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bytebuf相关"><span class="toc-text">Bytebuf相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Bytebuf的分类"><span class="toc-text">Bytebuf的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Allocator实例化"><span class="toc-text">Allocator实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PoolArena实例化"><span class="toc-text">PoolArena实例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1024内存分配-1"><span class="toc-text">1024内存分配#1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实例化PoolThreadCache"><span class="toc-text">实例化PoolThreadCache</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1024内存分配-2"><span class="toc-text">1024内存分配#2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PoolChunk实例化"><span class="toc-text">PoolChunk实例化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PoolChunk的Page管理"><span class="toc-text">PoolChunk的Page管理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1024内存分配-3"><span class="toc-text">1024内存分配#3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#allocateNode寻找结点和值更新"><span class="toc-text">allocateNode寻找结点和值更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PoolSubpage的实例化"><span class="toc-text">PoolSubpage的实例化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16K内存分配"><span class="toc-text">16K内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32MB内存分配"><span class="toc-text">32MB内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Recycler"><span class="toc-text">Recycler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DefaultHandle-recycle"><span class="toc-text">DefaultHandle#recycle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Recycler-get"><span class="toc-text">Recycler#get</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存策略总结"><span class="toc-text">内存策略总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#读写操作"><span class="toc-text">读写操作</span></a></li></ol>
<h1 id="Client源码分析"><a href="#Client源码分析" class="headerlink" title="Client源码分析"></a>Client源码分析</h1><h2 id="EchoClient"><a href="#EchoClient" class="headerlink" title="EchoClient"></a>EchoClient</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String HOST = System.getProperty(<span class="string">"host"</span>, <span class="string">"127.0.0.1"</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">"port"</span>, <span class="string">"8007"</span>));</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = Integer.parseInt(System.getProperty(<span class="string">"size"</span>, <span class="string">"256"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Configure the client.</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.group(group)</span><br><span class="line">             .channel(NioSocketChannel.class)</span><br><span class="line">             .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">             .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     ChannelPipeline p = ch.pipeline();</span><br><span class="line">                     p.addLast(<span class="keyword">new</span> EchoClientHandler());</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">            <span class="comment">// Start the client.</span></span><br><span class="line">            ChannelFuture f = b.connect(HOST, PORT).sync();</span><br><span class="line">            <span class="comment">// Wait until the connection is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Shut down the event loop to terminate all threads.</span></span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="EchoClientHandler"><a href="#EchoClientHandler" class="headerlink" title="EchoClientHandler"></a>EchoClientHandler</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteBuf firstMessage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a client-side handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoClientHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        firstMessage = Unpooled.buffer(EchoClient.SIZE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; firstMessage.capacity(); i ++) &#123;</span><br><span class="line">            firstMessage.writeByte((<span class="keyword">byte</span>) i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.writeAndFlush(firstMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        System.out.println(in.toString());</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">       ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Close the connection when an exception is raised.</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BootStrap-Connect"><a href="#BootStrap-Connect" class="headerlink" title="BootStrap#Connect"></a>BootStrap#Connect</h2><p>该方法与Server的bind方法类似,最终走到BootStrap#doResolveAndConnect<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doResolveAndConnect</span><span class="params">(<span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的initAndRegister与ServerBootStrap的调用一样(都是父类AbstractBootStrap中的方法),但这次创建的Channel是NioSocketChannel<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以看到,这里记录的interestSet是OP_READ</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioByteChannel</span><span class="params">(Channel parent, SelectableChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, ch, SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中调用的init方法是BootStrap的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line">    <span class="comment">//添加自己实现的EchoClientHandler</span></span><br><span class="line">    p.addLast(config.handler());</span><br><span class="line">    设置options</span><br><span class="line">    <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">    <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">        setChannelOptions(channel, options, logger);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回想Server端的init方法中的addLast是添加了一个ChannelInitializer用于初始化客户端连接所对应的channel,Client端这里则直接将handler添加到pipeline上,这里填一下相关代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//handler就是echoClientHandler</span></span><br><span class="line">newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">addLast0(newCtx);</span><br><span class="line"><span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">    <span class="comment">//修改newCtx的handlerState为ADD_PENDING</span></span><br><span class="line">    newCtx.setAddPending();</span><br><span class="line">    <span class="comment">//封装newCtx为PendingHandlerAddedTask并赋值给pendingHandlerCallbackHead</span></span><br><span class="line">    <span class="comment">//稍后会调用</span></span><br><span class="line">    callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来的register方法链与Server端一致,都是使用eventLoop线程去执行register—&gt;register0,但是在register0中调用AbstractChannel#invokeHandlerAddedIfNeeded时调用我们刚刚说的pendingHandlerCallbackHead,最终调用initChannel方法将EchoClientHandler添加到Client端的pipeline上,同样的,该handler对应的context也被实例化,并通过addLast0加入到context链中。<br>随后initAndRegister返回,由于Server端分析时已经分析过Listener的作用流程,所以这里假设eventLoop线程在主线程if判断时已经做完具体的register工作,即已经将channel注册到Selector上,但并没有设置事件。<br>继续看doResolveAndConnect<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doResolveAndConnect</span><span class="params">(<span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接看doResolveAndConnect0</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!regFuture.isSuccess()) &#123;</span><br><span class="line">            <span class="keyword">return</span> regFuture;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//newPromise就是以channel为参数实例化DefaultChannelPromise</span></span><br><span class="line">        <span class="keyword">return</span> doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="BootStrap-doResolveAndConnect0"><a href="#BootStrap-doResolveAndConnect0" class="headerlink" title="BootStrap#doResolveAndConnect0"></a>BootStrap#doResolveAndConnect0</h3><p>这个方法等效于Server端的doBind0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doResolveAndConnect0</span><span class="params">(<span class="keyword">final</span> Channel channel, SocketAddress remoteAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> EventLoop eventLoop = channel.eventLoop();</span><br><span class="line">        <span class="keyword">final</span> AddressResolver&lt;SocketAddress&gt; resolver = <span class="keyword">this</span>.resolver.getResolver(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!resolver.isSupported(remoteAddress) || resolver.isResolved(remoteAddress)) &#123;</span><br><span class="line">            <span class="comment">// Resolver has no idea about what to do with the specified remote address or it's resolved already.</span></span><br><span class="line">            doConnect(remoteAddress, localAddress, promise);</span><br><span class="line">            <span class="keyword">return</span> promise;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>this.resolver是AddressResolverGroup实例,他其中保存了一个map(Map&lt;EventExecutor, AddressResolver<t>&gt;)<br>接下来看getResolver方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AddressResolver&lt;T&gt; <span class="title">getResolver</span><span class="params">(<span class="keyword">final</span> EventExecutor executor)</span> </span>&#123;</span><br><span class="line">    AddressResolver&lt;T&gt; r;</span><br><span class="line">    <span class="keyword">synchronized</span> (resolvers) &#123;</span><br><span class="line">        <span class="comment">//第一次调用肯定返回null</span></span><br><span class="line">        r = resolvers.get(executor);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> AddressResolver&lt;T&gt; newResolver;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//newResolver返回的是一个DefaultNameResolver实例</span></span><br><span class="line">                newResolver = newResolver(executor);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"failed to create a new resolver"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            resolvers.put(executor, newResolver);</span><br><span class="line">            <span class="comment">//这个terminationFuture可能是对应于"关闭客户端线程"</span></span><br><span class="line">            executor.terminationFuture().addListener(<span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (resolvers) &#123;</span><br><span class="line">                        resolvers.remove(executor);</span><br><span class="line">                    &#125;</span><br><span class="line">                    newResolver.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            r = newResolver;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>该方法返回后,doResolveAndConnect0中的if判断为真,这个if判断用到了一个matcher来进行isSupported判断,内部使用isInstance判断,对于本例来说返回false,接下来看doConnect方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doConnect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise connectPromise)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Channel channel = connectPromise.channel();</span><br><span class="line">      channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="comment">//本例的localAddress为null</span></span><br><span class="line">              <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  channel.connect(remoteAddress, connectPromise);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  channel.connect(remoteAddress, localAddress, connectPromise);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//这个Listener用于在future失败时关闭channel</span></span><br><span class="line">              connectPromise.addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//channel.connect方法一顿调用最终走到AbstractNioUnsafe#connect</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//还没有进行真正的socket connect,isActive返回false</span></span><br><span class="line">          <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">          <span class="keyword">if</span> (doConnect(remoteAddress, localAddress)) &#123;</span><br><span class="line">              fulfillConnectPromise(promise, wasActive);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//.....</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          <span class="comment">//......</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//一路调用,走到NioSocketChannel#doConnect  </span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doConnect</span><span class="params">(SocketAddress remoteAddress, SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (localAddress != <span class="keyword">null</span>) &#123;</span><br><span class="line">        doBind0(localAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//这里用的JDK底层的connect,这个方法对于非阻塞的channel,这个方法直接返回false</span></span><br><span class="line">        <span class="keyword">boolean</span> connected = SocketUtils.connect(javaChannel(), remoteAddress);</span><br><span class="line">        <span class="keyword">if</span> (!connected) &#123;</span><br><span class="line">            <span class="comment">//向selectionKey注册CONNECT事件</span></span><br><span class="line">            selectionKey().interestOps(SelectionKey.OP_CONNECT);</span><br><span class="line">        &#125;</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> connected;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            doClose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此channel已经完成了注册,并且在等到OP_CONNECT事件。<br>在Server端分析时说过register方法是被包装为一个task并通过NioEventLoop的无限循环来处理该task,在NioEventLoop的循环中,不断调用了Selector.select方法,当连接完成时,我们需要调用processSelectedKeys()来处理这个事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; selectedKeys.size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> SelectionKey k = selectedKeys.keys[i];</span><br><span class="line">        selectedKeys.keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//这里的attachment返回的就是SocketChannel,因为我们在register时将channel参数作为了</span></span><br><span class="line">        <span class="comment">//attachment</span></span><br><span class="line">        <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line">        <span class="comment">//if判断为true</span></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">            processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//NioEventLoop#processSelectedKey处理各种各样的事件,目前只分析CONNECT事件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//返回OP_CONNECT</span></span><br><span class="line">        <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">        <span class="comment">//if判断为true</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//ops为0</span></span><br><span class="line">            <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line">            <span class="comment">//重点方法</span></span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>unsafe.finishConnect()处理两件事:“Active事件的传播”,OP_READ的设置,其中重要的方法是fulfillConnectPromise<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//AbstractNioUnsafe#fulfillConnectPromise  </span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fulfillConnectPromise</span><span class="params">(ChannelPromise promise, <span class="keyword">boolean</span> wasActive)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; active) &#123;</span><br><span class="line">        pipeline().fireChannelActive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//最终走到AbstractChannelHandlerContext#invokeChannelActive</span></span><br><span class="line">  <span class="comment">//next现在指向的是HeadContext实例</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelActive</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next)</span> </span>&#123;</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelActive();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//HeadContext的invokeChannelActive实现如下,ctx指向的是headContext  </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      ctx.fireChannelActive();</span><br><span class="line"></span><br><span class="line">      readIfIsAutoRead();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//findContextInbound通过context的next引用和inbound属性循环找,找到第一个inboundContext</span></span><br><span class="line">    <span class="comment">//本例来说,就是EchoClientHandler对应的Context,最终通过这个context找到我们的handler</span></span><br><span class="line">    <span class="comment">//并调用channelActive方法,本例中该方法并没有继续调用fireChannelActive,所以active事件的传播到此为止</span></span><br><span class="line">    invokeChannelActive(findContextInbound());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里打断一下,HeadContext#channelActive中还调用了readIfisAutoRead方法,这个方法主要做的就是设置selectionKey的interestOps(同Server端分析的一样),他最终将初始化时指定的OP_READ设置进去。<br>在分析write之前,我们先回过来分析EchoClientHandler中关于ByteBuf相关的操作  </p>
<h1 id="Bytebuf相关"><a href="#Bytebuf相关" class="headerlink" title="Bytebuf相关"></a>Bytebuf相关</h1><h2 id="Bytebuf的分类"><a href="#Bytebuf的分类" class="headerlink" title="Bytebuf的分类"></a>Bytebuf的分类</h2><ul>
<li>heap/direct:堆上内存/堆外内存  </li>
<li>pooled/unpooled:是否基于对象池  </li>
<li>unsafe/safe:get/set方法是否通过UNSAFE对象直接操作    </li>
</ul>
<p>这里以PooledUnsafeDirectByteBuf为例进行分析<br><img src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/1/allocator.png" alt><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf byteBuf1 = PooledByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>);<span class="comment">//&lt;8192</span></span><br><span class="line">ByteBuf byteBuf2 = PooledByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>*<span class="number">16</span>);<span class="comment">//&gt;8192&amp;&amp;&lt;16MB</span></span><br><span class="line">ByteBuf byteBuf3 = PooledByteBufAllocator.DEFAULT.buffer(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">32</span>);<span class="comment">//&gt;16MB</span></span><br></pre></td></tr></table></figure></p>
<p>DEFAULT是PooledUnsafeDirectByteBuf的实例,实例化过程中会进行很多参数值的判断确认,这里全都使用默认值<br><img src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/1/init.png" alt><br>接下来的内存分配分析按照代码顺序分析  </p>
<h2 id="Allocator实例化"><a href="#Allocator实例化" class="headerlink" title="Allocator实例化"></a>Allocator实例化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledByteBufAllocator</span><span class="params">(<span class="keyword">boolean</span> preferDirect, <span class="keyword">int</span> nHeapArena, <span class="keyword">int</span> nDirectArena, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> tinyCacheSize, <span class="keyword">int</span> smallCacheSize, <span class="keyword">int</span> normalCacheSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> useCacheForAllThreads, <span class="keyword">int</span> directMemoryCacheAlignment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(preferDirect);<span class="comment">//true</span></span><br><span class="line">    threadCache = <span class="keyword">new</span> PoolThreadLocalCache(useCacheForAllThreads);<span class="comment">//true</span></span><br><span class="line">    <span class="keyword">this</span>.tinyCacheSize = tinyCacheSize;<span class="comment">//512</span></span><br><span class="line">    <span class="keyword">this</span>.smallCacheSize = smallCacheSize;<span class="comment">//256</span></span><br><span class="line">    <span class="keyword">this</span>.normalCacheSize = normalCacheSize;<span class="comment">//64</span></span><br><span class="line">    <span class="comment">//最终chunkSize计算值为16MB</span></span><br><span class="line">    chunkSize = validateAndCalculateChunkSize(pageSize, maxOrder);<span class="comment">//8192,11</span></span><br><span class="line">    <span class="comment">//最终pageShifts计算值为13</span></span><br><span class="line">    <span class="keyword">int</span> pageShifts = validateAndCalculatePageShifts(pageSize);<span class="comment">//8192</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nHeapArena &gt; <span class="number">0</span>) &#123;<span class="comment">//16</span></span><br><span class="line">        heapArenas = newArenaArray(nHeapArena);</span><br><span class="line">        List&lt;PoolArenaMetric&gt; metrics = <span class="keyword">new</span> ArrayList&lt;PoolArenaMetric&gt;(heapArenas.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heapArenas.length; i ++) &#123;</span><br><span class="line">            PoolArena.HeapArena arena = <span class="keyword">new</span> PoolArena.HeapArena(<span class="keyword">this</span>,</span><br><span class="line">                    pageSize, maxOrder, pageShifts, chunkSize,</span><br><span class="line">                    directMemoryCacheAlignment);</span><br><span class="line">            heapArenas[i] = arena;</span><br><span class="line">            metrics.add(arena);</span><br><span class="line">        &#125;</span><br><span class="line">        heapArenaMetrics = Collections.unmodifiableList(metrics);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        heapArenas = <span class="keyword">null</span>;</span><br><span class="line">        heapArenaMetrics = Collections.emptyList();</span><br><span class="line">    &#125;<span class="comment">//至此,实例化了16个heapArena,每个heapArena中有一个长度为32的PoolSubpage数组(tiny)和</span></span><br><span class="line">    <span class="comment">//长度为4的PoolSubpage数组(small),以及六个chunkList</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nDirectArena &gt; <span class="number">0</span>) &#123;<span class="comment">//16</span></span><br><span class="line">        directArenas = newArenaArray(nDirectArena);</span><br><span class="line">        List&lt;PoolArenaMetric&gt; metrics = <span class="keyword">new</span> ArrayList&lt;PoolArenaMetric&gt;(directArenas.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; directArenas.length; i ++) &#123;</span><br><span class="line">            PoolArena.DirectArena arena = <span class="keyword">new</span> PoolArena.DirectArena(</span><br><span class="line">                    <span class="keyword">this</span>, pageSize, maxOrder, pageShifts, chunkSize, directMemoryCacheAlignment);</span><br><span class="line">            directArenas[i] = arena;</span><br><span class="line">            metrics.add(arena);</span><br><span class="line">        &#125;</span><br><span class="line">        directArenaMetrics = Collections.unmodifiableList(metrics);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        directArenas = <span class="keyword">null</span>;</span><br><span class="line">        directArenaMetrics = Collections.emptyList();</span><br><span class="line">    &#125;<span class="comment">//至此又实例化了16个directArena,其中成员变量实例化过程与heapArena完全一样</span></span><br><span class="line">    metric = <span class="keyword">new</span> PooledByteBufAllocatorMetric(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PoolArena实例化"><a href="#PoolArena实例化" class="headerlink" title="PoolArena实例化"></a>PoolArena实例化</h3><p>directArena和heapArena的实例化方法都是调用父类的实例化方法,PoolArena<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">PoolArena</span><span class="params">(PooledByteBufAllocator parent, <span class="keyword">int</span> pageSize,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize, <span class="keyword">int</span> cacheAlignment)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...数据记录</span></span><br><span class="line">    <span class="comment">//创建长度为32的PoolSubpage数组(数组成员全null)</span></span><br><span class="line">    tinySubpagePools = newSubpagePoolArray(numTinySubpagePools);<span class="comment">//32</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tinySubpagePools.length; i ++) &#123;</span><br><span class="line">        <span class="comment">//数组中每个元素都是PoolSubpage实例,pageSize为8192</span></span><br><span class="line">        tinySubpagePools[i] = newSubpagePoolHead(pageSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numSmallSubpagePools = pageShifts - <span class="number">9</span>;<span class="comment">//4</span></span><br><span class="line">    <span class="comment">//数组长度为4,其余与上面类似</span></span><br><span class="line">    smallSubpagePools = newSubpagePoolArray(numSmallSubpagePools);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; smallSubpagePools.length; i ++) &#123;</span><br><span class="line">        smallSubpagePools[i] = newSubpagePoolHead(pageSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里实例化六个ChunkList负责管理Arena中的chunk,每个list中的chunk的使用率有要求</span></span><br><span class="line">    <span class="comment">//0-25/25-50/50-75/75-100,每个chunk大小16MB,使用率就是根据chunk使用大小和16MB的比值计算</span></span><br><span class="line">    q100 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, <span class="keyword">null</span>, <span class="number">100</span>, Integer.MAX_VALUE, chunkSize);<span class="comment">//maxCapacity为0</span></span><br><span class="line">    q075 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q100, <span class="number">75</span>, <span class="number">100</span>, chunkSize);<span class="comment">//maxCapacity为4MB</span></span><br><span class="line">    q050 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q075, <span class="number">50</span>, <span class="number">100</span>, chunkSize);<span class="comment">//maxCapacity为8MB</span></span><br><span class="line">    q025 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q050, <span class="number">25</span>, <span class="number">75</span>, chunkSize);<span class="comment">//maxCapacity为12MB</span></span><br><span class="line">    q000 = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q025, <span class="number">1</span>, <span class="number">50</span>, chunkSize);<span class="comment">//maxCapacity约等于16MB</span></span><br><span class="line">    qInit = <span class="keyword">new</span> PoolChunkList&lt;T&gt;(<span class="keyword">this</span>, q000, Integer.MIN_VALUE, <span class="number">25</span>, chunkSize);<span class="comment">//maxCapacity约等于16MB</span></span><br><span class="line">    <span class="comment">//将六个list组成双向列表</span></span><br><span class="line">    q100.prevList(q075);</span><br><span class="line">    q075.prevList(q050);</span><br><span class="line">    q050.prevList(q025);</span><br><span class="line">    q025.prevList(q000);</span><br><span class="line">    q000.prevList(<span class="keyword">null</span>);</span><br><span class="line">    qInit.prevList(qInit);</span><br><span class="line">    <span class="comment">//管理这六个list</span></span><br><span class="line">    List&lt;PoolChunkListMetric&gt; metrics = <span class="keyword">new</span> ArrayList&lt;PoolChunkListMetric&gt;(<span class="number">6</span>);</span><br><span class="line">    metrics.add(qInit);</span><br><span class="line">    metrics.add(q000);</span><br><span class="line">    metrics.add(q025);</span><br><span class="line">    metrics.add(q050);</span><br><span class="line">    metrics.add(q075);</span><br><span class="line">    metrics.add(q100);</span><br><span class="line">    chunkListMetrics = Collections.unmodifiableList(metrics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此,PooledBytebufAllocator和DirectArena&amp;HeaoArena(各16个)已经实例化完毕,接下来调用buffer(1024)分配指定大小内存。  </p>
<h3 id="1024内存分配-1"><a href="#1024内存分配-1" class="headerlink" title="1024内存分配#1"></a>1024内存分配#1</h3><p>buffer方法判断当前是否支持堆外内存分配(默认情况下支持),最终调用PooledBytebufAllocator#newDirectBuffer,这个方法比较长,分段看<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PoolThreadCache cache = threadCache.get();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>threadCache是内存分配器的成员变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolThreadLocalCache</span> <span class="keyword">extends</span> <span class="title">FastThreadLocal</span>&lt;<span class="title">PoolThreadCache</span>&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="实例化PoolThreadCache"><a href="#实例化PoolThreadCache" class="headerlink" title="实例化PoolThreadCache"></a>实例化PoolThreadCache</h4><p>当前线程第一次调用get,得到的值肯定为null,上一篇对于FastThreadLocal的分析可知,会调用initValue方法进行值的初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> PoolThreadCache <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//为当前线程寻找使用最少的Arena(线程和Arena是绑定的)</span></span><br><span class="line">    <span class="keyword">final</span> PoolArena&lt;<span class="keyword">byte</span>[]&gt; heapArena = leastUsedArena(heapArenas);</span><br><span class="line">    <span class="keyword">final</span> PoolArena&lt;ByteBuffer&gt; directArena = leastUsedArena(directArenas);</span><br><span class="line"></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (useCacheForAllThreads || current <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class="line">        <span class="comment">//当前threadLocal的get返回的就是这个PoolThreadCache</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PoolThreadCache(    <span class="comment">//512          256              64</span></span><br><span class="line">                heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,</span><br><span class="line">                <span class="comment">//32K                                   8K</span></span><br><span class="line">                DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// No caching so just use 0 as sizes.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PoolThreadCache(heapArena, directArena, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为当前线程找好Arena后,要实例化属于当前线程的PooLThreadCache<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PoolThreadCache(PoolArena&lt;<span class="keyword">byte</span>[]&gt; heapArena, PoolArena&lt;ByteBuffer&gt; directArena,</span><br><span class="line">                <span class="keyword">int</span> tinyCacheSize, <span class="keyword">int</span> smallCacheSize, <span class="keyword">int</span> normalCacheSize,</span><br><span class="line">                <span class="keyword">int</span> maxCachedBufferCapacity, <span class="keyword">int</span> freeSweepAllocationThreshold) &#123;</span><br><span class="line">    <span class="keyword">this</span>.freeSweepAllocationThreshold = freeSweepAllocationThreshold;</span><br><span class="line">    <span class="keyword">this</span>.heapArena = heapArena;</span><br><span class="line">    <span class="keyword">this</span>.directArena = directArena;</span><br><span class="line">    <span class="keyword">if</span> (directArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tinySubPageDirectCaches = createSubPageCaches(</span><br><span class="line">                tinyCacheSize, PoolArena.numTinySubpagePools, SizeClass.Tiny);</span><br><span class="line">        smallSubPageDirectCaches = createSubPageCaches(</span><br><span class="line">                smallCacheSize, directArena.numSmallSubpagePools, SizeClass.Small);</span><br><span class="line"></span><br><span class="line">        numShiftsNormalDirect = log2(directArena.pageSize);</span><br><span class="line">        normalDirectCaches = createNormalCaches(</span><br><span class="line">                normalCacheSize, maxCachedBufferCapacity, directArena);</span><br><span class="line">        <span class="comment">//至此PoolThreadCache中tinySubPageDirectCaches被实例化为长度为32的SubPageMemoryRegionCache数组,</span></span><br><span class="line">        <span class="comment">//每个SubPageMemoryRegionCache包含一个长度为cacheSize(512)的Queue(Object[512])</span></span><br><span class="line">        <span class="comment">//smallSubPageDirectCaches被实例化为长度为4的SubPageMemoryRegionCache数组,SubPageMemoryRegionCache</span></span><br><span class="line">        <span class="comment">//中包含的Queue长度为256,normalDirectCaches是长度为3的NormalMemoryRegionCache,其中Queue长度为64</span></span><br><span class="line">        <span class="comment">//更新Arena的相关线程数</span></span><br><span class="line">        directArena.numThreadCaches.getAndIncrement();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//heapArena的操作跟directArena完全一样  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时,get方法返回该cache  </p>
<h3 id="1024内存分配-2"><a href="#1024内存分配-2" class="headerlink" title="1024内存分配#2"></a>1024内存分配#2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;</span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">    <span class="keyword">if</span> (directArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">        buf = directArena.allocate(cache, initialCapacity, maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>directArena方法是父类方法,其中又将allocate分为两步<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PooledByteBuf&lt;T&gt; <span class="title">allocate</span><span class="params">(PoolThreadCache cache, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PooledByteBuf&lt;T&gt; buf = newByteBuf(maxCapacity);</span><br><span class="line">    allocate(cache, buf, reqCapacity);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//newByteBuf方法比较简单  </span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PooledUnsafeDirectByteBuf <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//RECYCLER内部有个threadLocal这个get会为当前线程创建一个Stack和DefaultHandle</span></span><br><span class="line">    <span class="comment">//并设置handle.value为PooledUnsafeDirectByteBuf实例并返回该实例</span></span><br><span class="line">    PooledUnsafeDirectByteBuf buf = RECYCLER.get();</span><br><span class="line">    <span class="comment">//设置buf的readerIndex/writerIndex/maxCapacity/引用计数+1</span></span><br><span class="line">    buf.reuse(maxCapacity);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//allocate方法  </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocate</span><span class="params">(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, <span class="keyword">final</span> <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个方法相当于将reqCapacity标准化,本例1024就是标准数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> normCapacity = normalizeCapacity(reqCapacity);</span><br><span class="line">    <span class="keyword">if</span> (isTinyOrSmall(normCapacity)) &#123; <span class="comment">// capacity &lt; pageSize(8192),本例capacity为1024,if为真</span></span><br><span class="line">        <span class="keyword">int</span> tableIdx;</span><br><span class="line">        PoolSubpage&lt;T&gt;[] table;</span><br><span class="line">        <span class="keyword">boolean</span> tiny = isTiny(normCapacity);<span class="comment">//1024&lt;512,tiny=false</span></span><br><span class="line">        <span class="keyword">if</span>(tiny)&#123;<span class="comment">//......</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//当前情况下,线程第一次获取Buffer,这个方法返回false</span></span><br><span class="line">            <span class="keyword">if</span> (cache.allocateSmall(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tableIdx = smallIdx(normCapacity);</span><br><span class="line">            table = smallSubpagePools;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> PoolSubpage&lt;T&gt; head = table[tableIdx];</span><br><span class="line">        <span class="comment">//这里有一段代码但当前情况下并不会有结果...</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分配其他大小的内存,先不分析</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过层层判断,最终会调用allocateNormal进行真正的堆外内存分配,这一步内存的分配是在PoolArena中进行,前面说过默认情况下每个线程都会关联两个Arena(heap/direct),而一个Arana也可能关联多个线程,所以这个方法必须在synchronized(this)块中被调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateNormal</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这些chunkList都没有chunk实例,所以allocate全部返回false</span></span><br><span class="line">    <span class="keyword">if</span> (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">        q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||</span><br><span class="line">        q075.allocate(buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="comment">//实例化pageSize为8192,chunkSize为16MB的chunk(另外两个参数暂不清楚作用)</span></span><br><span class="line">    PoolChunk&lt;T&gt; c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);</span><br><span class="line">    <span class="keyword">long</span> handle = c.allocate(normCapacity);</span><br><span class="line">    <span class="keyword">assert</span> handle &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//initBuf中主要做的就是在PooledUnsafeDirectBytebuf中记录当前buffer的内存地址</span></span><br><span class="line">    c.initBuf(buf, handle, reqCapacity);</span><br><span class="line">    <span class="comment">//将新创建的chunk添加到qInit中,add方法内部会判断chunk的使用率以将其添加到正确的chunkList中</span></span><br><span class="line">    qInit.add(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="PoolChunk实例化"><a href="#PoolChunk实例化" class="headerlink" title="PoolChunk实例化"></a>PoolChunk实例化</h4><p>newChunk会先调用UNSAFE的native方法用malloc分配16MB的堆外内存,并将该ByteBuffer作为参数传给chunk的构造方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">PoolChunk(PoolArena&lt;T&gt; arena, T memory, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> maxOrder, <span class="keyword">int</span> pageShifts, <span class="keyword">int</span> chunkSize, <span class="keyword">int</span> offset) &#123;</span><br><span class="line">    <span class="comment">//T就是ByteBuffer类型</span></span><br><span class="line">    unpooled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">this</span>.arena = arena;</span><br><span class="line">    <span class="keyword">this</span>.memory = memory;<span class="comment">//这就是UNSAFE分配的堆外内存的ByteBuffer实例</span></span><br><span class="line">    <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">    <span class="keyword">this</span>.pageShifts = pageShifts;</span><br><span class="line">    <span class="keyword">this</span>.maxOrder = maxOrder;</span><br><span class="line">    <span class="keyword">this</span>.chunkSize = chunkSize;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    unusable = (<span class="keyword">byte</span>) (maxOrder + <span class="number">1</span>);<span class="comment">//12</span></span><br><span class="line">    log2ChunkSize = log2(chunkSize);<span class="comment">//24</span></span><br><span class="line">    subpageOverflowMask = ~(pageSize - <span class="number">1</span>);<span class="comment">//-8192</span></span><br><span class="line">    <span class="comment">//记录当前chunk中可用大小</span></span><br><span class="line">    freeBytes = chunkSize;</span><br><span class="line">    <span class="keyword">assert</span> maxOrder &lt; <span class="number">30</span> : <span class="string">"maxOrder should be &lt; 30, but is: "</span> + maxOrder;</span><br><span class="line">    maxSubpageAllocs = <span class="number">1</span> &lt;&lt; maxOrder;<span class="comment">//2048</span></span><br><span class="line">    <span class="comment">//4K大小的memoryMap/depthMap</span></span><br><span class="line">    memoryMap = <span class="keyword">new</span> <span class="keyword">byte</span>[maxSubpageAllocs &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    depthMap = <span class="keyword">new</span> <span class="keyword">byte</span>[memoryMap.length];</span><br><span class="line">    <span class="keyword">int</span> memoryMapIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//初始化memoryMap/depthMap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt;= maxOrder; ++ d) &#123; <span class="comment">// move down the tree one level at a time</span></span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">1</span> &lt;&lt; d;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; depth; ++ p) &#123;</span><br><span class="line">            <span class="comment">// in each level traverse left to right and set value to the depth of subtree</span></span><br><span class="line">            memoryMap[memoryMapIndex] = (<span class="keyword">byte</span>) d;</span><br><span class="line">            depthMap[memoryMapIndex] = (<span class="keyword">byte</span>) d;</span><br><span class="line">            memoryMapIndex ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建长度为2048的PoolSubpage数组,意味着每一个chunk被分为2048个page,一个page8K</span></span><br><span class="line">    subpages = newSubpageArray(maxSubpageAllocs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="PoolChunk的Page管理"><a href="#PoolChunk的Page管理" class="headerlink" title="PoolChunk的Page管理"></a>PoolChunk的Page管理</h4><p>在上面的chunk实例化过程中可以看到,chunk被分为2048个大小为8K的page,同时初始化了两个map(其实是byte数组),chunk通过这两个数组来管理2048个page的分配<br>2048个page当做叶子结点组成完全二叉树共需要4K个结点<br><img src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/1/chunk.jpg" alt><br>底层的共2048(下标分别为2048-4095)个结点表示chunk分配的最小粒度page,对应到memoryMap中,index下标表示树中结点索引值,memoryMap[index]值表示树结点所在层级,如memoryMap[2048]=11表示第2048个结点在树的第11层。<br>如果分配内存小于pageSize,则直接在第11层找结点即可,如果大于pageSize,小于2*pageSize,则在第10层寻找结点,以此类推。<br>同时memoryMap[index]的值还表明了当前结点子结点的分配情况,如1024结点本应该在10层,即memoryMap[1024]=10,但当其子结点(2048或2049)被分配出去以后,会触发map的更新操作,导致2048结点本身以及其父结点,祖父节点,曾祖父结点(好像没这个说法)直到追溯到根节点……依次加1,那么memory[1024]=11,memory[512]=10…….<br>这样从memoryMap[index]实际值和初始值对比就能知道结点分配情况:如果实际值与理论初始值相等,说明两个子结点都没有被分配,如果等于初始值+1说明有一个子结点已被分配,如果等于12(chunk中以unusable记录)则表明当前结点下的所有子结点都被分配。</p>
<h3 id="1024内存分配-3"><a href="#1024内存分配-3" class="headerlink" title="1024内存分配#3"></a>1024内存分配#3</h3><p>接下来的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> handle = c.allocate(normCapacity);</span><br></pre></td></tr></table></figure></p>
<p>最终调用PoolChunk#allocateSubpage<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">allocateSubpage</span><span class="params">(<span class="keyword">int</span> normCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从Arena中的smallSubpagePools拿到一个PoolSubpage</span></span><br><span class="line">    PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity);</span><br><span class="line">    <span class="keyword">synchronized</span> (head) &#123;</span><br><span class="line">        <span class="keyword">int</span> d = maxOrder;<span class="comment">//maxOrder记录的是chunk中的Page树最大层级,即11</span></span><br><span class="line">        <span class="keyword">int</span> id = allocateNode(d);<span class="comment">//因为是分配小于8K的内存,所以直接从第11层分配即可</span></span><br><span class="line">        <span class="keyword">if</span> (id &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> PoolSubpage&lt;T&gt;[] subpages = <span class="keyword">this</span>.subpages;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pageSize = <span class="keyword">this</span>.pageSize;</span><br><span class="line">        <span class="comment">//分出去一个page,更新空闲内存值</span></span><br><span class="line">        freeBytes -= pageSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> subpageIdx = subpageIdx(id);</span><br><span class="line">        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx];</span><br><span class="line">        <span class="keyword">if</span> (subpage == <span class="keyword">null</span>) &#123;<span class="comment">//subpages未进行实例化,subpage为null,</span></span><br><span class="line">            <span class="comment">//PoolSubpage构造方法中会将this与参数中的head通过next,prev引用连接起来</span></span><br><span class="line">            subpage = <span class="keyword">new</span> PoolSubpage&lt;T&gt;(head, <span class="keyword">this</span>, id, runOffset(id), pageSize, normCapacity);</span><br><span class="line">            subpages[subpageIdx] = subpage;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            subpage.init(head, normCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subpage.allocate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="allocateNode寻找结点和值更新"><a href="#allocateNode寻找结点和值更新" class="headerlink" title="allocateNode寻找结点和值更新"></a>allocateNode寻找结点和值更新</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">allocateNode</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> initial = - (<span class="number">1</span> &lt;&lt; d); <span class="comment">// has last d bits = 0 and rest all = 1</span></span><br><span class="line">    <span class="comment">//返回memoryMap[id]</span></span><br><span class="line">    <span class="keyword">byte</span> val = value(id);</span><br><span class="line">    <span class="keyword">if</span> (val &gt; d) &#123; <span class="comment">// unusable</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (val &lt; d || (id &amp; initial) == <span class="number">0</span>) &#123;</span><br><span class="line">        id &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        val = value(id);</span><br><span class="line">        <span class="keyword">if</span> (val &gt; d) &#123;</span><br><span class="line">            <span class="comment">//这个求兄弟树ID的方法可以学一下！！！！！！！！！！</span></span><br><span class="line">            id ^= <span class="number">1</span>;</span><br><span class="line">            val = value(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将memoryMap[id]设置为unusable(12)表示当前结点已经分配出去了</span></span><br><span class="line">    setValue(id, unusable);</span><br><span class="line">    <span class="comment">//更新父结点的值</span></span><br><span class="line">    updateParentsAlloc(id);</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父结点更新过程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateParentsAlloc</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (id &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//除2得父结点的index</span></span><br><span class="line">        <span class="keyword">int</span> parentId = id &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//val1和val2是parent结点的两个子结点</span></span><br><span class="line">        <span class="keyword">byte</span> val1 = value(id);</span><br><span class="line">        <span class="keyword">byte</span> val2 = value(id ^ <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//可以看到父结点值是两子结点的小值,假设2048结点被分配出去了(设置为12)父结点一路更新+1</span></span><br><span class="line">        <span class="comment">//随后2049页也被分出去了,1024结点会被设为12,但由于是取小值所有512结点仍然是10</span></span><br><span class="line">        <span class="comment">//说明结点仅仅一棵子树全部分配当前结点仍然不会是12</span></span><br><span class="line">        <span class="keyword">byte</span> val = val1 &lt; val2 ? val1 : val2;</span><br><span class="line">        setValue(parentId, val);</span><br><span class="line">        id = parentId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PoolSubpage的实例化"><a href="#PoolSubpage的实例化" class="headerlink" title="PoolSubpage的实例化"></a>PoolSubpage的实例化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PoolSubpage(PoolSubpage&lt;T&gt; head, PoolChunk&lt;T&gt; chunk, <span class="keyword">int</span> memoryMapIdx, <span class="keyword">int</span> runOffset, <span class="keyword">int</span> pageSize, <span class="keyword">int</span> elemSize) &#123;</span><br><span class="line">    <span class="keyword">this</span>.chunk = chunk;</span><br><span class="line">    <span class="keyword">this</span>.memoryMapIdx = memoryMapIdx;</span><br><span class="line">    <span class="keyword">this</span>.runOffset = runOffset;<span class="comment">//记录的是当前page在其所属chunk的ByteBuffer中的偏移量</span></span><br><span class="line">    <span class="keyword">this</span>.pageSize = pageSize;</span><br><span class="line">    bitmap = <span class="keyword">new</span> <span class="keyword">long</span>[pageSize &gt;&gt;&gt; <span class="number">10</span>]; <span class="comment">//该bitmap用来进一步划分page</span></span><br><span class="line">    init(head, elemSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bitmap是长度为8的long数组,因为内存分配的最小单位是16,一个page8192,最多分为512份,一个long长64所以8个long刚好表示。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(PoolSubpage&lt;T&gt; head, <span class="keyword">int</span> elemSize)</span> </span>&#123;</span><br><span class="line">    doNotDestroy = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.elemSize = elemSize;</span><br><span class="line">    <span class="keyword">if</span> (elemSize != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//当前page被分为8段(8192/1024)</span></span><br><span class="line">        maxNumElems = numAvail = pageSize / elemSize;</span><br><span class="line">        <span class="comment">//下一个可用的段是0号段</span></span><br><span class="line">        nextAvail = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//bitmapLength记录需要几个long才能描述该page,本例需要1个即可</span></span><br><span class="line">        bitmapLength = maxNumElems &gt;&gt;&gt; <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span> ((maxNumElems &amp; <span class="number">63</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            bitmapLength ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bitmapLength; i ++) &#123;</span><br><span class="line">            bitmap[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//将当前page添加到PooArena的smallSubpagePools中</span></span><br><span class="line">    addToPool(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终1024大小内存分配完毕,返回buffer。    </p>
<h3 id="16K内存分配"><a href="#16K内存分配" class="headerlink" title="16K内存分配"></a>16K内存分配</h3><p>与1024分配不同在于PoolArane#allocate<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocate</span><span class="params">(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, <span class="keyword">final</span> <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//normCapacity=reqCapacity=1024*</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> normCapacity = normalizeCapacity(reqCapacity);</span><br><span class="line">    <span class="keyword">if</span> (normCapacity &lt;= chunkSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.allocateNormal(<span class="keyword">this</span>, buf, reqCapacity, normCapacity)) &#123;</span><br><span class="line">            <span class="comment">// was able to allocate out of the cache so move on</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            allocateNormal(buf, reqCapacity, normCapacity);</span><br><span class="line">            ++allocationsNormal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Huge allocations are never served via the cache so just call allocateHuge</span></span><br><span class="line">        allocateHuge(buf, reqCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在allocateNormal中首先通过chunkList进行内存分配,由于我们之前在1024分配时,实例化了qInit中的head(chunk实例),所以代码走到PoolChunkList(qInit)#allocate<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (PoolChunk&lt;T&gt; cur = head;;) &#123;</span><br><span class="line">    <span class="keyword">long</span> handle = cur.allocate(normCapacity);</span><br><span class="line">    <span class="keyword">if</span> (handle &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur.initBuf(buf, handle, reqCapacity);</span><br><span class="line">        <span class="keyword">if</span> (cur.usage() &gt;= maxUsage) &#123;</span><br><span class="line">            remove(cur);</span><br><span class="line">            nextList.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在chunk中从第10层开始找结点以进行分配,最终分配1025号结点(由于之前分配了1024的内存,所以1024号结点的值已经为11)<br>找到结点后,调用PoolChunk#initBuf-&gt;buf.init记录内存地址<br>最终返回这块Bytebuf,内存分配完毕。  </p>
<h3 id="32MB内存分配"><a href="#32MB内存分配" class="headerlink" title="32MB内存分配"></a>32MB内存分配</h3><p>之前的分析已经有看到,对于大块内存的分配,在PoolArena#allocate中会调用allocateHuge<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateHuge</span><span class="params">(PooledByteBuf&lt;T&gt; buf, <span class="keyword">int</span> reqCapacity)</span> </span>&#123;</span><br><span class="line">    PoolChunk&lt;T&gt; chunk = newUnpooledChunk(reqCapacity);</span><br><span class="line">    activeBytesHuge.add(chunk.chunkSize());</span><br><span class="line">    buf.initUnpooled(chunk, reqCapacity);</span><br><span class="line">    allocationsHuge.increment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>超大内存的分配比较简单,因为netty对于这种内存并不使用Pool进行池化,只是按照指定大小创建chunk并在Arena.activeBytesHuge中记录这个chunk的大小,随后调用init方法进行记录内存地址等初始化操作。</p>
<h3 id="Recycler"><a href="#Recycler" class="headerlink" title="Recycler"></a>Recycler</h3><p>Recycler是netty实现的一个对象池,概念上和linux内存管理中的SLAB有点像,也是为指定类型创建对象池,在前面的分析中有提到他(PooledUnsafeDirectByteBuf中的RECYCLER变量)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Recycler&lt;PooledUnsafeDirectByteBuf&gt; RECYCLER = <span class="keyword">new</span> Recycler&lt;PooledUnsafeDirectByteBuf&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PooledUnsafeDirectByteBuf <span class="title">newObject</span><span class="params">(Handle&lt;PooledUnsafeDirectByteBuf&gt; handle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PooledUnsafeDirectByteBuf(handle, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>DefaultHandle: Netty中的对象包装类,其成员变量value是真正被缓存的对象<br>Stack: Netty自己实现的栈,与线程通过FastThreadLocal绑定,其中有一个DefaultHandle数组用于存储本线程回收的对象<br>WeakOrderQueue: Netty中通过Recycler获取对象时的线程(假设为A)可能与回收(Handle#recycle)对象时的线程(假设为B)不是一个线程,对于这种情况会将Handle回收到WeakOrderQueue中<br>Link: WeakOrderQueue的内部类,其中包含一个DefaultHandle数组,真正存放上面说到的“get线程和recycle线程不同”的handle  </p>
<h4 id="DefaultHandle-recycle"><a href="#DefaultHandle-recycle" class="headerlink" title="DefaultHandle#recycle"></a>DefaultHandle#recycle</h4><p>先从回收方法看起,这里仍然假设A线程获取对象,B线程回收对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    stack.push(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Stack#push  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(DefaultHandle&lt;?&gt; item)</span> </span>&#123;</span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (threadRef.get() == currentThread) &#123;</span><br><span class="line">        pushNow(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pushLater(item, currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pushNow很简单,进行一些stack中DefaultHandle数组size的判断(拒绝?扩容?直接存?),然后存在数组中即可  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重点看pushLater</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pushLater</span><span class="params">(DefaultHandle&lt;?&gt; item, Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//DELAYED_RECYCLED是FastThreadLocal实例,返回的是一个WeakHashMap</span></span><br><span class="line">        <span class="comment">//Map中以Stack实例(A线程的Stack)做key,Queue做value</span></span><br><span class="line">        Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled = DELAYED_RECYCLED.get();</span><br><span class="line">        WeakOrderQueue queue = delayedRecycled.get(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (delayedRecycled.size() &gt;= maxDelayedQueues) &#123;</span><br><span class="line">                <span class="comment">//Map容量无法再存放Queue了,添加一个哑队列,该缓存对象直接被丢弃</span></span><br><span class="line">                delayedRecycled.put(<span class="keyword">this</span>, WeakOrderQueue.DUMMY);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//尝试创建一个新的Queue,最终调用的是WeakOrderQueue#newQueue进行Queue实例化</span></span><br><span class="line">            <span class="keyword">if</span> ((queue = WeakOrderQueue.allocate(<span class="keyword">this</span>, thread)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// drop object</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="comment">//将刚刚实例化的Queue加入当前线程的WeakHashMap中</span></span><br><span class="line">            delayedRecycled.put(<span class="keyword">this</span>, queue);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queue == WeakOrderQueue.DUMMY) &#123;</span><br><span class="line">            <span class="comment">// drop object</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="comment">//缓存对象加入到Queue中</span></span><br><span class="line">        queue.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//WeakOrderQueue的实例化  </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">WeakOrderQueue</span><span class="params">(Stack&lt;?&gt; stack, Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Link实例化时会实例化初始大小的DefaultHandle数组</span></span><br><span class="line">        tail = <span class="keyword">new</span> Link();</span><br><span class="line">        head = <span class="keyword">new</span> Head(stack.availableSharedCapacity);</span><br><span class="line">        head.link = tail;</span><br><span class="line">        owner = <span class="keyword">new</span> WeakReference&lt;Thread&gt;(thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//WeakOrderQueue#add</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(DefaultHandle&lt;?&gt; handle)</span> </span>&#123;</span><br><span class="line">        handle.lastRecycledId = id;</span><br><span class="line"></span><br><span class="line">        Link tail = <span class="keyword">this</span>.tail;</span><br><span class="line">        <span class="keyword">int</span> writeIndex;</span><br><span class="line">        <span class="keyword">if</span> ((writeIndex = tail.get()) == LINK_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!head.reserveSpace(LINK_CAPACITY)) &#123;</span><br><span class="line">                <span class="comment">// Drop it.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前tail已满且可以创建新的Link,那么创建Link并加入链表</span></span><br><span class="line">            <span class="keyword">this</span>.tail = tail = tail.next = <span class="keyword">new</span> Link();</span><br><span class="line">            writeIndex = tail.get();</span><br><span class="line">        &#125;<span class="comment">//存储缓存对象</span></span><br><span class="line">        tail.elements[writeIndex] = handle;</span><br><span class="line">        handle.stack = <span class="keyword">null</span>;</span><br><span class="line">        tail.lazySet(writeIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>现在回看一下recycle方法<br>Stack#push方法判断回收线程是stack对应的线程,直接将缓存对象加入stack的DufaultHandle数组中,否则调用pushLater<br>pushLater中通过FashThreadLocal拿到属于当前线程(B)的一个WeakHashMap&lt;Stack&lt;?&gt;, WeakOrderQueue&gt;,创建一个WeakOrderQueue,实例化Queue过程中将该Queue设置到了Stack的head变量中,然后以当前Stack做键进行存储,最终调用WeakOrderQueue#add存储缓存对象。  </p>
<h4 id="Recycler-get"><a href="#Recycler-get" class="headerlink" title="Recycler#get"></a>Recycler#get</h4><p>这里假设线程A调用get想要获得一个缓存对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxCapacityPerThread == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newObject((Handle&lt;T&gt;) NOOP_HANDLE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//threadLocal触发的initValue会创建一个属于当前线程的stack</span></span><br><span class="line">    Stack&lt;T&gt; stack = threadLocal.get();</span><br><span class="line">    DefaultHandle&lt;T&gt; handle = stack.pop();</span><br><span class="line">    <span class="comment">//第一次pop为null</span></span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="keyword">null</span>) &#123;</span><br><span class="line">        handle = stack.newHandle();</span><br><span class="line">        <span class="comment">//value就是PooledUnsafeDirectBytebuf实例</span></span><br><span class="line">        handle.value = newObject(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) handle.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Stack#pop  </span></span><br><span class="line"></span><br><span class="line"><span class="function">DefaultHandle&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.size;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!scavenge()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="keyword">this</span>.size;</span><br><span class="line">    &#125;</span><br><span class="line">    size --;</span><br><span class="line">    DefaultHandle ret = elements[size];</span><br><span class="line">    elements[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ret.lastRecycledId != ret.recycleId) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recycled multiple times"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ret.recycleId = <span class="number">0</span>;</span><br><span class="line">    ret.lastRecycledId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.size = size;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//scavenge内部调用了scavengeSome尝试从Queue中获取缓存对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">scavengeSome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WeakOrderQueue prev;</span><br><span class="line">    WeakOrderQueue cursor = <span class="keyword">this</span>.cursor;</span><br><span class="line">    <span class="keyword">if</span> (cursor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev = <span class="keyword">null</span>;</span><br><span class="line">        cursor = head;</span><br><span class="line">        <span class="keyword">if</span> (cursor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev = <span class="keyword">this</span>.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;<span class="comment">//this就是Stack实例,调用transfer方法尝试转移Queue中对象到该stack中</span></span><br><span class="line">        <span class="keyword">if</span> (cursor.transfer(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="comment">//如果没有转移成功,通过next遍历Queue依次尝试进行transfer获取对象</span></span><br><span class="line">        WeakOrderQueue next = cursor.next;</span><br><span class="line">        <span class="keyword">if</span> (cursor.owner.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cursor.hasFinalData()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cursor.transfer(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                        success = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.setNext(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev = cursor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cursor = next;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (cursor != <span class="keyword">null</span> &amp;&amp; !success);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    <span class="keyword">this</span>.cursor = cursor;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>……………..未完待续</p>
<h2 id="内存策略总结"><a href="#内存策略总结" class="headerlink" title="内存策略总结"></a>内存策略总结</h2><h1 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h1><p>接下来,继续沿着EchoClientHandler的channelActive中ctx.writeAndFlush调用进行分析,他最终会走到AbstractChannelHandlerContext#write<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的promise就是writeAndFlush返回的future,msg是写的内容</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Object msg, <span class="keyword">boolean</span> flush, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//outbound是向前找,这里next就是HeadContext</span></span><br><span class="line">    AbstractChannelHandlerContext next = findContextOutbound();</span><br><span class="line">    <span class="keyword">final</span> Object m = pipeline.touch(msg, next);</span><br><span class="line">    EventExecutor executor = next.executor();</span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            next.invokeWriteAndFlush(m, promise);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.invokeWrite(m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AbstractWriteTask task;</span><br><span class="line">        <span class="keyword">if</span> (flush) &#123;</span><br><span class="line">            task = WriteAndFlushTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">            task = WriteTask.newInstance(next, m, promise);</span><br><span class="line">        &#125;</span><br><span class="line">        safeExecute(executor, task, promise, m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>……………..未完待续</p>
            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/09/24/Netty基础源码1/" data-tooltip="Netty基础源码" aria-label="上一篇: Netty基础源码">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/09/10/Linux/" data-tooltip="Linux/存储基础" aria-label="下一篇: Linux/存储基础">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 一条咸鱼. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/09/24/Netty基础源码1/" data-tooltip="Netty基础源码" aria-label="上一篇: Netty基础源码">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/09/10/Linux/" data-tooltip="Linux/存储基础" aria-label="下一篇: Linux/存储基础">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Share this post">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-times"></i>
    <ul class="share-options">
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
        
            <h4 id="about-card-name">一条咸鱼</h4>
        
            <div id="about-card-bio"><p>重庆</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>学生</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/sideCover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-vufjrm3fmbuttogo1hxuu0w9w0sesk5iyysjuguc2hdhufot9szxg8twijry.min.js"></script>
<!--SCRIPTS END-->

    



    </body>
</html>
