
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="一条咸鱼">
    <title>Netty基础源码 - 一条咸鱼</title>
    <meta name="author" content="一条咸鱼">
    
    
        <link rel="icon" href="http://yoursite.com/assets/images/favicon.ico">
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"一条咸鱼","sameAs":[],"image":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"},"articleBody":"\n\n基本组件/架构BootStrap引导类启动器,进行各种配置的组装,启动Netty程序,设置Handler,绑定端口。同时客户端使用BootStrap,服务端使用ServerBootStrap。  \nEventLoop/EventLoopGroup一个EventLoop实例对应一个线程(永不改变),通过将通道(连接)注册到EventLoop上(多个Channel可以注册到同一个EventLoop上),该EventLoop对应的线程就可以处理该Channel上的所有IO事件(也只由该线程处理)。EventLoopGroup是多个EventLoop的集合(JDK线程池的扩展),BootStrap需要EventLoopGroup实例用来处理连接(服务端需要两个)。类图\nChannelNetty为了统一各种IO(BIO/NIO…)模式,协议(UDP/TCP…)下的API的统一性,自定义了表示连接的通道接口,Channel的所有IO操作都是异步的,返回一个ChannelFuture对象(有点像JDK的Future),可以在该ChanneFuture上绑定监听器,当操作完成后会调用相应方法。  \nChannelPipelin/ChannelHandler/ChannelInitializerChannelPipeline是与Channel一一对应的链表(责任链模式)。用户通过自定义ChannelHandler,netty将其注册到ChannelPipeline上来处理各种各样的事件,Handler基本划分为InboundHandler/OutboundHandler/DuplexHandler,分别处理输出/输出/输入+输出事件,用Netty自动调用方法(自动辨认In/Out)。ChannelInitalizer是一个特殊的Handler,他的主要作用就是初始化Channel(重写initChannel),当Channel被注册到EventLoop,Initializer注册到ChannelPipeline后,会自动调用initChannel方法,初始化完毕后,Initializer会被从ChannelPipeline上移除。  \nBytebufnetty自己实现的缓冲区,相较于JDK的更加易用,同时使用了内存池,高效的内存放配算法,零拷贝等提升性能。\nEcho代码(Server)EchoServer123456789101112131415161718192021222324252627282930313233public final class EchoServer &#123;    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\"));    public static void main(String[] args) throws Exception &#123;        // Configure the server.        EventLoopGroup bossGroup = new NioEventLoopGroup(1);        EventLoopGroup workerGroup = new NioEventLoopGroup();        final EchoServerHandler serverHandler = new EchoServerHandler();        try &#123;            ServerBootstrap b = new ServerBootstrap();            b.group(bossGroup, workerGroup)             .channel(NioServerSocketChannel.class)             .option(ChannelOption.SO_BACKLOG, 100)             .handler(new LoggingHandler(LogLevel.INFO))             .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                 @Override                 public void initChannel(SocketChannel ch) throws Exception &#123;                     ChannelPipeline p = ch.pipeline();                     p.addLast(serverHandler);                 &#125;             &#125;);            // Start the server.            ChannelFuture f = b.bind(PORT).sync();            // Wait until the server socket is closed.            f.channel().closeFuture().sync();        &#125; finally &#123;            // Shut down all event loops to terminate all threads.            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;\nEchoServerHandler12345678910111213141516171819202122@Sharablepublic class EchoServerHandler extends ChannelInboundHandlerAdapter &#123;    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;        ByteBuf in = (ByteBuf) msg;        System.out.println(in.toString());        ctx.write(msg);    &#125;    @Override    public void channelReadComplete(ChannelHandlerContext ctx) &#123;        ctx.flush();    &#125;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123;        // Close the connection when an exception is raised.        cause.printStackTrace();        ctx.close();    &#125;&#125;\nServer源码分析NioEventLoopGroup的初始化#1最终调用的实例化方法如下,此时未指定情况下,nThreads为0,excutor为null,selectProvider为平台相关的SelectorProvider实例(该实例的open方法返回Selector,Linux2.6以上Selector使用epoll),selectStrategyFactory是默认配置(目前不清楚这个实例在哪里用到,看名字像是挑选任务的策略器?),RejectedExecutionHandlers.reject()是拒绝策略(和JDK线程池一样),默认处理方法是直接抛异常。1234public NioEventLoopGroup(int nThreads, Executor executor, final SelectorProvider selectorProvider,                         final SelectStrategyFactory selectStrategyFactory) &#123;    super(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());&#125;\n走到父类的实例化方法1234protected MultithreadEventLoopGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory,                                 Object... args) &#123;    super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, chooserFactory, args);&#125;\n此处会修改nThreads值(如果为0),默认值的计算如下。PS:跟进availableProcessors()方法后,如果NettyRuntime记录的处理器数值是0,那么会调用JDK的Runtime来获取处理器的值,然后设置并返回该值,那么这个方法应该不会返回0,那Math.max的比较意义是什么呢……难道说Runtime获取到的可用处理器数会小于1或者等于0???12DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(        \"io.netty.eventLoopThreads\", NettyRuntime.availableProcessors() * 2));\n最终走到真正的实例化代码12345678protected MultithreadEventExecutorGroup(int nThreads, Executor executor,                                        EventExecutorChooserFactory chooserFactory, Object... args) &#123;    //......    if (executor == null) &#123;//        executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());    &#125;    //......&#125;\n前面说过,默认情况下executor为null,记下来看一下Netty的默认executor实现。1234@Overridepublic void execute(Runnable command) &#123;    threadFactory.newThread(command).start();&#125;\n该线程池的实现就是为每个Runnable都通过调用newDefaultThreadFactory()返回的线程工厂new一个Thread以执行任务,关键就是这个默认线程工厂以及其实例化的Thread。  \nDefaultThreadFactory#newThread(Runnable r)123456789101112131415public Thread newThread(Runnable r) &#123;    //调用重载方法,将传入的Runnable封装为一个FastThreadLocalRunnable    Thread t = newThread(FastThreadLocalRunnable.wrap(r), prefix + nextId.incrementAndGet());    try &#123;        if (t.isDaemon() != daemon) &#123;            t.setDaemon(daemon);        &#125;        if (t.getPriority() != priority) &#123;            t.setPriority(priority);        &#125;    &#125; catch (Exception ignored) &#123;        // Doesn't matter even if failed to set.    &#125;    return t;&#125;\nFastThreadLocalRunnable与Runnable的唯一不同就是run方法1234567public void run() &#123;    try &#123;//这里的runnable就是上面execute传入的command        runnable.run();    &#125; finally &#123;        FastThreadLocal.removeAll();    &#125;&#125;\nNetty的FastThreadNetty并没有直接使用JDK的Thread做Reactor线程,他使用了继承自Thread的FastThreadLocalThread,重要原因之一是Netty实现了FastThreadLocal/InternalThreadLocalMap(替代ThreadLocal和ThreadLocalMap),他在高并发的情况该提供了更好的性能。ThreadLocal使用threadLocalHashCode查找元素在Map中的位置,hash冲突时,效率降低。FastThreadLocal与ThreadLocal不同之处在于他不再使用hashCode,而是直接使用index,每个FastThreadLocal实例对应一个全局唯一的index,在从map中get元素时,直接返回objects[index]。  \nFastThreadLocal实例化12345public FastThreadLocal() &#123;    //nextVariableIndex调用InternalThreadLocalMap中的static final    //AtomicInteger#getAndIncrement(),全局唯一index    index = InternalThreadLocalMap.nextVariableIndex();&#125;\nFastThreadLocal#set1234567891011public final void set(V value) &#123;    //UNSET是一个占位符,remove的时候会分析    if (value != InternalThreadLocalMap.UNSET) &#123;        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();        if (setKnownNotUnset(threadLocalMap, value)) &#123;            registerCleaner(threadLocalMap);        &#125;    &#125; else &#123;        remove();    &#125;&#125;\nInternalThreadLocalMap.get()就是尝试获取当前Thread的map,如果是FastThreadLocalThread的实例,直接返回即可(如果为null会进行初始化),如果是普通Thread,需要通过slowGet获取InternalThreadLocalMap实例。1234567891011121314private static InternalThreadLocalMap slowGet() &#123;    //slowThreadLocalMap是为了兼容\"JDK的Thread使用FastThreadLocal\"的情况,其是一个static final实例    ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap;    //通过JDK的threadLocal的get尝试拿到InternalThreadLocalMap,返回null    InternalThreadLocalMap ret = slowThreadLocalMap.get();    if (ret == null) &#123;        //为JDK的thread设置InternalThreadLocalMap        //将InternalThreadLocalMap设置到ThreadLocal中,此时用户的JDK Thread的已经通过slowThreadLocalMap        // 拥有了属于自己的InternalThreadLocalMap实例,普通Thread也就可以使用FastThreadLocal        ret = new InternalThreadLocalMap();        slowThreadLocalMap.set(ret);    &#125;    return ret;&#125;\n至此,get方法中已经获取到了InternalThreadLocalMap(无论当前线程是普通线程还是Fast线程),随后进行真正的元素set1234567private boolean setKnownNotUnset(InternalThreadLocalMap threadLocalMap, V value) &#123;    if (threadLocalMap.setIndexedVariable(index, value)) &#123;     addToVariablesToRemove(threadLocalMap, this);     return true;   &#125;   return false;&#125;\n123456789101112public boolean setIndexedVariable(int index, Object value) &#123;    Object[] lookup = indexedVariables;    if (index &lt; lookup.length) &#123;        Object oldValue = lookup[index];        lookup[index] = value;        //如果是设置新值,返回true,如果是replace,返回false        return oldValue == UNSET;    &#125; else &#123;//需要扩容,这个地方个人认为算是FastThreadLocal设计的一个缺点?        expandIndexedVariableTableAndSet(index, value);        return true;    &#125;&#125;\n这里的set方法可以看到,如果当前FastThreadLocal的index大于length,就需要对数组进行扩容,但index本身就是递增的值,如果出现“某个FastThreadLocal被回收/不再使用”的情况,那么他的index对应的数组位置就会被一直“占着”,而无法使用(因为其index全局唯一且递增),回想JDK的实现,由于使用的是HashCode+线性探测法,所以并不会出现这种的“空间浪费”。  \nsetKnownNotUnset在插入完元素后123456789101112private static void addToVariablesToRemove(InternalThreadLocalMap threadLocalMap, FastThreadLocal&lt;?&gt; variable) &#123;    //variablesToRemoveIndex是static final值    Object v = threadLocalMap.indexedVariable(variablesToRemoveIndex);    Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove;    if (v == InternalThreadLocalMap.UNSET || v == null) &#123;        variablesToRemove = Collections.newSetFromMap(new IdentityHashMap&lt;FastThreadLocal&lt;?&gt;, Boolean&gt;());        threadLocalMap.setIndexedVariable(variablesToRemoveIndex, variablesToRemove);    &#125; else &#123;        variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;    &#125;//通过variablesToRemove记录所有那些\"Index在InternalThreadLocalMap有对应元素的\"FastThreadLocal,方便removeAll。    variablesToRemove.add(variable);&#125;\n接下来执行set中的最后一个方法registerCleaner1234567private void registerCleaner(final InternalThreadLocalMap threadLocalMap) &#123;    Thread current = Thread.currentThread();    if (FastThreadLocalThread.willCleanupFastThreadLocals(current) || threadLocalMap.isCleanerFlagSet(index)) &#123;        return;    &#125;    threadLocalMap.setCleanerFlag(index);&#125;\n该方法最终的执行结果就是将FastThreadLocal的Index设置到InternalThreadLocalMap#BitSet中(无论当前线程类型是什么),暂时不清楚这个BitSet是用来干什么的。至此set执行完毕,get方法很简单,获取map-&gt;根据index获取value-&gt;value若为“占位符UNSET”,调用初始化方法(默认初始化为null),set方法,register方法,最后返回(null)。  \nFastThreadLocal#removeAll在之前的FastThreadLocalRunnable#run方法中可以看到,finally调用了removeAll。123456789101112131415161718192021public static void removeAll() &#123;    InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.getIfSet();    if (threadLocalMap == null) &#123;        return;    &#125;    try &#123;//拿到variablesToRemoveIndex中的元素(set方法中分析过)        Object v = threadLocalMap.indexedVariable(variablesToRemoveIndex);        if (v != null &amp;&amp; v != InternalThreadLocalMap.UNSET) &#123;            @SuppressWarnings(\"unchecked\")            Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;            FastThreadLocal&lt;?&gt;[] variablesToRemoveArray =                    variablesToRemove.toArray(new FastThreadLocal[0]);            //遍历remove            for (FastThreadLocal&lt;?&gt; tlv: variablesToRemoveArray) &#123;                tlv.remove(threadLocalMap);            &#125;        &#125;    &#125; finally &#123;        InternalThreadLocalMap.remove();    &#125;&#125;\n接下来先分析FastThreadLocal的remove123456789101112131415public final void remove(InternalThreadLocalMap threadLocalMap) &#123;    if (threadLocalMap == null) &#123;        return;    &#125;    //将数组中的index位元素设置为占位符(UNSET)    Object v = threadLocalMap.removeIndexedVariable(index);    removeFromVariablesToRemove(threadLocalMap, this);    if (v != InternalThreadLocalMap.UNSET) &#123;        try &#123;//默认空实现            onRemoval((V) v);        &#125; catch (Exception e) &#123;            PlatformDependent.throwException(e);        &#125;    &#125;&#125;\n继续深入removeFromVariablesToRemove1234567891011private static void removeFromVariablesToRemove(        InternalThreadLocalMap threadLocalMap, FastThreadLocal&lt;?&gt; variable) &#123;    Object v = threadLocalMap.indexedVariable(variablesToRemoveIndex);    if (v == InternalThreadLocalMap.UNSET || v == null) &#123;        return;    &#125;    //将当前FastThreadLocal从set中移除,这个特殊位置的set只记录那些当前线程使用了的FastThreadLocal    @SuppressWarnings(\"unchecked\")    Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;    variablesToRemove.remove(variable);&#125;\n遍历调用remove后,当前线程的所有FastThreadLocal已经被从map中移除,接下来走到finally中处理map123456789public static void remove() &#123;    Thread thread = Thread.currentThread();    if (thread instanceof FastThreadLocalThread) &#123;        //将FastThreadLocalThread的map置null        ((FastThreadLocalThread) thread).setThreadLocalMap(null);    &#125; else &#123;//如果是普通线程,从UnpaddedInternalThreadLocalMap中移除当前线程的map        slowThreadLocalMap.remove();    &#125;&#125;\n至此,当前线程的所有元素,FastThreadLocal,map都已被移除,线程可以结束。  \nNioEventLoopGroup的初始化#2回到NioEventLoopGroup的初始化,代码走到1234567891011121314children = new EventExecutor[nThreads];for (int i = 0; i &lt; nThreads; i ++) &#123;    boolean success = false;    try &#123;//executor就是之前分析的ThreadPerTaskExecutor,args是一大堆默认的参数列表        //newChile是实例化具体的EventLoop,本例中指的就是NioEventLoop,所以调用        //NioEventLoopGroup#newChild        children[i] = newChild(executor, args);        success = true;    &#125; catch (Exception e) &#123;        throw new IllegalStateException(\"failed to create a child event loop\", e);    &#125; finally &#123;//如果EventLoop创建失败,关闭所有之前创建的EventLoop,暂时不分析        //...    &#125;&#125;\n按照指定线程数创建线程123456protected EventLoop newChild(Executor executor, Object... args) throws Exception &#123;    //args[0]是平台相关SelectorProvider,args[1]是DefaultEventExecutorChooserFactory实例    //args[2]是直接抛异常的拒绝处理器    return new NioEventLoop(this, executor, (SelectorProvider) args[0],        ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2]);&#125;\nNioEventLoop123456789101112131415161718NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;    //DEFAULT_MAX_PENDING_TASKS默认为Integer最大值    super(parent, executor, false, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);    if (selectorProvider == null) &#123;        throw new NullPointerException(\"selectorProvider\");    &#125;    if (strategy == null) &#123;        throw new NullPointerException(\"selectStrategy\");    &#125;    provider = selectorProvider;    //获取Selector(难道是一个EventLoop对应一个Selector???)SelectorTuple是对Selector的封装,    // 从构造函数看,其selector/unwrappedSelector都是同一个Selector实例,暂时不知道为什么这么设计......    final SelectorTuple selectorTuple = openSelector();    selector = selectorTuple.selector;    unwrappedSelector = selectorTuple.unwrappedSelector;    selectStrategy = strategy;&#125;\nSingleThreadEventLoop的构造方法中实例化了一个DEFAULT_MAX_PENDING_TASKS大小的的LinkedBlockingQueue(注释说是任务队列)赋值给tailTasks接下来走到SingleThreadEventExecutor实例化12345678910111213protected SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor,                                    boolean addTaskWakesUp, int maxPendingTasks,                                    RejectedExecutionHandler rejectedHandler) &#123;    super(parent);    //如果为true则只有在调用addTask方法时才会唤醒当前线程,默认为false    this.addTaskWakesUp = addTaskWakesUp;    //应该为Integer.MAX_VALUE(为什么要再比一次?)前面的DEFAULT就是与16比,选最大值    this.maxPendingTasks = Math.max(16, maxPendingTasks);    this.executor = ObjectUtil.checkNotNull(executor, \"executor\");    //这里为什么又new一个任务队列？暂时不知道......    taskQueue = newTaskQueue(this.maxPendingTasks);    rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, \"rejectedHandler\");&#125;\nServerBootStrap的配置首先配置EventLoopGroup,parentGroup就是前面nThreads=1的Group,childGroup是默认线程数量Group123456public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) &#123;    super.group(parentGroup);    //...    this.childGroup = childGroup;    return this;&#125;\n然后是调用父类的channel方法实例化一个channel工厂12345public B channel(Class&lt;? extends C&gt; channelClass) &#123;    //....    //实例化ReflectiveChannelFactory(一个通过反射调用默认构造器的工厂)    return channelFactory(new ReflectiveChannelFactory&lt;C&gt;(channelClass));&#125;\n接下来调用option方法进行配置  \nChannelOption&amp;ChannelConfigNetty中的每个Channel都有对应的配置信息类(实现ChannelConfig接口),如NioServerSocketChannel对应的ServerSocketChannelConfig,这个Config记录了该Channel的一些底层连接配置(如超时时间,连接缓冲区大小,连接队列大小)。ChannelOption提供了一种类型安全的配置ChannelConfig的方式,使得在配置信息时并不需要关注Channel的实际类型,其中的泛型T指的是该配置对应的值的类型,如server代码中的.option(ChannelOption.SO_BACKLOG, 100)12345678910111213public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value) &#123;    //...    if (value == null) &#123;        synchronized (options) &#123;            options.remove(option);        &#125;    &#125; else &#123;//options是存储ChannelOption的LinkedHashMap        synchronized (options) &#123;            options.put(option, value);        &#125;    &#125;    return self();&#125;\n接下来的handler()&amp;childHandler()方法分别将handler设置到AbstractBootstrap&amp;ServerBootstrap中,此处ServerBootStrap中设置的是一个ChannelInitializer(),他是ChannelInboundHandlerAdapter的抽象子类,重要的是他的initChannel方法,后面分析,其上的Sharable注解表示该handler的实例可以被多个ChannelPipeline共享,即他不保存有状态的信息。\nServerBootStrap的启动#1bind方法一路调用,走到第一个主要方法doBind(SocketAddress),参数是根据port实例化的InetSocketAddress,这个方法调用链很长,分段分析。1234private ChannelFuture doBind(final SocketAddress localAddress) &#123;    final ChannelFuture regFuture = initAndRegister();    //...&#125;\nServerBootStrap#initAndRegister#1首先分析doBind中的initAndRegister相关方法1234567final ChannelFuture initAndRegister() &#123;    Channel channel = null;    try &#123;//反射调用默认构造方法以实例化NioServerSocketChannel(是Netty对于JDK的Channel的封装)        channel = channelFactory.newChannel();        init(channel);    &#125; &#125;\nServerChannel的实例化channelFactory调用的是NioServerSocketChannel的无参构造方法1234public NioServerSocketChannel() &#123;    //通过NioEventLoopGroup实例化时设置的SelectorProvider创建Channel实例    this(newSocket(DEFAULT_SELECTOR_PROVIDER));&#125;\n可以看到这个ServerChannel的监听事件就是OP_ACCEPT1234public NioServerSocketChannel(ServerSocketChannel channel) &#123;    super(null, channel, SelectionKey.OP_ACCEPT);//javaChannel返回的就是之前newSocket的返回值    config = new NioServerSocketChannelConfig(this, javaChannel().socket());&#125;\n接下来到父类AbstractNioChannel,记录channel和SelectionKey.OP_ACCEPT。随后AbstractChannel构造方法123456protected AbstractChannel(Channel parent) &#123;    this.parent = parent;    id = newId();//Channel的全局唯一标识符    unsafe = newUnsafe();    pipeline = newChannelPipeline();//DefaultChannelPipeline实例&#125;\n跟进看一下DefaultChannelPipeline的实例化1234567891011protected DefaultChannelPipeline(Channel channel) &#123;    this.channel = ObjectUtil.checkNotNull(channel, \"channel\");    succeededFuture = new SucceededChannelFuture(channel, null);    //Promise相当于可写的Future,这里的实例的主要作用就是传播Exception    voidPromise =  new VoidChannelPromise(channel, true);    tail = new TailContext(this);    head = new HeadContext(this);    //两个Context互相连起来    head.next = tail;    tail.prev = head;&#125;\n两个Context的实例化比较简单,其中比较关键的一步是设置Context的handlerState为ADD_COMPLETE。至此NioServerSocketchannel已经实例化完毕。  \nServerBootStrap#initAndRegister#2回到initAndRegister中调用ServerBootStrap的init以初始化ServerChannel12345678910111213141516171819202122232425262728293031void init(Channel channel) throws Exception &#123;    final Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();    synchronized (options) &#123;//遍历,为Channel实例进行配置信息的设置        setChannelOptions(channel, options, logger);    &#125;//LinkedHashMap实例,目前其中没有数据,暂时不分析    final Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();    synchronized (attrs) &#123;        //......    &#125;    ChannelPipeline p = channel.pipeline();    //用于处理连接的NioEventLoopGroup    final EventLoopGroup currentChildGroup = childGroup;    //自己实现的ChannelInitializer    final ChannelHandler currentChildHandler = childHandler;    final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;    final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;    //进行深拷贝转化为数组    synchronized (childOptions) &#123;        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(0));    &#125;    synchronized (childAttrs) &#123;        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(0));    &#125;    //将ChannelInitializer实例添加到ServerChannel的Pipeline上(具体其实是添加到context上)    p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;        @Override        public void initChannel(final Channel ch) throws Exception &#123;          //这里的initChannel会在后面调用/分析        &#125;    &#125;);&#125;\n这段代码中最重要的就是addLast的调用  \nDefaultChannelPipeline#addLast其中的group,name全为null123456789101112public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) &#123;    final AbstractChannelHandlerContext newCtx;    synchronized (this) &#123;        checkMultiplicity(handler);        //一个handler对应一个ChannelHandlerContext,此处进行context实例化        //现根据handler为其生成name        newCtx = newContext(group, filterName(name, handler), handler);        addLast0(newCtx);        //.....    &#125;      //......&#125;\n首先实例化一个DefaultChannelHandlerContext123456DefaultChannelHandlerContext(        DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) &#123;    //ChannelInitializer是InboundHandler的子类,executor为null,父类只做一些简单的赋值操作    super(pipeline, executor, name, isInbound(handler), isOutbound(handler));    this.handler = handler;&#125;\n其次的addLas0主要做的就是将context插入到tail(在实例化ServerChannel的DefaultChannelPipeline时创建的)前面。随后addLast走到12345678910//registered表示ServerChannel第一次调用addLast,此时registered为false,说明Channel还没有注册到eventLoopif (!registered) &#123;    //修改newCtx的handlerState为ADD_PENDING    newCtx.setAddPending();    //封装newCtx为PendingHandlerAddedTask并赋值给pendingHandlerCallbackHead    //注意,这个pendingHandlerCallbackHead(PendingHandlerAddedTask的实例)    //将会在后面被调用    callHandlerCallbackLater(newCtx, true);    return this;&#125;\n此时addLast方法已经返回,其中的其他代码在后面分析。  \nServerBootStrap#initAndRegister#31234567891011//group返回的就是最开始nThreads=1的那个NioEventLoopGroup,//一路调用先走到SingleThreadEventLoop#register,这个类就是NioEventLoop的父类ChannelFuture regFuture = config().group().register(channel);if (regFuture.cause() != null) &#123;    if (channel.isRegistered()) &#123;        channel.close();    &#125; else &#123;        channel.unsafe().closeForcibly();    &#125;&#125;return regFuture;\nSingleThreadEventLoop#register只是将ServerSocketChannel包装一下123456789        //将Channel封装为DefaultChannelPromise        return register(new DefaultChannelPromise(channel, this));//继续调用    public ChannelFuture register(final ChannelPromise promise) &#123;        ObjectUtil.checkNotNull(promise, \"promise\");        promise.channel().unsafe().register(this, promise);        return promise;    &#125;\nunsafe方法返回的是AbstractChannel的内部类AbstractUnsafe(netty的Unsafe接口的抽象实现类)的实例。12345678910111213141516171819public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;    //......    //在这里将ServerChannel与eventLoop进行绑定    AbstractChannel.this.eventLoop = eventLoop;    //inEventLoop是判断当前线程是否是EventLoop线程(我们现在是在主线程中启动ServerBootStrap,所以应该返回false)    if (eventLoop.inEventLoop()) &#123;        register0(promise);    &#125; else &#123;        try &#123;//用eventLoop线程去做register工作(\"异步\"的体现)            eventLoop.execute(new Runnable() &#123;                @Override                public void run() &#123;                    register0(promise);                &#125;            &#125;);        &#125;         //....    &#125;&#125;\n12345678910111213141516171819202122232425262728293031323334353637383940414243public void execute(Runnable task) &#123;    //...    //继续返回false    boolean inEventLoop = inEventLoop();    //把task加入到当前eventLoop的任务队列中    addTask(task);    if (!inEventLoop) &#123;        startThread();        if (isShutdown() &amp;&amp; removeTask(task)) &#123;            reject();        &#125;    &#125;    if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;        wakeup(inEventLoop);    &#125;&#125;private void startThread() &#123;    //state的默认值就是ST_NOT_STARTED    if (state == ST_NOT_STARTED) &#123;        if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) &#123;            try &#123;                doStartThread();            &#125; //...        &#125;    &#125;&#125;private void doStartThread() &#123;    assert thread == null;    //executor就是ThreadPerTaskExecutor,其会调用之前分析的线程工厂创建一个线程来执行这个任务    //此时,initAndRegister方法已经返回了    executor.execute(new Runnable() &#123;        @Override        public void run() &#123;            //注意,执行到这里,EventLoop的thread变量才被赋值            thread = Thread.currentThread();            //任务的具体内容稍后分析        &#125;    &#125;);&#125;\n至此,initAndRegister返回了包装了ServerSocketChannel的DefaultChannelPromise,终于回到了doBind方法,然而此时只执行了doBind方法中的第一行代码…….  \nServerBootStrap的启动#21234567891011121314151617181920212223242526private ChannelFuture doBind(final SocketAddress localAddress) &#123;    final ChannelFuture regFuture = initAndRegister();    final Channel channel = regFuture.channel();    //注释说大部分情况下,register已经完成,为了看Listener相关    //这里假设register方法还没有执行完,即isDone返回false    if (regFuture.isDone()) &#123;        //...    &#125; else &#123;        //...        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);        regFuture.addListener(new ChannelFutureListener() &#123;            @Override            public void operationComplete(ChannelFuture future) throws Exception &#123;                Throwable cause = future.cause();                if (cause != null) &#123;                    //register过程中出错了                    promise.setFailure(cause);                &#125; else &#123;                    promise.registered();                    doBind0(regFuture, channel, localAddress, promise);                &#125;            &#125;        &#125;);        return promise;    &#125;&#125;\n代码中向future(DefaultChannelPormise实例)添加了一个Listener,Listener的内部方法稍后分析,先分析addListener-&gt;DefaultPromise#addListener1234567891011121314public Promise&lt;V&gt; addListener(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt; listener) &#123;    checkNotNull(listener, \"listener\");    synchronized (this) &#123;        //使用数组保存Listener        addListener0(listener);    &#125;    //再次检查是否完成,如果完成,唤醒调用所有的Listener,这里的再次检查避免了    //\"添加Listener到数组之前Future已经完成,导致错过Listener\"    //这里仍然假设没有完成    if (isDone()) &#123;        notifyListeners();    &#125;    return this;&#125;\n至此,bind(doBind)方法已经结束,但我们假设EventLoop中调用的的register方法还没有结束,开头的实例代码中,调用了sync,继续分析。  \nDefaultChannelPromise#syncsync方法阻塞等待future的任务完成12345678910111213141516171819202122232425262728293031    public Promise&lt;V&gt; sync() throws InterruptedException &#123;        await();        rethrowIfFailed();        return this;    &#125;//---------------------------------------    public Promise&lt;V&gt; await() throws InterruptedException &#123;        if (isDone()) &#123;//再次检查任务是否完成            return this;        &#125;        if (Thread.interrupted()) &#123;            throw new InterruptedException(toString());        &#125;        //检查死锁,主要步骤就是检查当前线程是否是eventLoop线程,如果是的话说明出现了死锁,        //抛出异常，当前调用sync的线程是主线程,所以没有死锁        checkDeadLock();        //仍未完成的话,就要调用Object#wait        synchronized (this) &#123;            while (!isDone()) &#123;                incWaiters();//记录sync调用者数量                try &#123;                    wait();                &#125; finally &#123;                    decWaiters();                &#125;            &#125;        &#125;        return this;    &#125;\n至此,主线程已经成功阻塞,等待eventLoop完成register后唤醒他。  \nregister&amp;runeventLoop要运行的runnable是在之前分析的doStartThread中定义的1234567891011public void run() &#123;    boolean success = false;    //更新最近执行任务的时间    updateLastExecutionTime();    try &#123;//这里的run方法调用的是register方法中封装的runnable        SingleThreadEventExecutor.this.run();        success = true;    &#125; catch (Throwable t) &#123;        logger.warn(\"Unexpected exception from an event executor: \", t);    &#125; //....&#125;\nSingleThreadEventExecutor.this对于本例来说就是NioEventLoop,下面看一下他的run方法  \nrun12345678910111213141516171819202122232425262728293031323334353637383940protected void run() &#123;    for (;;) &#123;        try &#123;            switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;                case SelectStrategy.CONTINUE:                    continue;                case SelectStrategy.SELECT:                    select(wakenUp.getAndSet(false));                    if (wakenUp.get()) &#123;                        selector.wakeup();                    &#125;                default:            &#125;            cancelledKeys = 0;            needsToSelectAgain = false;            final int ioRatio = this.ioRatio;            if (ioRatio == 100) &#123;                try &#123;                    processSelectedKeys();                &#125; finally &#123;                    // Ensure we always run tasks.                    runAllTasks();                &#125;            &#125; else &#123;                final long ioStartTime = System.nanoTime();                try &#123;                    processSelectedKeys();                &#125; finally &#123;                    // Ensure we always run tasks.                    final long ioTime = System.nanoTime() - ioStartTime;                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);                &#125;            &#125;        &#125; catch (Throwable t) &#123;            handleLoopException(t);        &#125;        //......    &#125;&#125;\n首先是switch语句中的hastTasks,这个方法就是判断taskQueue是否为空,在SingleThreadEventExecutor#execute中曾经向其中添加过一个task,所以该方法返回true123public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception &#123;    return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;&#125;\nselectSupplier.get()内部只是继续调用了Selector#selectNow,由于我们目前还没完成注册selectNow自然返回0,所以直接退出switch。ioRatio这个int变量的意思是“IO事件的时间占比”,对于EventLoop来说有两类事要处理“IO”和“task”,这个值默认为50,即IO事件和task时间占比1:1,由于目前没有任何selectKey,所以接下来直接看else中调用的runAlltasks1234567891011121314151617181920212223242526272829303132333435protected boolean runAllTasks(long timeoutNanos) &#123;    //将现在应该执行的定时任务添加到taskQueue中,暂不分析    fetchFromScheduledTaskQueue();    Runnable task = pollTask();    if (task == null) &#123;        afterRunningAllTasks();        return false;    &#125;    //计算终止时间    final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;    long runTasks = 0;    long lastExecutionTime;    for (;;) &#123;//简单调用task.run()        safeExecute(task);        //完成任务数+!        runTasks ++;        //每隔64个任务检查一次时间,减少System.nanoTime的调用次数        if ((runTasks &amp; 0x3F) == 0) &#123;            lastExecutionTime = ScheduledFutureTask.nanoTime();            if (lastExecutionTime &gt;= deadline) &#123;                break;            &#125;        &#125;        task = pollTask();        if (task == null) &#123;            lastExecutionTime = ScheduledFutureTask.nanoTime();            break;        &#125;    &#125;    //这个方法会调用tailTask中的所有任务,目前没有看到哪里向tailTask中添加任务    afterRunningAllTasks();    this.lastExecutionTime = lastExecutionTime;    return true;&#125;\n目前taskQueue中只有一个任务,任务内容就是运行register0()。  \nregister0这里的promise就是包装了ServerSocketChannel实例的DefaultChannelPromise1234567891011121314151617181920212223        private void register0(ChannelPromise promise) &#123;            try &#123;                //......                //neverRegistered默认值是true                boolean firstRegistration = neverRegistered;                doRegister();                //......        &#125;//AbstractNioChannel#doRegister      protected void doRegister() throws Exception &#123;        boolean selected = false;        for (;;) &#123;            try &#123;//0的意思是清空目前的interest set(目前是注册阶段)                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);                return;            &#125; catch (CancelledKeyException e) &#123;                //...            &#125;        &#125;    &#125;\n走到这里,netty相关就走完了,接下来就是JDK底层的处理,暂时不分析(能力不够),回到register0方法12345678910111213141516171819202122232425//register0pipeline.invokeHandlerAddedIfNeeded();//DefaultChannelPipeline#invokeHandlerAddedIfNeededfinal void invokeHandlerAddedIfNeeded() &#123;    assert channel.eventLoop().inEventLoop();    if (firstRegistration) &#123;//这个值默认是true        firstRegistration = false;        //这里要执行的是addLast0中实例化的pendingHandlerCallbackHead        callHandlerAddedForAllHandlers();    &#125;&#125;//pendingHandlerCallbackHead的逻辑就是调用了callHandlerAdded0//DefaultChannelPipeline#callHandlerAdded0private void callHandlerAdded0(final AbstractChannelHandlerContext ctx) &#123;    try &#123;        //修改context(最开始调用init时实例化的context)的handlerState为Complete        ctx.setAddComplete();        ctx.handler().handlerAdded(ctx);    &#125; catch (Throwable t) &#123;        //......    &#125;&#125;\n  在最开始分析的ServereBootstrap#init时,其代码内部通过调用addLast实例化context并添加了一个ChannelInitializer。  这里的ctx.handler.handlerAdded(ctx)非常简单,就是调用initChannel方法,这里把当时initChannel的实现贴一下12345678910111213141516171819//ServerBootStrap#initp.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;    @Override    public void initChannel(final Channel ch) throws Exception &#123;        final ChannelPipeline pipeline = ch.pipeline();        ChannelHandler handler = config.handler();//返回null        if (handler != null) &#123;            pipeline.addLast(handler);        &#125;        ch.eventLoop().execute(new Runnable() &#123;            @Override            public void run() &#123;                pipeline.addLast(new ServerBootstrapAcceptor(                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));            &#125;        &#125;);    &#125;&#125;);\n可以看到,这里是向pipeline添加ChannelInboundHandlerAdapter的子类ServerBootstrapAcceptor的实例对象构造方法中的五个参数,分别为NioServerSocketChannel实例;用于处理连接的NioEventLoopGroup(最开始的workerGroup);EceoServer中自己实现的ChannelInitializer;后面两个就是ChannelOption和AttributeKey(前面提到过)实例化方法中,除了变量的赋值以外,还将channel(目前是NioServerSocketChannel)的autoRead设置为true,这样context会自动调用read方法读取数据。至于对这个Acceptor的addLast,其最终是一个空调用,不再分析,再次回到register0方法中1safeSetSuccess(promise);\n这个方法最终走到一个十分关键的方法:DefaultPromise#trySuccess123456789101112131415161718//这里的result为nullpublic boolean trySuccess(V result) &#123;    if (setSuccess0(result)) &#123;        notifyListeners();        return true;    &#125;    return false;&#125;//setSuccess0为result赋值(一个普通的Object实例),继续调用setValue0    private boolean setValue0(Object objResult) &#123;    if (RESULT_UPDATER.compareAndSet(this, null, objResult) ||        RESULT_UPDATER.compareAndSet(this, UNCANCELLABLE, objResult)) &#123;        checkNotifyWaiters();        return true;    &#125;    return false;&#125;\nsetValue0方法更新了当前future的result值(原先为非空),这个result值最大的作用就是用于判断当前future是否完成(isDone),如果为null则未完成,现在这个值非null,当前future已经完成,回想一下,之前的主线程调用sync正是阻塞在当前future,现在future已经完成,所以调用checkNotifyWaiters唤醒所有等待者(对于本例来说就是主线程),这个方法也很简单,就是调用Object#notifyAll至此主线程已被唤醒,注意:register线程还没有结束(register0方法还没有结束),这里我们假设主线程先执行(或执行的更快),他尝试关闭ServerBootStrap12345f.channel().closeFuture().sync();//看一下closeFuture返回什么  //AbstractChannelprivate final CloseFuture closeFuture = new CloseFuture(this);\n可以看到该方法返回一个新的future,紧接着的sync调用再次将主线程阻塞(这次是阻塞在closeFuture上)。  \n下面再回到register线程上来,唤醒所有等待者后,setValu0返回true,由上面的trySuccess可以看到,接下来要执行notifyListeners(),唤醒所有的Listener,我们在之前的ServerBootStrap的启动#2中分析doBind时可以看到下面这段代码1234567891011121314final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);regFuture.addListener(new ChannelFutureListener() &#123;    @Override    public void operationComplete(ChannelFuture future) throws Exception &#123;        Throwable cause = future.cause();        if (cause != null) &#123;            //register过程中出错了            promise.setFailure(cause);        &#125; else &#123;            promise.registered();            doBind0(regFuture, channel, localAddress, promise);        &#125;    &#125;&#125;);\n这里的notifyListeners就会唤醒这个listener,现在终于该执行最关键的doBind0方法了……1234567891011121314private static void doBind0(        final ChannelFuture regFuture, final Channel channel,        final SocketAddress localAddress, final ChannelPromise promise) &#123;    channel.eventLoop().execute(new Runnable() &#123;        @Override        public void run() &#123;            if (regFuture.isSuccess()) &#123;                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);            &#125; else &#123;                promise.setFailure(regFuture.cause());            &#125;        &#125;    &#125;);&#125;\nchannel.bind一路调用最终走到AbstractUnsafe#bind,这里分段看这个方法123456789101112131415161718192021222324252627282930313233343536public final void bind(final SocketAddress localAddress, final ChannelPromise promise) &#123;    //......    //isActive返回false,因为当前socket还没有bind    boolean wasActive = isActive();    try &#123;        doBind(localAddress);    &#125; catch (Throwable t) &#123;        safeSetFailure(promise, t);        closeIfClosed();        return;    &#125;    //.....&#125;//doBind调用:NioServerSocketChannel#doBindprotected void doBind(SocketAddress localAddress) throws Exception &#123;    if (PlatformDependent.javaVersion() &gt;= 7) &#123;        javaChannel().bind(localAddress, config.getBacklog());    &#125; else &#123;        javaChannel().socket().bind(localAddress, config.getBacklog());    &#125;&#125;//此时最底层的socket已经完成bind,已经绑定到指定端口,继续来看bind方法public final void bind(final SocketAddress localAddress, final ChannelPromise promise) &#123;    //这里isActive将会返回true,因为socket已经绑定成功    if (!wasActive &amp;&amp; isActive()) &#123;        invokeLater(new Runnable() &#123;            @Override            public void run() &#123;                pipeline.fireChannelActive();            &#125;        &#125;);    &#125;    //......&#125;\n此时只剩下最后一个方法,pipeline.fireChannelActive()最终会走到HeadContext#channelActive12345678910111213141516171819    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;        ctx.fireChannelActive();        //上面的代码分析中说到过,AutoRead已经设置为true        readIfIsAutoRead();    &#125;    //接下来一串调用最终走到HeadContext#read------&gt;AbstractChannel#doBeginReadprotected void doBeginRead() throws Exception &#123;    //...    readPending = true;    final int interestOps = selectionKey.interestOps();    //在之前,代码调用了selectionKey.interestOps(0),所以这个if判断一定为true    //回想NioServerSocketChannel的实例化中,曾经传过OP_ACCEPT参数,那个参数最终被保存在      //readInterestOp中,在这里终于将OP_ACCEPT这个事件注册到了selectionKey中    if ((interestOps &amp; readInterestOp) == 0) &#123;        selectionKey.interestOps(interestOps | readInterestOp);    &#125;&#125;\n至此,ServerSocketChannel终于绑定到了端口,接下来就是分析”Server端在哪里被阻塞以等待客户端连接?“  \n等待连接task执行完后,再次回到NioEventLoop的run方法,这一次hasTasks返回false,并向switch返回SelectStrategy.SELECT12345case SelectStrategy.SELECT:    select(wakenUp.getAndSet(false));    if (wakenUp.get()) &#123;        selector.wakeup();    &#125;\nwakeUp是AtomicBoolean实例,默认返回false123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private void select(boolean oldWakenUp) throws IOException &#123;    Selector selector = this.selector;    try &#123;        //记录select方法的调用次数        int selectCnt = 0;        long currentTimeNanos = System.nanoTime();        //delayNanos返回定时任务队列中最近的那个任务还要多长时间才能执行        //没有定时任务时返回1秒(本例返回1秒)        long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);        for (;;) &#123;            long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;            //timemoutMillis&lt;=0说明delayNanos返回值小于500000L,那么立马调用selectNow并结束循环            //以便稍后调用定时任务            if (timeoutMillis &lt;= 0) &#123;                if (selectCnt == 0) &#123;                    selector.selectNow();                    selectCnt = 1;                &#125;                break;            &#125;            //如果此时队列中有任务了,调用selectNow并结束循环,以便执行任务            if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;                selector.selectNow();                selectCnt = 1;                break;            &#125;            //否则进行阻塞式select(阻塞时间为1秒)            int selectedKeys = selector.select(timeoutMillis);            selectCnt ++;            //要么有任务,要么有IO事件,结束循环            if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;                break;            &#125;            if (Thread.interrupted()) &#123;                //......                selectCnt = 1;                break;            &#125;            long time = System.nanoTime();            if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;                selectCnt = 1;            &#125; else if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp;                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;                //......                rebuildSelector();                selector = this.selector;                selector.selectNow();                selectCnt = 1;                break;            &#125;            //更新currentTimeNanos,这样下一轮的循环中,timeoutMillis&lt;=0            //就会退出循环            currentTimeNanos = time;        &#125;        if (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;            //......        &#125;    &#125; catch (CancelledKeyException e) &#123;        //......    &#125;&#125;\n至此,已经找到了服务端阻塞的地方,他通过NioEventLoop#run中的无限循环,以一秒为超时时间,不断调用select等待IO事件。服务端的实例化即启动至此分析完毕,下一篇分析客户端和服务端的交互。","dateCreated":"2018-09-24T15:21:31+08:00","dateModified":"2018-09-26T09:24:57+08:00","datePublished":"2018-09-24T15:21:31+08:00","description":"Netty基本架构(4.1.x-fianll)/基本源码(Nio Server端实例化配置及启动)","headline":"Netty基础源码","image":["https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/nettyCover.png","https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2018/09/24/Netty基础源码1/"},"publisher":{"@type":"Organization","name":"一条咸鱼","sameAs":[],"image":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg","logo":{"@type":"ImageObject","url":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"}},"url":"http://yoursite.com/2018/09/24/Netty基础源码1/","thumbnailUrl":"https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/nettyCover.png"}</script>
    <meta name="description" content="Netty基本架构(4.1.x-fianll)/基本源码(Nio Server端实例化配置及启动)">
<meta property="og:type" content="blog">
<meta property="og:title" content="Netty基础源码">
<meta property="og:url" content="http://yoursite.com/2018/09/24/Netty基础源码1/index.html">
<meta property="og:site_name" content="一条咸鱼">
<meta property="og:description" content="Netty基本架构(4.1.x-fianll)/基本源码(Nio Server端实例化配置及启动)">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/1/EventLoopGroup.png">
<meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/1/NioEventLoop.png">
<meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/1/ServerBootStrap.png">
<meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/1/ChannelInitializer.png">
<meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/1/NioServerSocketChannel.png">
<meta property="og:updated_time" content="2018-09-26T01:24:57.636Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Netty基础源码">
<meta name="twitter:description" content="Netty基本架构(4.1.x-fianll)/基本源码(Nio Server端实例化配置及启动)">
<meta name="twitter:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/1/EventLoopGroup.png">
<meta property="fb:app_id" content="[object Object]">
    
    
        
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg"/>
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/nettyCover.png"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/nettyCover.png" />
    
    
        <meta property="og:image" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg" />
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-du2xmrqdqrl2ollgeiw050kpl6l4nbyz7bumjuurjgsxyopifvukebxc9lqe.min.css">
    <!--STYLES END-->
    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">一条咸鱼</a>
    </div>
    
        
            <a class="header-right-picture " href="#about">
        
        
            <img class="header-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
                </a>
                <h4 class="sidebar-profile-name">一条咸鱼</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Java Developer</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/ " title="首页">
                    
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link open-algolia-search" href="/all-archives" title="归档">
                    
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a class="sidebar-button-link " href="/about" title="关于">
                    
                        <i class="sidebar-button-icon fa fa-user" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
        <div class="post-header-cover
                    text-center
                    post-header-cover--full" style="background-image:url('https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fcover%2Fcover.jpg');" data-behavior="4">
            
                <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            Netty基础源码
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-09-24T15:21:31+08:00">
	
		    9月 24, 2018
    	
    </time>
    
</div>

    
</div>

            
        </div>

            <div id="main" data-behavior="4"
                 class="hasCover
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <!-- excerpt -->
<h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本组件-架构"><span class="toc-text">基本组件/架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BootStrap"><span class="toc-text">BootStrap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventLoop-EventLoopGroup"><span class="toc-text">EventLoop/EventLoopGroup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Channel"><span class="toc-text">Channel</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ChannelPipelin-ChannelHandler-ChannelInitializer"><span class="toc-text">ChannelPipelin/ChannelHandler/ChannelInitializer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bytebuf"><span class="toc-text">Bytebuf</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Echo代码-Server"><span class="toc-text">Echo代码(Server)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EchoServer"><span class="toc-text">EchoServer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EchoServerHandler"><span class="toc-text">EchoServerHandler</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Server源码分析"><span class="toc-text">Server源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NioEventLoopGroup的初始化-1"><span class="toc-text">NioEventLoopGroup的初始化#1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Netty的FastThread"><span class="toc-text">Netty的FastThread</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FastThreadLocal实例化"><span class="toc-text">FastThreadLocal实例化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FastThreadLocal-set"><span class="toc-text">FastThreadLocal#set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FastThreadLocal-removeAll"><span class="toc-text">FastThreadLocal#removeAll</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NioEventLoopGroup的初始化-2"><span class="toc-text">NioEventLoopGroup的初始化#2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NioEventLoop"><span class="toc-text">NioEventLoop</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ServerBootStrap的配置"><span class="toc-text">ServerBootStrap的配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ChannelOption-amp-ChannelConfig"><span class="toc-text">ChannelOption&amp;ChannelConfig</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ServerBootStrap的启动-1"><span class="toc-text">ServerBootStrap的启动#1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ServerBootStrap-initAndRegister-1"><span class="toc-text">ServerBootStrap#initAndRegister#1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ServerChannel的实例化"><span class="toc-text">ServerChannel的实例化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ServerBootStrap-initAndRegister-2"><span class="toc-text">ServerBootStrap#initAndRegister#2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DefaultChannelPipeline-addLast"><span class="toc-text">DefaultChannelPipeline#addLast</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ServerBootStrap-initAndRegister-3"><span class="toc-text">ServerBootStrap#initAndRegister#3</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ServerBootStrap的启动-2"><span class="toc-text">ServerBootStrap的启动#2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DefaultChannelPromise-sync"><span class="toc-text">DefaultChannelPromise#sync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#register-amp-run"><span class="toc-text">register&amp;run</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#run"><span class="toc-text">run</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#register0"><span class="toc-text">register0</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#等待连接"><span class="toc-text">等待连接</span></a></li></ol></li></ol></li></ol>
<h1 id="基本组件-架构"><a href="#基本组件-架构" class="headerlink" title="基本组件/架构"></a>基本组件/架构</h1><h2 id="BootStrap"><a href="#BootStrap" class="headerlink" title="BootStrap"></a>BootStrap</h2><p>引导类启动器,进行各种配置的组装,启动Netty程序,设置Handler,绑定端口。同时客户端使用BootStrap,服务端使用ServerBootStrap。  </p>
<h2 id="EventLoop-EventLoopGroup"><a href="#EventLoop-EventLoopGroup" class="headerlink" title="EventLoop/EventLoopGroup"></a>EventLoop/EventLoopGroup</h2><p>一个EventLoop实例对应一个线程(永不改变),通过将通道(连接)注册到EventLoop上(多个Channel可以注册到同一个EventLoop上),该EventLoop对应的线程就可以处理该Channel上的所有IO事件(也只由该线程处理)。<br>EventLoopGroup是多个EventLoop的集合(JDK线程池的扩展),BootStrap需要EventLoopGroup实例用来处理连接(服务端需要两个)。<br>类图<br><img src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/1/EventLoopGroup.png" alt></p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Netty为了统一各种IO(BIO/NIO…)模式,协议(UDP/TCP…)下的API的统一性,自定义了表示连接的通道接口,Channel的所有IO操作都是异步的,返回一个ChannelFuture对象(有点像JDK的Future),可以在该ChanneFuture上绑定监听器,当操作完成后会调用相应方法。  </p>
<h2 id="ChannelPipelin-ChannelHandler-ChannelInitializer"><a href="#ChannelPipelin-ChannelHandler-ChannelInitializer" class="headerlink" title="ChannelPipelin/ChannelHandler/ChannelInitializer"></a>ChannelPipelin/ChannelHandler/ChannelInitializer</h2><p>ChannelPipeline是与Channel一一对应的链表(责任链模式)。<br>用户通过自定义ChannelHandler,netty将其注册到ChannelPipeline上来处理各种各样的事件,Handler基本划分为InboundHandler/OutboundHandler/DuplexHandler,分别处理输出/输出/输入+输出事件,用Netty自动调用方法(自动辨认In/Out)。<br>ChannelInitalizer是一个特殊的Handler,他的主要作用就是初始化Channel(重写initChannel),当Channel被注册到EventLoop,Initializer注册到ChannelPipeline后,会自动调用initChannel方法,初始化完毕后,Initializer会被从ChannelPipeline上移除。  </p>
<h2 id="Bytebuf"><a href="#Bytebuf" class="headerlink" title="Bytebuf"></a>Bytebuf</h2><p>netty自己实现的缓冲区,相较于JDK的更加易用,同时使用了内存池,高效的内存放配算法,零拷贝等提升性能。</p>
<h1 id="Echo代码-Server"><a href="#Echo代码-Server" class="headerlink" title="Echo代码(Server)"></a>Echo代码(Server)</h1><h2 id="EchoServer"><a href="#EchoServer" class="headerlink" title="EchoServer"></a>EchoServer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">"port"</span>, <span class="string">"8007"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Configure the server.</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class)</span><br><span class="line">             .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">             .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     ChannelPipeline p = ch.pipeline();</span><br><span class="line">                     p.addLast(serverHandler);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">            <span class="comment">// Start the server.</span></span><br><span class="line">            ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line">            <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="EchoServerHandler"><a href="#EchoServerHandler" class="headerlink" title="EchoServerHandler"></a>EchoServerHandler</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ByteBuf in = (ByteBuf) msg;</span><br><span class="line">        System.out.println(in.toString());</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Close the connection when an exception is raised.</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Server源码分析"><a href="#Server源码分析" class="headerlink" title="Server源码分析"></a>Server源码分析</h1><h2 id="NioEventLoopGroup的初始化-1"><a href="#NioEventLoopGroup的初始化-1" class="headerlink" title="NioEventLoopGroup的初始化#1"></a>NioEventLoopGroup的初始化#1</h2><p>最终调用的实例化方法如下,此时未指定情况下,nThreads为0,excutor为null,selectProvider为平台相关的SelectorProvider实例(该实例的open方法返回Selector,Linux2.6以上Selector使用epoll),selectStrategyFactory是默认配置(目前不清楚这个实例在哪里用到,看名字像是挑选任务的策略器?),RejectedExecutionHandlers.reject()是拒绝策略(和JDK线程池一样),默认处理方法是直接抛异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>走到父类的实例化方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, EventExecutorChooserFactory chooserFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, chooserFactory, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此处会修改nThreads值(如果为0),默认值的计算如下。<br>PS:跟进availableProcessors()方法后,如果NettyRuntime记录的处理器数值是0,那么会调用JDK的Runtime来获取处理器的值,然后设置并返回该值,那么这个方法应该不会返回0,那Math.max的比较意义是什么呢……<br>难道说Runtime获取到的可用处理器数会小于1或者等于0???<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(</span><br><span class="line">        <span class="string">"io.netty.eventLoopThreads"</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br></pre></td></tr></table></figure></p>
<p>最终走到真正的实例化代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;<span class="comment">//</span></span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面说过,默认情况下executor为null,记下来看一下Netty的默认executor实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    threadFactory.newThread(command).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该线程池的实现就是为每个Runnable都通过调用newDefaultThreadFactory()返回的线程工厂new一个Thread以执行任务,关键就是这个默认线程工厂以及其实例化的Thread。  </p>
<p>DefaultThreadFactory#newThread(Runnable r)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用重载方法,将传入的Runnable封装为一个FastThreadLocalRunnable</span></span><br><span class="line">    Thread t = newThread(FastThreadLocalRunnable.wrap(r), prefix + nextId.incrementAndGet());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon() != daemon) &#123;</span><br><span class="line">            t.setDaemon(daemon);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != priority) &#123;</span><br><span class="line">            t.setPriority(priority);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">        <span class="comment">// Doesn't matter even if failed to set.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FastThreadLocalRunnable与Runnable的唯一不同就是run方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">//这里的runnable就是上面execute传入的command</span></span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        FastThreadLocal.removeAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Netty的FastThread"><a href="#Netty的FastThread" class="headerlink" title="Netty的FastThread"></a>Netty的FastThread</h3><p>Netty并没有直接使用JDK的Thread做Reactor线程,他使用了继承自Thread的FastThreadLocalThread,重要原因之一是Netty实现了FastThreadLocal/InternalThreadLocalMap(替代ThreadLocal和ThreadLocalMap),他在高并发的情况该提供了更好的性能。<br>ThreadLocal使用threadLocalHashCode查找元素在Map中的位置,hash冲突时,效率降低。<br>FastThreadLocal与ThreadLocal不同之处在于他不再使用hashCode,而是直接使用index,每个FastThreadLocal实例对应一个全局唯一的index,在从map中get元素时,直接返回objects[index]。  </p>
<h4 id="FastThreadLocal实例化"><a href="#FastThreadLocal实例化" class="headerlink" title="FastThreadLocal实例化"></a>FastThreadLocal实例化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FastThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//nextVariableIndex调用InternalThreadLocalMap中的static final</span></span><br><span class="line">    <span class="comment">//AtomicInteger#getAndIncrement(),全局唯一index</span></span><br><span class="line">    index = InternalThreadLocalMap.nextVariableIndex();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="FastThreadLocal-set"><a href="#FastThreadLocal-set" class="headerlink" title="FastThreadLocal#set"></a>FastThreadLocal#set</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//UNSET是一个占位符,remove的时候会分析</span></span><br><span class="line">    <span class="keyword">if</span> (value != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">        InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.get();</span><br><span class="line">        <span class="keyword">if</span> (setKnownNotUnset(threadLocalMap, value)) &#123;</span><br><span class="line">            registerCleaner(threadLocalMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InternalThreadLocalMap.get()就是尝试获取当前Thread的map,如果是FastThreadLocalThread的实例,直接返回即可(如果为null会进行初始化),如果是普通Thread,需要通过slowGet获取InternalThreadLocalMap实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InternalThreadLocalMap <span class="title">slowGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//slowThreadLocalMap是为了兼容"JDK的Thread使用FastThreadLocal"的情况,其是一个static final实例</span></span><br><span class="line">    ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = UnpaddedInternalThreadLocalMap.slowThreadLocalMap;</span><br><span class="line">    <span class="comment">//通过JDK的threadLocal的get尝试拿到InternalThreadLocalMap,返回null</span></span><br><span class="line">    InternalThreadLocalMap ret = slowThreadLocalMap.get();</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//为JDK的thread设置InternalThreadLocalMap</span></span><br><span class="line">        <span class="comment">//将InternalThreadLocalMap设置到ThreadLocal中,此时用户的JDK Thread的已经通过slowThreadLocalMap</span></span><br><span class="line">        <span class="comment">// 拥有了属于自己的InternalThreadLocalMap实例,普通Thread也就可以使用FastThreadLocal</span></span><br><span class="line">        ret = <span class="keyword">new</span> InternalThreadLocalMap();</span><br><span class="line">        slowThreadLocalMap.set(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此,get方法中已经获取到了InternalThreadLocalMap(无论当前线程是普通线程还是Fast线程),随后进行真正的元素set<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setKnownNotUnset</span><span class="params">(InternalThreadLocalMap threadLocalMap, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadLocalMap.setIndexedVariable(index, value)) &#123;</span><br><span class="line">     addToVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setIndexedVariable</span><span class="params">(<span class="keyword">int</span> index, Object value)</span> </span>&#123;</span><br><span class="line">    Object[] lookup = indexedVariables;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; lookup.length) &#123;</span><br><span class="line">        Object oldValue = lookup[index];</span><br><span class="line">        lookup[index] = value;</span><br><span class="line">        <span class="comment">//如果是设置新值,返回true,如果是replace,返回false</span></span><br><span class="line">        <span class="keyword">return</span> oldValue == UNSET;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//需要扩容,这个地方个人认为算是FastThreadLocal设计的一个缺点?</span></span><br><span class="line">        expandIndexedVariableTableAndSet(index, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的set方法可以看到,如果当前FastThreadLocal的index大于length,就需要对数组进行扩容,但index本身就是递增的值,如果出现“某个FastThreadLocal被回收/不再使用”的情况,那么他的index对应的数组位置就会被一直“占着”,而无法使用(因为其index全局唯一且递增),回想JDK的实现,由于使用的是HashCode+线性探测法,所以并不会出现这种的“空间浪费”。  </p>
<p>setKnownNotUnset在插入完元素后<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addToVariablesToRemove</span><span class="params">(InternalThreadLocalMap threadLocalMap, FastThreadLocal&lt;?&gt; variable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//variablesToRemoveIndex是static final值</span></span><br><span class="line">    Object v = threadLocalMap.indexedVariable(variablesToRemoveIndex);</span><br><span class="line">    Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove;</span><br><span class="line">    <span class="keyword">if</span> (v == InternalThreadLocalMap.UNSET || v == <span class="keyword">null</span>) &#123;</span><br><span class="line">        variablesToRemove = Collections.newSetFromMap(<span class="keyword">new</span> IdentityHashMap&lt;FastThreadLocal&lt;?&gt;, Boolean&gt;());</span><br><span class="line">        threadLocalMap.setIndexedVariable(variablesToRemoveIndex, variablesToRemove);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;</span><br><span class="line">    &#125;<span class="comment">//通过variablesToRemove记录所有那些"Index在InternalThreadLocalMap有对应元素的"FastThreadLocal,方便removeAll。</span></span><br><span class="line">    variablesToRemove.add(variable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来执行set中的最后一个方法registerCleaner<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerCleaner</span><span class="params">(<span class="keyword">final</span> InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (FastThreadLocalThread.willCleanupFastThreadLocals(current) || threadLocalMap.isCleanerFlagSet(index)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    threadLocalMap.setCleanerFlag(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法最终的执行结果就是将FastThreadLocal的Index设置到InternalThreadLocalMap#BitSet中(无论当前线程类型是什么),暂时不清楚这个BitSet是用来干什么的。<br>至此set执行完毕,get方法很简单,获取map-&gt;根据index获取value-&gt;value若为“占位符UNSET”,调用初始化方法(默认初始化为null),set方法,register方法,最后返回(null)。  </p>
<h4 id="FastThreadLocal-removeAll"><a href="#FastThreadLocal-removeAll" class="headerlink" title="FastThreadLocal#removeAll"></a>FastThreadLocal#removeAll</h4><p>在之前的FastThreadLocalRunnable#run方法中可以看到,finally调用了removeAll。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    InternalThreadLocalMap threadLocalMap = InternalThreadLocalMap.getIfSet();</span><br><span class="line">    <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">//拿到variablesToRemoveIndex中的元素(set方法中分析过)</span></span><br><span class="line">        Object v = threadLocalMap.indexedVariable(variablesToRemoveIndex);</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;</span><br><span class="line">            FastThreadLocal&lt;?&gt;[] variablesToRemoveArray =</span><br><span class="line">                    variablesToRemove.toArray(<span class="keyword">new</span> FastThreadLocal[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">//遍历remove</span></span><br><span class="line">            <span class="keyword">for</span> (FastThreadLocal&lt;?&gt; tlv: variablesToRemoveArray) &#123;</span><br><span class="line">                tlv.remove(threadLocalMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        InternalThreadLocalMap.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来先分析FastThreadLocal的remove<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(InternalThreadLocalMap threadLocalMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadLocalMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将数组中的index位元素设置为占位符(UNSET)</span></span><br><span class="line">    Object v = threadLocalMap.removeIndexedVariable(index);</span><br><span class="line">    removeFromVariablesToRemove(threadLocalMap, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (v != InternalThreadLocalMap.UNSET) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//默认空实现</span></span><br><span class="line">            onRemoval((V) v);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            PlatformDependent.throwException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续深入removeFromVariablesToRemove<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeFromVariablesToRemove</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        InternalThreadLocalMap threadLocalMap, FastThreadLocal&lt;?&gt; variable)</span> </span>&#123;</span><br><span class="line">    Object v = threadLocalMap.indexedVariable(variablesToRemoveIndex);</span><br><span class="line">    <span class="keyword">if</span> (v == InternalThreadLocalMap.UNSET || v == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前FastThreadLocal从set中移除,这个特殊位置的set只记录那些当前线程使用了的FastThreadLocal</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Set&lt;FastThreadLocal&lt;?&gt;&gt; variablesToRemove = (Set&lt;FastThreadLocal&lt;?&gt;&gt;) v;</span><br><span class="line">    variablesToRemove.remove(variable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>遍历调用remove后,当前线程的所有FastThreadLocal已经被从map中移除,接下来走到finally中处理map<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread thread = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (thread <span class="keyword">instanceof</span> FastThreadLocalThread) &#123;</span><br><span class="line">        <span class="comment">//将FastThreadLocalThread的map置null</span></span><br><span class="line">        ((FastThreadLocalThread) thread).setThreadLocalMap(<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果是普通线程,从UnpaddedInternalThreadLocalMap中移除当前线程的map</span></span><br><span class="line">        slowThreadLocalMap.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此,当前线程的所有元素,FastThreadLocal,map都已被移除,线程可以结束。  </p>
<h2 id="NioEventLoopGroup的初始化-2"><a href="#NioEventLoopGroup的初始化-2" class="headerlink" title="NioEventLoopGroup的初始化#2"></a>NioEventLoopGroup的初始化#2</h2><p>回到NioEventLoopGroup的初始化,代码走到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">//executor就是之前分析的ThreadPerTaskExecutor,args是一大堆默认的参数列表</span></span><br><span class="line">        <span class="comment">//newChile是实例化具体的EventLoop,本例中指的就是NioEventLoop,所以调用</span></span><br><span class="line">        <span class="comment">//NioEventLoopGroup#newChild</span></span><br><span class="line">        children[i] = newChild(executor, args);</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"failed to create a child event loop"</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;<span class="comment">//如果EventLoop创建失败,关闭所有之前创建的EventLoop,暂时不分析</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>按照指定线程数创建线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//args[0]是平台相关SelectorProvider,args[1]是DefaultEventExecutorChooserFactory实例</span></span><br><span class="line">    <span class="comment">//args[2]是直接抛异常的拒绝处理器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">        ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="NioEventLoop"><a href="#NioEventLoop" class="headerlink" title="NioEventLoop"></a>NioEventLoop</h3><p><img src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/1/NioEventLoop.png" alt><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line">    <span class="comment">//DEFAULT_MAX_PENDING_TASKS默认为Integer最大值</span></span><br><span class="line">    <span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);</span><br><span class="line">    <span class="keyword">if</span> (selectorProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"selectorProvider"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strategy == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"selectStrategy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    provider = selectorProvider;</span><br><span class="line">    <span class="comment">//获取Selector(难道是一个EventLoop对应一个Selector???)SelectorTuple是对Selector的封装,</span></span><br><span class="line">    <span class="comment">// 从构造函数看,其selector/unwrappedSelector都是同一个Selector实例,暂时不知道为什么这么设计......</span></span><br><span class="line">    <span class="keyword">final</span> SelectorTuple selectorTuple = openSelector();</span><br><span class="line">    selector = selectorTuple.selector;</span><br><span class="line">    unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">    selectStrategy = strategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SingleThreadEventLoop的构造方法中实例化了一个DEFAULT_MAX_PENDING_TASKS大小的的LinkedBlockingQueue(注释说是任务队列)赋值给tailTasks<br>接下来走到SingleThreadEventExecutor实例化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventExecutor</span><span class="params">(EventExecutorGroup parent, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">boolean</span> addTaskWakesUp, <span class="keyword">int</span> maxPendingTasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    RejectedExecutionHandler rejectedHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="comment">//如果为true则只有在调用addTask方法时才会唤醒当前线程,默认为false</span></span><br><span class="line">    <span class="keyword">this</span>.addTaskWakesUp = addTaskWakesUp;</span><br><span class="line">    <span class="comment">//应该为Integer.MAX_VALUE(为什么要再比一次?)前面的DEFAULT就是与16比,选最大值</span></span><br><span class="line">    <span class="keyword">this</span>.maxPendingTasks = Math.max(<span class="number">16</span>, maxPendingTasks);</span><br><span class="line">    <span class="keyword">this</span>.executor = ObjectUtil.checkNotNull(executor, <span class="string">"executor"</span>);</span><br><span class="line">    <span class="comment">//这里为什么又new一个任务队列？暂时不知道......</span></span><br><span class="line">    taskQueue = newTaskQueue(<span class="keyword">this</span>.maxPendingTasks);</span><br><span class="line">    rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, <span class="string">"rejectedHandler"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="ServerBootStrap的配置"><a href="#ServerBootStrap的配置" class="headerlink" title="ServerBootStrap的配置"></a>ServerBootStrap的配置</h2><p><img src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/1/ServerBootStrap.png" alt><br>首先配置EventLoopGroup,parentGroup就是前面nThreads=1的Group,childGroup是默认线程数量Group<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.group(parentGroup);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后是调用父类的channel方法实例化一个channel工厂<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="comment">//实例化ReflectiveChannelFactory(一个通过反射调用默认构造器的工厂)</span></span><br><span class="line">    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(channelClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来调用option方法进行配置  </p>
<h3 id="ChannelOption-amp-ChannelConfig"><a href="#ChannelOption-amp-ChannelConfig" class="headerlink" title="ChannelOption&amp;ChannelConfig"></a>ChannelOption&amp;ChannelConfig</h3><p>Netty中的每个Channel都有对应的配置信息类(实现ChannelConfig接口),如NioServerSocketChannel对应的ServerSocketChannelConfig,这个Config记录了该Channel的一些底层连接配置(如超时时间,连接缓冲区大小,连接队列大小)。<br>ChannelOption<t>提供了一种类型安全的配置ChannelConfig的方式,使得在配置信息时并不需要关注Channel的实际类型,其中的泛型T指的是该配置对应的值的类型,如server代码中的.option(ChannelOption.SO_BACKLOG, 100)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">B <span class="title">option</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">            options.remove(option);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//options是存储ChannelOption的LinkedHashMap</span></span><br><span class="line">        <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">            options.put(option, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p>接下来的handler()&amp;childHandler()方法分别将handler设置到AbstractBootstrap&amp;ServerBootstrap中,此处ServerBootStrap中设置的是一个ChannelInitializer<socketchannel>(),他是ChannelInboundHandlerAdapter的抽象子类,重要的是他的initChannel方法,后面分析,其上的Sharable注解表示该handler的实例可以被多个ChannelPipeline共享,即他不保存有状态的信息。<br><img src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/1/ChannelInitializer.png" alt></socketchannel></p>
<h2 id="ServerBootStrap的启动-1"><a href="#ServerBootStrap的启动-1" class="headerlink" title="ServerBootStrap的启动#1"></a>ServerBootStrap的启动#1</h2><p>bind方法一路调用,走到第一个主要方法doBind(SocketAddress),参数是根据port实例化的InetSocketAddress,这个方法调用链很长,分段分析。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ServerBootStrap-initAndRegister-1"><a href="#ServerBootStrap-initAndRegister-1" class="headerlink" title="ServerBootStrap#initAndRegister#1"></a>ServerBootStrap#initAndRegister#1</h3><p>首先分析doBind中的initAndRegister相关方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">//反射调用默认构造方法以实例化NioServerSocketChannel(是Netty对于JDK的Channel的封装)</span></span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="ServerChannel的实例化"><a href="#ServerChannel的实例化" class="headerlink" title="ServerChannel的实例化"></a>ServerChannel的实例化</h4><p><img src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/netty/1/NioServerSocketChannel.png" alt><br>channelFactory调用的是NioServerSocketChannel的无参构造方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过NioEventLoopGroup实例化时设置的SelectorProvider创建Channel实例</span></span><br><span class="line">    <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到这个ServerChannel的监听事件就是OP_ACCEPT<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);<span class="comment">//javaChannel返回的就是之前newSocket的返回值</span></span><br><span class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来到父类AbstractNioChannel,记录channel和SelectionKey.OP_ACCEPT。<br>随后AbstractChannel构造方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    id = newId();<span class="comment">//Channel的全局唯一标识符</span></span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    pipeline = newChannelPipeline();<span class="comment">//DefaultChannelPipeline实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>跟进看一下DefaultChannelPipeline的实例化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">    succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//Promise相当于可写的Future,这里的实例的主要作用就是传播Exception</span></span><br><span class="line">    voidPromise =  <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//两个Context互相连起来</span></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个Context的实例化比较简单,其中比较关键的一步是设置Context的handlerState为ADD_COMPLETE。<br>至此NioServerSocketchannel已经实例化完毕。  </p>
<h3 id="ServerBootStrap-initAndRegister-2"><a href="#ServerBootStrap-initAndRegister-2" class="headerlink" title="ServerBootStrap#initAndRegister#2"></a>ServerBootStrap#initAndRegister#2</h3><p>回到initAndRegister中调用ServerBootStrap的init以初始化ServerChannel<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">    <span class="keyword">synchronized</span> (options) &#123;<span class="comment">//遍历,为Channel实例进行配置信息的设置</span></span><br><span class="line">        setChannelOptions(channel, options, logger);</span><br><span class="line">    &#125;<span class="comment">//LinkedHashMap实例,目前其中没有数据,暂时不分析</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">    <span class="keyword">synchronized</span> (attrs) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line">    <span class="comment">//用于处理连接的NioEventLoopGroup</span></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="comment">//自己实现的ChannelInitializer</span></span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">    <span class="comment">//进行深拷贝转化为数组</span></span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (childAttrs) &#123;</span><br><span class="line">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将ChannelInitializer实例添加到ServerChannel的Pipeline上(具体其实是添加到context上)</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          <span class="comment">//这里的initChannel会在后面调用/分析</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码中最重要的就是addLast的调用  </p>
<h4 id="DefaultChannelPipeline-addLast"><a href="#DefaultChannelPipeline-addLast" class="headerlink" title="DefaultChannelPipeline#addLast"></a>DefaultChannelPipeline#addLast</h4><p>其中的group,name全为null<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line">        <span class="comment">//一个handler对应一个ChannelHandlerContext,此处进行context实例化</span></span><br><span class="line">        <span class="comment">//现根据handler为其生成name</span></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line">        addLast0(newCtx);</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先实例化一个DefaultChannelHandlerContext<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelHandlerContext(</span><br><span class="line">        DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) &#123;</span><br><span class="line">    <span class="comment">//ChannelInitializer是InboundHandler的子类,executor为null,父类只做一些简单的赋值操作</span></span><br><span class="line">    <span class="keyword">super</span>(pipeline, executor, name, isInbound(handler), isOutbound(handler));</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其次的addLas0主要做的就是将context插入到tail(在实例化ServerChannel的DefaultChannelPipeline时创建的)前面。<br>随后addLast走到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//registered表示ServerChannel第一次调用addLast,此时registered为false,说明Channel还没有注册到eventLoop</span></span><br><span class="line"><span class="keyword">if</span> (!registered) &#123;</span><br><span class="line">    <span class="comment">//修改newCtx的handlerState为ADD_PENDING</span></span><br><span class="line">    newCtx.setAddPending();</span><br><span class="line">    <span class="comment">//封装newCtx为PendingHandlerAddedTask并赋值给pendingHandlerCallbackHead</span></span><br><span class="line">    <span class="comment">//注意,这个pendingHandlerCallbackHead(PendingHandlerAddedTask的实例)</span></span><br><span class="line">    <span class="comment">//将会在后面被调用</span></span><br><span class="line">    callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时addLast方法已经返回,其中的其他代码在后面分析。  </p>
<h3 id="ServerBootStrap-initAndRegister-3"><a href="#ServerBootStrap-initAndRegister-3" class="headerlink" title="ServerBootStrap#initAndRegister#3"></a>ServerBootStrap#initAndRegister#3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//group返回的就是最开始nThreads=1的那个NioEventLoopGroup,</span></span><br><span class="line"><span class="comment">//一路调用先走到SingleThreadEventLoop#register,这个类就是NioEventLoop的父类</span></span><br><span class="line">ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line"><span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        channel.unsafe().closeForcibly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> regFuture;</span><br></pre></td></tr></table></figure>
<p>SingleThreadEventLoop#register只是将ServerSocketChannel包装一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">//将Channel封装为DefaultChannelPromise</span></span><br><span class="line">        <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//继续调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</span><br><span class="line">        promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>unsafe方法返回的是AbstractChannel的内部类AbstractUnsafe(netty的Unsafe接口的抽象实现类)的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//在这里将ServerChannel与eventLoop进行绑定</span></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">    <span class="comment">//inEventLoop是判断当前线程是否是EventLoop线程(我们现在是在主线程中启动ServerBootStrap,所以应该返回false)</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//用eventLoop线程去做register工作("异步"的体现)</span></span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//继续返回false</span></span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    <span class="comment">//把task加入到当前eventLoop的任务队列中</span></span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        startThread();</span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//state的默认值就是ST_NOT_STARTED</span></span><br><span class="line">    <span class="keyword">if</span> (state == ST_NOT_STARTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doStartThread();</span><br><span class="line">            &#125; <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//executor就是ThreadPerTaskExecutor,其会调用之前分析的线程工厂创建一个线程来执行这个任务</span></span><br><span class="line">    <span class="comment">//此时,initAndRegister方法已经返回了</span></span><br><span class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//注意,执行到这里,EventLoop的thread变量才被赋值</span></span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            <span class="comment">//任务的具体内容稍后分析</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此,initAndRegister返回了包装了ServerSocketChannel的DefaultChannelPromise,终于回到了doBind方法,然而此时只执行了doBind方法中的第一行代码…….  </p>
<h2 id="ServerBootStrap的启动-2"><a href="#ServerBootStrap的启动-2" class="headerlink" title="ServerBootStrap的启动#2"></a>ServerBootStrap的启动#2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="comment">//注释说大部分情况下,register已经完成,为了看Listener相关</span></span><br><span class="line">    <span class="comment">//这里假设register方法还没有执行完,即isDone返回false</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//register过程中出错了</span></span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.registered();</span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中向future(DefaultChannelPormise实例)添加了一个Listener,Listener的内部方法稍后分析,先分析addListener-&gt;DefaultPromise#addListener<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span> </span>&#123;</span><br><span class="line">    checkNotNull(listener, <span class="string">"listener"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//使用数组保存Listener</span></span><br><span class="line">        addListener0(listener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再次检查是否完成,如果完成,唤醒调用所有的Listener,这里的再次检查避免了</span></span><br><span class="line">    <span class="comment">//"添加Listener到数组之前Future已经完成,导致错过Listener"</span></span><br><span class="line">    <span class="comment">//这里仍然假设没有完成</span></span><br><span class="line">    <span class="keyword">if</span> (isDone()) &#123;</span><br><span class="line">        notifyListeners();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此,bind(doBind)方法已经结束,但我们假设EventLoop中调用的的register方法还没有结束,开头的实例代码中,调用了sync,继续分析。  </p>
<h3 id="DefaultChannelPromise-sync"><a href="#DefaultChannelPromise-sync" class="headerlink" title="DefaultChannelPromise#sync"></a>DefaultChannelPromise#sync</h3><p>sync方法阻塞等待future的任务完成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">sync</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        await();</span><br><span class="line">        rethrowIfFailed();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isDone()) &#123;<span class="comment">//再次检查任务是否完成</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException(toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查死锁,主要步骤就是检查当前线程是否是eventLoop线程,如果是的话说明出现了死锁,</span></span><br><span class="line">        <span class="comment">//抛出异常，当前调用sync的线程是主线程,所以没有死锁</span></span><br><span class="line">        checkDeadLock();</span><br><span class="line">        <span class="comment">//仍未完成的话,就要调用Object#wait</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!isDone()) &#123;</span><br><span class="line">                incWaiters();<span class="comment">//记录sync调用者数量</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    decWaiters();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>至此,主线程已经成功阻塞,等待eventLoop完成register后唤醒他。  </p>
<h3 id="register-amp-run"><a href="#register-amp-run" class="headerlink" title="register&amp;run"></a>register&amp;run</h3><p>eventLoop要运行的runnable是在之前分析的doStartThread中定义的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//更新最近执行任务的时间</span></span><br><span class="line">    updateLastExecutionTime();</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">//这里的run方法调用的是register方法中封装的runnable</span></span><br><span class="line">        SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">        success = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Unexpected exception from an event executor: "</span>, t);</span><br><span class="line">    &#125; <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SingleThreadEventExecutor.this对于本例来说就是NioEventLoop,下面看一下他的run方法  </p>
<h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                    select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line">                    <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                        selector.wakeup();</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                    runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是switch语句中的hastTasks,这个方法就是判断taskQueue是否为空,在SingleThreadEventExecutor#execute中曾经向其中添加过一个task,所以该方法返回true<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateStrategy</span><span class="params">(IntSupplier selectSupplier, <span class="keyword">boolean</span> hasTasks)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>selectSupplier.get()内部只是继续调用了Selector#selectNow,由于我们目前还没完成注册selectNow自然返回0,所以直接退出switch。<br>ioRatio这个int变量的意思是“IO事件的时间占比”,对于EventLoop来说有两类事要处理“IO”和“task”,这个值默认为50,即IO事件和task时间占比1:1,由于目前没有任何selectKey,所以接下来直接看else中调用的runAlltasks<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAllTasks</span><span class="params">(<span class="keyword">long</span> timeoutNanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将现在应该执行的定时任务添加到taskQueue中,暂不分析</span></span><br><span class="line">    fetchFromScheduledTaskQueue();</span><br><span class="line">    Runnable task = pollTask();</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        afterRunningAllTasks();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算终止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</span><br><span class="line">    <span class="keyword">long</span> runTasks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> lastExecutionTime;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//简单调用task.run()</span></span><br><span class="line">        safeExecute(task);</span><br><span class="line">        <span class="comment">//完成任务数+!</span></span><br><span class="line">        runTasks ++;</span><br><span class="line">        <span class="comment">//每隔64个任务检查一次时间,减少System.nanoTime的调用次数</span></span><br><span class="line">        <span class="keyword">if</span> ((runTasks &amp; <span class="number">0x3F</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        task = pollTask();</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个方法会调用tailTask中的所有任务,目前没有看到哪里向tailTask中添加任务</span></span><br><span class="line">    afterRunningAllTasks();</span><br><span class="line">    <span class="keyword">this</span>.lastExecutionTime = lastExecutionTime;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目前taskQueue中只有一个任务,任务内容就是运行register0()。  </p>
<h4 id="register0"><a href="#register0" class="headerlink" title="register0"></a>register0</h4><p>这里的promise就是包装了ServerSocketChannel实例的DefaultChannelPromise<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">                <span class="comment">//neverRegistered默认值是true</span></span><br><span class="line">                <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">                doRegister();</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractNioChannel#doRegister  </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;<span class="comment">//0的意思是清空目前的interest set(目前是注册阶段)</span></span><br><span class="line">                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>走到这里,netty相关就走完了,接下来就是JDK底层的处理,暂时不分析(能力不够),回到register0方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//register0</span></span><br><span class="line">pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//DefaultChannelPipeline#invokeHandlerAddedIfNeeded</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invokeHandlerAddedIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> channel.eventLoop().inEventLoop();</span><br><span class="line">    <span class="keyword">if</span> (firstRegistration) &#123;<span class="comment">//这个值默认是true</span></span><br><span class="line">        firstRegistration = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//这里要执行的是addLast0中实例化的pendingHandlerCallbackHead</span></span><br><span class="line">        callHandlerAddedForAllHandlers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pendingHandlerCallbackHead的逻辑就是调用了callHandlerAdded0</span></span><br><span class="line"><span class="comment">//DefaultChannelPipeline#callHandlerAdded0</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerAdded0</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//修改context(最开始调用init时实例化的context)的handlerState为Complete</span></span><br><span class="line">        ctx.setAddComplete();</span><br><span class="line">        ctx.handler().handlerAdded(ctx);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>  在最开始分析的ServereBootstrap#init时,其代码内部通过调用addLast实例化context并添加了一个ChannelInitializer。<br>  这里的ctx.handler.handlerAdded(ctx)非常简单,就是调用initChannel方法,这里把当时initChannel的实现贴一下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServerBootStrap#init</span></span><br><span class="line">p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">        ChannelHandler handler = config.handler();<span class="comment">//返回null</span></span><br><span class="line">        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pipeline.addLast(handler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>可以看到,这里是向pipeline添加ChannelInboundHandlerAdapter的子类ServerBootstrapAcceptor的实例对象<br>构造方法中的五个参数,分别为NioServerSocketChannel实例;用于处理连接的NioEventLoopGroup(最开始的workerGroup);EceoServer中自己实现的ChannelInitializer;后面两个就是ChannelOption和AttributeKey(前面提到过)<br>实例化方法中,除了变量的赋值以外,还将channel(目前是NioServerSocketChannel)的autoRead设置为true,这样context会自动调用read方法读取数据。<br>至于对这个Acceptor的addLast,其最终是一个空调用,不再分析,再次回到register0方法中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">safeSetSuccess(promise);</span><br></pre></td></tr></table></figure></p>
<p>这个方法最终走到一个十分关键的方法:DefaultPromise#trySuccess<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的result为null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">trySuccess</span><span class="params">(V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (setSuccess0(result)) &#123;</span><br><span class="line">        notifyListeners();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//setSuccess0为result赋值(一个普通的Object实例),继续调用setValue0</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setValue0</span><span class="params">(Object objResult)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (RESULT_UPDATER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, objResult) ||</span><br><span class="line">        RESULT_UPDATER.compareAndSet(<span class="keyword">this</span>, UNCANCELLABLE, objResult)) &#123;</span><br><span class="line">        checkNotifyWaiters();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>setValue0方法更新了当前future的result值(原先为非空),这个result值最大的作用就是用于判断当前future是否完成(isDone),如果为null则未完成,现在这个值非null,当前future已经完成,回想一下,之前的主线程调用sync正是阻塞在当前future,现在future已经完成,所以调用checkNotifyWaiters唤醒所有等待者(对于本例来说就是主线程),这个方法也很简单,就是调用Object#notifyAll<br>至此主线程已被唤醒,注意:register线程还没有结束(register0方法还没有结束),这里我们假设主线程先执行(或执行的更快),他尝试关闭ServerBootStrap<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line"><span class="comment">//看一下closeFuture返回什么  </span></span><br><span class="line"><span class="comment">//AbstractChannel</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CloseFuture closeFuture = <span class="keyword">new</span> CloseFuture(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p>
<p>可以看到该方法返回一个新的future,紧接着的sync调用再次将主线程阻塞(这次是阻塞在closeFuture上)。  </p>
<p>下面再回到register线程上来,唤醒所有等待者后,setValu0返回true,由上面的trySuccess可以看到,接下来要执行notifyListeners(),唤醒所有的Listener,我们在之前的ServerBootStrap的启动#2中分析doBind时可以看到下面这段代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Throwable cause = future.cause();</span><br><span class="line">        <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//register过程中出错了</span></span><br><span class="line">            promise.setFailure(cause);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            promise.registered();</span><br><span class="line">            doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里的notifyListeners就会唤醒这个listener,现在终于该执行最关键的doBind0方法了……<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>channel.bind一路调用最终走到AbstractUnsafe#bind,这里分段看这个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//isActive返回false,因为当前socket还没有bind</span></span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doBind(localAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        closeIfClosed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//doBind调用:NioServerSocketChannel#doBind</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时最底层的socket已经完成bind,已经绑定到指定端口,继续来看bind方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里isActive将会返回true,因为socket已经绑定成功</span></span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时只剩下最后一个方法,pipeline.fireChannelActive()最终会走到HeadContext#channelActive<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.fireChannelActive();</span><br><span class="line">        <span class="comment">//上面的代码分析中说到过,AutoRead已经设置为true</span></span><br><span class="line">        readIfIsAutoRead();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接下来一串调用最终走到HeadContext#read------&gt;AbstractChannel#doBeginRead</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    readPending = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">    <span class="comment">//在之前,代码调用了selectionKey.interestOps(0),所以这个if判断一定为true</span></span><br><span class="line">    <span class="comment">//回想NioServerSocketChannel的实例化中,曾经传过OP_ACCEPT参数,那个参数最终被保存在  </span></span><br><span class="line">    <span class="comment">//readInterestOp中,在这里终于将OP_ACCEPT这个事件注册到了selectionKey中</span></span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此,ServerSocketChannel终于绑定到了端口,接下来就是分析”Server端在哪里被阻塞以等待客户端连接?“  </p>
<h3 id="等待连接"><a href="#等待连接" class="headerlink" title="等待连接"></a>等待连接</h3><p>task执行完后,再次回到NioEventLoop的run方法,这一次hasTasks返回false,并向switch返回SelectStrategy.SELECT<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">    select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line">    <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">        selector.wakeup();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>wakeUp是AtomicBoolean实例,默认返回false<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//记录select方法的调用次数</span></span><br><span class="line">        <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> currentTimeNanos = System.nanoTime();</span><br><span class="line">        <span class="comment">//delayNanos返回定时任务队列中最近的那个任务还要多长时间才能执行</span></span><br><span class="line">        <span class="comment">//没有定时任务时返回1秒(本例返回1秒)</span></span><br><span class="line">        <span class="keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">            <span class="comment">//timemoutMillis&lt;=0说明delayNanos返回值小于500000L,那么立马调用selectNow并结束循环</span></span><br><span class="line">            <span class="comment">//以便稍后调用定时任务</span></span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    selector.selectNow();</span><br><span class="line">                    selectCnt = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果此时队列中有任务了,调用selectNow并结束循环,以便执行任务</span></span><br><span class="line">            <span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则进行阻塞式select(阻塞时间为1秒)</span></span><br><span class="line">            <span class="keyword">int</span> selectedKeys = selector.select(timeoutMillis);</span><br><span class="line">            selectCnt ++;</span><br><span class="line">            <span class="comment">//要么有任务,要么有IO事件,结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">                <span class="comment">//......</span></span><br><span class="line">                rebuildSelector();</span><br><span class="line">                selector = <span class="keyword">this</span>.selector;</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新currentTimeNanos,这样下一轮的循环中,timeoutMillis&lt;=0</span></span><br><span class="line">            <span class="comment">//就会退出循环</span></span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;</span><br><span class="line">            <span class="comment">//......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至此,已经找到了服务端阻塞的地方,他通过NioEventLoop#run中的无限循环,以一秒为超时时间,不断调用select等待IO事件。<br>服务端的实例化即启动至此分析完毕,下一篇分析客户端和服务端的交互。</p>
            

        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/09/24/Netty基础源码2/" data-tooltip="Netty基础源码" aria-label="上一篇: Netty基础源码">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/09/10/Linux/" data-tooltip="Linux/存储基础" aria-label="下一篇: Linux/存储基础">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2019 一条咸鱼. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/09/24/Netty基础源码2/" data-tooltip="Netty基础源码" aria-label="上一篇: Netty基础源码">
                
                    <i class="fa fa-angle-left" aria-hidden="true"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                </a>
            </li>
            <li class="post-action">
                
                    
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2018/09/10/Linux/" data-tooltip="Linux/存储基础" aria-label="下一篇: Linux/存储基础">
                
                    <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                    <i class="fa fa-angle-right" aria-hidden="true"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions" aria-label="Diesen Beitrag teilen">
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-times"></i>
    <ul class="share-options">
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli%2Fhead.jpg" alt="作者的图片">
        
            <h4 id="about-card-name">一条咸鱼</h4>
        
            <div id="about-card-bio"><p>重庆</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br>
                <p>学生</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('https://image-1256648750.cos.ap-chengdu.myqcloud.com/javerli/sideCover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-vufjrm3fmbuttogo1hxuu0w9w0sesk5iyysjuguc2hdhufot9szxg8twijry.min.js"></script>
<!--SCRIPTS END-->

    



    </body>
</html>
